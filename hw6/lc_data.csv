sortedNum,requireLen,example,tipsLen,quesClass,Fundamentals,Algorithms,Common.Data.Structures,Advanced.Data.Structures,Techniques,Math,Other,otherCom,huawei,bytedance,microsoft,google,amazon,tencent,recursion,linked-list,math,hash-table,string,binary-search,divide-and-conquer,dynamic-programming,greedy,two-pointers,sorting,backtracking,heap-priority-queue,simulation,depth-first-search,binary-tree,breadth-first-search,union-find,graph,geometry,database,topological-sort,prefix-sum,shortest-path,bitmask,difficulty,require,tips,ifcom,topicNum
0,114,3,59,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数数组和一个整数目标值，请你在该数组中找出的那整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。你可以想出一个时间复杂度小于的算法吗？,2<=nums.length<=10-10<=nums[i]<=10-10<=target<=10只会存在一个有效答案,1,2
1,99,3,51,题库,0,1,1,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个的链表，表示两个非负的整数。它们每位数字都是按照的方式存储的，并且每个节点只能存储数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头。,"每个链表中的节点数在范围[1,100]0<=Node.val<=9题目数据保证列表表示的数字不含前导零",1,3
2,26,3,33,题库,1,0,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串，请你找出其中不含有重复字符的的长度。,0<=s.length<=5*10由英文字母、数字、符号和空格组成,1,3
3,51,2,88,题库,1,2,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定两个大小分别为和的正序（从小到大）数组和。请你找出并返回这两个正序数组的。算法的时间复杂度应该为。,"nums1.length==mnums2.length==n0<=m<=10000<=n<=10001<=m+n<=2000-10<=nums1[i],nums2[i]<=10",1,3
4,49,2,28,题库,1,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，找到中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。,1<=s.length<=1000仅由数字和英文字母组成,1,2
5,107,3,55,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,将一个给定字符串根据给定的行数，以从上往下、从左到右进行Z字形排列。比如输入字符串为行数为时，排列如下：之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：。请你实现这个将字符串进行指定行数变换的函数：,"1<=s.length<=1000由英文字母（小写和大写）、','和'.'组成1<=numRows<=1000",1,1
6,57,4,8,题库,0,0,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个32位的有符号整数，返回将中的数字部分反转后的结果。如果反转后整数超过32位的有符号整数的范围，就返回0。,<=x<=2-1,1,1
7,52,3,94,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你来实现一个函数，使其能将字符串转换成一个32位有符号整数（类似C/C++中的函数）。函数的算法如下：,本题中的空白字符只包括空格字符''除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。0<=s.length<=200由英文字母（大写和小写）、数字（0-9'''+''-'和'.'组成,1,1
8,77,3,25,题库,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，如果是一个回文整数，返回；否则，返回。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。你能不将整数转为字符串来解决这个问题吗？,例如，121是回文，而123不是。<=x<=2-1,1,1
9,57,3,111,题库,1,2,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串和一个字符规律，请你来实现一个支持和的正则表达式匹配。所谓匹配，是要涵盖字符串的，而不是部分字符串。,'.'匹配任意单个字符'*'匹配零个或多个前面的那一个元素1<=s.length<=201<=p.length<=20只包含从a-z的小写字母。只包含从a-z的小写字母，以及字符和保证每次出现字符时，前面都匹配到有效的字符,1,3
10,82,2,40,题库,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个长度为的整数数组。有条垂线，第条线的两个端点是和。找出其中的两条线，使得它们与轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。你不能倾斜容器。,n==height.length2<=n<=100<=height[i]<=10,1,3
11,177,5,93,题库,1,0,1,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"罗马数字包含以下七种字符：，，，，，和。例如，罗马数字2写做，即为两个并列的1。12写做，即为+。27写做,即为++。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4不写做，而是。数字1在数字5的左边，所表示的数等于大数5减小数1得到的数值4。同样地，数字9表示为。这个特殊的规则只适用于以下六种情况：给你一个整数，将其转为罗马数字。",可以放在(5)和(10)的左边，来表示4和9。可以放在(50)和(100)的左边，来表示40和90。可以放在(500)和(1000)的左边，来表示400和900。1<=num<=3999,1,3
12,173,5,270,题库,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"罗马数字包含以下七种字符:，，，，，和。例如，罗马数字写做，即为两个并列的1。写做，即为+。写做,即为++。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4不写做，而是。数字1在数字5的左边，所表示的数等于大数5减小数1得到的数值4。同样地，数字9表示为。这个特殊的规则只适用于以下六种情况：给定一个罗马数字，将其转换成整数。","可以放在(5)和(10)的左边，来表示4和9。可以放在(50)和(100)的左边，来表示40和90。可以放在(500)和(1000)的左边，来表示400和900。1<=s.length<=15仅含字符('I','V','X','L','C','D','M')题目数据保证是一个有效的罗马数字，且表示整数在范围[1,3999]题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。IL和IM这样的例子并不符合题目要求，49应该写作XLIX，999应该写作CMXCIX。关于罗马数字的详尽书写规则，可以参考罗马数字-Mathematics",1,3
13,40,2,58,题库,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串。,1<=strs.length<=2000<=strs[i].length<=200strs[i]仅由小写英文字母组成,1,2
14,61,3,36,题库,2,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，判断是否存在三元组满足、且，同时还满足。请你返回所有和为且不重复的三元组。答案中不可以包含重复的三元组。,3<=nums.length<=3000-10<=nums[i]<=10,1,3
15,64,2,55,题库,2,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组和一个目标值。请你从中选出三个整数，使它们的和与最接近。返回这三个数的和。假定每组输入只存在恰好一个解。,3<=nums.length<=1000-1000<=nums[i]<=1000-10<=target<=10,1,3
16,69,3,46,题库,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个仅包含数字的字符串，返回所有它能表示的字母组合。答案可以按返回。给出数字到字母的映射如下（与电话按键相同）。注意1不对应任何字母。,"0<=digits.length<=4digits[i]是范围['2','9']的一个数字。",1,3
17,76,2,106,题库,2,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由个整数组成的数组，和一个目标值。请你找出并返回满足下述全部条件且的四元组（若两个四元组元素一一对应，则认为两个四元组重复）：你可以按返回答案。,"0<=a,b,c,d<n和互不相同nums[a]+nums[b]+nums[c]+nums[d]==target1<=nums.length<=200-10<=nums[i]<=10-10<=target<=10",1,3
18,44,3,42,题库,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表，删除链表的倒数第个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？,链表中结点的数目为1<=sz<=300<=Node.val<=1001<=n<=sz,1,2
19,36,3,29,题库,1,0,1,0,0,0,0,1,0,0,1,0,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个只包括，，，，，的字符串，判断字符串是否有效。有效字符串需满足：,1<=s.length<=10仅由括号'()[]{}'组成,1,2
20,44,3,47,题库,0,1,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,将两个升序链表合并为一个新的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。,"两个链表的节点数目范围是[0,50]-100<=Node.val<=100和均按非递减顺序排列",1,2
21,39,2,7,题库,1,2,0,0,0,0,0,0,0,1,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,数字代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且括号组合。,1<=n<=8,1,3
22,49,3,108,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。,k==lists.length0<=k<=10^40<=lists[i].length<=500-10^4<=lists[i][j]<=10^4lists[i]按排列lists[i].length的总和不超过10^4,1,4
23,66,3,34,题库,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。,"链表中节点的数目在范围[0,100]0<=Node.val<=100",1,2
24,138,2,39,题库,0,1,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你链表的头节点，每个节点一组进行翻转，请你返回修改后的链表。是一个正整数，它的值小于或等于链表的长度。如果节点总数不是的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。你可以设计一个只用额外内存空间的算法解决此问题吗？,链表中的节点数目为1<=k<=n<=50000<=Node.val<=1000,1,2
25,127,2,114,题库,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的数组，请你删除重复出现的元素，使每个元素，返回删除后数组的新长度。元素的应该保持。然后返回中唯一元素的个数。考虑的唯一元素的数量为，你需要做以下事情确保你的题解可以被通过：系统会用下面的代码来测试你的题解:如果所有断言都通过，那么您的题解将被。,更改数组nums，使nums的前个元素包含唯一元素，并按照它们最初在nums中出现的顺序排列。nums的其余元素与nums的大小不重要。返回1<=nums.length<=3*10-10<=nums[i]<=10nums已按排列,1,2
26,167,2,44,题库,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组和一个值，你需要移除所有数值等于的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用额外空间并。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:,0<=nums.length<=1000<=nums[i]<=500<=val<=100,1,2
27,53,2,61,题库,2,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串和，请你在字符串中找出字符串的第一个匹配项的下标（下标从0开始）。如果不是的一部分，则返回。,"1<=haystack.length,needle.length<=10haystack和needle仅由小写英文字符组成",1,3
28,129,2,33,题库,0,0,0,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数，被除数和除数。将两数相除，要求乘法、除法和取余运算。整数除法应该向零截断，也就是截去（）其小数部分。例如，将被截断为，将被截断至。返回被除数除以除数得到的。假设我们的环境只能存储有符号整数，其数值范围是。本题中，如果商，则返回；如果商，则返回。,"<=dividend,divisor<=2-1divisor!=0",1,2
29,76,3,196,题库,1,0,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串和一个字符串数组中所有字符串。中的是指一个包含中所有字符串以任意顺序排列连接起来的子串。返回所有串联子串在中的开始索引。你可以以返回答案。,"例如，如果words=[""ab"",""cd"",""ef""]，那么""abcdef""""abefcd""""cdabef""""cdefab""""efabcd""，和""efcdab""都是串联子串。""acdbef""不是串联子串，因为他不是任何words排列的连接。1<=s.length<=101<=words.length<=50001<=words[i].length<=30words[i]和由小写英文字母组成",1,3
30,190,3,199,题库,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,整数数组的一个就是将其所有成员以序列或线性顺序排列。整数数组的是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。给你一个整数数组，找出的下一个排列。必须修改，只允许使用额外常数空间。,"例如，arr=[1,2,3]，以下这些都可以视作arr的排列：[1,2,3][1,3,2][3,1,2][2,3,1]例如，arr=[1,2,3]的下一个排列是[1,3,2]类似地，arr=[2,3,1]的下一个排列是[3,1,2]arr=[3,2,1]的下一个排列是[1,2,3]，因为[3,2,1]不存在一个字典序更大的排列。1<=nums.length<=1000<=nums[i]<=100",1,2
31,36,3,29,题库,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个只包含和的字符串，找出最长有效（格式正确且连续）括号子串的长度。,0<=s.length<=3*10s[i]为'('或')',1,3
32,127,3,91,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,整数数组按升序排列，数组中的值。在传递给函数之前，在预先未知的某个下标（）上进行了，使数组变为（下标计数）。例如，在下标处经旋转后可能变为。给你的数组和一个整数，如果中存在这个目标值，则返回它的下标，否则返回。你必须设计一个时间复杂度为的算法解决此问题。,1<=nums.length<=5000-10<=nums[i]<=10nums中的每个值都独一无二题目数据保证nums在预先未知的某个下标上进行了旋转-10<=target<=10,1,2
33,88,3,61,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个按照非递减顺序排列的整数数组，和一个目标值。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值，返回。你必须设计并实现时间复杂度为的算法解决此问题。,0<=nums.length<=10-10<=nums[i]<=10nums是一个非递减数组-10<=target<=10,1,2
34,75,3,65,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为的算法。,1<=nums.length<=10-10<=nums[i]<=10nums为无重复元素升序排列数组-10<=target<=10,1,2
35,34,2,118,题库,2,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你判断一个的数独是否有效。只需要，验证已经填入的数字是否有效即可。,一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。空白格用'.'表示。board.length==9board[i].length==9board[i][j]是一位数字（1-9）或者'.',1,3
36,49,1,67,题库,2,1,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,编写一个程序，通过填充空格来解决数独问题。数独的解法需：数独部分空格内已填入了数字，空白格用表示。,board.length==9board[i].length==9board[i][j]是一位数字或者'.'题目数据输入数独仅有一个解,1,4
37,211,2,76,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个正整数，输出外观数列的第项。「外观数列」是一个整数序列，从数字1开始，序列中的每一项都是对前一项的描述。你可以将其视作是由递归公式定义的数字字符串序列：前五项如下：要一个数字字符串，首先要将字符串分割为数量的组，每个组都由连续的最多组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。例如，数字字符串的描述如下图：,"countAndSay(1)=""1""countAndSay(n)是对countAndSay(n-1)的描述，然后转换成另一个数字字符串。1<=n<=30",1,1
38,109,3,76,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的整数数组和一个目标整数，找出中可以使数字和为目标数的所有，并以列表形式返回。你可以按返回这些组合。中的数字可以。如果至少一个数字的被选数量不同，则两种组合是不同的。对于给定的输入，保证和为的不同组合数少于个。,1<=candidates.length<=302<=candidates[i]<=40candidates的所有元素互不相同1<=target<=40,1,2
39,64,2,58,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个候选人编号的集合和一个目标数，找出中所有可以使数字和为的组合。中的每个数字在每个组合中只能使用。解集不能包含重复的组合。,1<=candidates.length<=1001<=candidates[i]<=501<=target<=30,1,2
40,31,3,34,题库,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。,1<=nums.length<=5*10<=nums[i]<=2-1,1,2
41,43,2,42,题库,1,1,2,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定个非负整数表示每个宽度为的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。,n==height.length1<=n<=2*100<=height[i]<=10,1,5
42,73,2,75,题库,2,0,0,0,0,1,0,1,0,0,1,1,0,0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个以字符串形式表示的非负整数和，返回和的乘积，它们的乘积也表示为字符串形式。不能使用任何内置的BigInteger库或直接将输入转换为整数。,"1<=num1.length,num2.length<=200num1和num2只能由数字组成。num1和num2都不包含任何前导零，除了数字0本身。",1,3
43,36,3,91,题库,1,3,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,判定匹配成功的充要条件是：字符模式必须能够输入字符串（而不是部分匹配）。,"'?'可以匹配任何单个字符。'*'可以匹配任意字符序列（包括空字符序列）。0<=s.length,p.length<=2000仅由小写英文字母组成仅由小写英文字母、'?'或'*'组成",1,4
44,83,2,69,题库,1,2,0,0,0,0,0,0,1,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个长度为的整数数组。初始位置为。每个元素表示从索引向前跳转的最大长度。换句话说，如果你在处，你可以跳转到任意处:返回到达的最小跳跃次数。生成的测试用例可以到达。,0<=j<=nums[i]i+j<n1<=nums.length<=100<=nums[i]<=1000题目保证可以到达nums[n-1],1,3
45,26,3,47,题库,1,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个不含重复数字的数组，返回其。你可以返回答案。,1<=nums.length<=6-10<=nums[i]<=10nums中的所有整数互不相同,1,2
46,27,2,33,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个可包含重复数字的序列，返回所有不重复的全排列。,1<=nums.length<=8-10<=nums[i]<=10,1,2
47,72,2,67,题库,2,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个×的二维矩阵表示一个图像。请你将图像顺时针旋转90度。你必须在旋转图像，这意味着你需要直接修改输入的二维矩阵。使用另一个矩阵来旋转图像。,n==matrix.length==matrix[i].length1<=n<=20-1000<=matrix[i][j]<=1000,1,3
48,56,3,54,题库,3,0,1,0,0,0,0,1,0,0,1,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串数组，请你将组合在一起。可以按任意顺序返回结果列表。是由重新排列源单词的所有字母得到的一个新单词。,1<=strs.length<=100<=strs[i].length<=100strs[i]仅包含小写字母,1,4
49,18,3,46,题库,0,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,实现，即计算的整数次幂函数（即，）。,-100.0<x<100.0<=n<=2是一个整数要么不为零，要么n>0-10<=x<=10,1,2
50,127,2,7,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。研究的是如何将个皇后放置在的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数，返回所有不同的的解决方案。每一种解法包含一个不同的的棋子放置方案，该方案中和分别代表了皇后和空位。,1<=n<=9,1,2
51,54,2,7,题库,0,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,研究的是如何将个皇后放置在的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数，返回不同的解决方案的数量。,1<=n<=9,1,1
52,86,3,34,题库,1,2,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。是数组中的一个连续部分。如果你已经实现复杂度为的解法，尝试使用更为精妙的求解。,1<=nums.length<=10-10<=nums[i]<=10,1,3
53,25,2,68,题库,3,0,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个行列的矩阵，请按照，返回矩阵中的所有元素。,"m==matrix.lengthn==matrix[i].length1<=m,n<=10-100<=matrix[i][j]<=100",1,3
54,61,2,34,题库,1,2,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个非负整数数组，你最初位于数组的。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。,1<=nums.length<=3*100<=nums[i]<=10,1,3
55,38,2,62,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,以数组表示若干个区间的集合，其中单个区间为。请你合并所有重叠的区间，并返回。,1<=intervals.length<=10intervals[i].length==20<=start<=end<=10,1,2
56,69,5,171,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。,0<=intervals.length<=10intervals[i].length==20<=intervals[i][0]<=intervals[i][1]<=10intervals根据intervals[i][0]按排列newInterval.length==20<=newInterval[0]<=newInterval[1]<=10,1,1
57,68,3,37,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中单词的长度。是指仅由字母组成、不包含任何空格字符的最大子字符串。,1<=s.length<=10仅有英文字母和空格''组成中至少存在一个单词,1,1
58,40,2,8,题库,3,0,0,0,0,0,0,0,0,1,1,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数，生成一个包含到所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。,1<=n<=20,1,3
59,57,3,15,题库,0,1,0,0,0,1,0,0,0,1,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给出集合，其所有元素共有种排列。按大小顺序列出所有排列情况，并一一标记，当时,所有排列如下：给定和，返回第个排列。",1<=n<=91<=k<=n!,1,2
60,31,2,47,题库,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表的头节点，旋转链表，将链表每个节点向右移动个位置。,"链表中节点的数目在范围[0,500]-100<=Node.val<=1000<=k<=2*10",1,2
61,97,4,27,题库,0,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个机器人位于一个网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？,"1<=m,n<=100题目数据保证答案小于等于2*10",1,3
62,137,2,78,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个机器人位于一个网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用和来表示。,"m==obstacleGrid.lengthn==obstacleGrid[i].length1<=m,n<=100obstacleGrid[i][j]为或",1,3
63,60,2,60,题库,2,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个包含非负整数的网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。,"m==grid.lengthn==grid[i].length1<=m,n<=2000<=grid[i][j]<=200",1,3
64,88,3,55,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,（按顺序）可以分成以下几个部分：（按顺序）可以分成以下几个部分：（按顺序）可以分成以下几个部分：部分有效数字列举如下：部分无效数字列举如下：给你一个字符串，如果是一个，请返回。,1<=s.length<=20仅含英文字母（大写和小写），数字（0-9），加号'+'，减号'-'，或者点'.',1,1
65,80,3,36,题库,1,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个由组成的数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位，数组中每个元素只存储数字。你可以假设除了整数0之外，这个整数不会以零开头。,1<=digits.length<=1000<=digits[i]<=9,1,2
66,29,2,55,题库,2,0,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个二进制字符串和，以二进制字符串的形式返回它们的和。,"1<=a.length,b.length<=10和仅由字符'0'或'1'组成字符串如果不是""0""，就不含前导零",1,4
67,180,3,164,题库,3,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个单词数组和一个长度，重新排版单词，使其成为每行恰好有个字符，且左右两端对齐的文本。你应该使用“”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格填充，使得每行恰好有个字符。要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。文本的最后一行应为左对齐，且单词之间不插入空格。,单词是指由非空格字符组成的字符序列。每个单词的长度大于0，小于等于maxWidth输入单词数组words至少包含一个单词。1<=words.length<=3001<=words[i].length<=20words[i]由小写英文字母和符号组成1<=maxWidth<=100words[i].length<=maxWidth,1,3
68,60,2,9,题库,0,1,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个非负整数，计算并返回的。由于返回类型是整数，结果只保留，小数部分将被不允许使用任何内置指数函数和算符，例如或者。,0<=x<=2-1,1,2
69,49,2,8,题库,0,2,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,假设你正在爬楼梯。需要阶你才能到达楼顶。每次你可以爬或个台阶。你有多少种不同的方法可以爬到楼顶呢？,1<=n<=45,1,3
70,200,4,157,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，表示指向某一文件或目录的Unix风格（以开头），请你将其转化为更加简洁的规范路径。在Unix风格的文件系统中，一个点（）表示当前目录本身；此外，两个点（）表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，）都被视为单个斜杠。对于此问题，任何其他格式的点（例如，）均被视为文件/目录名称。请注意，返回的必须遵循下述格式：返回简化后得到的。,始终以斜杠'/'开头。两个目录名之间必须只有一个斜杠'/'最后一个目录名（如果存在）不能'/'结尾。此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含'.'或'..'1<=path.length<=3000path由英文字母，数字，'.''/'或'_'组成。path是一个有效的Unix风格绝对路径。,1,2
71,26,2,71,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个单词和，。你可以对一个单词进行如下三种操作：,"插入一个字符删除一个字符替换一个字符0<=word1.length,word2.length<=500word1和word2由小写英文字母组成",1,2
72,38,2,150,题库,2,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个的矩阵，如果一个元素为，则将其所在行和列的所有元素都设为。请使用算法,"m==matrix.lengthn==matrix[0].length1<=m,n<=200<=matrix[i][j]<=2-1一个直观的解决方案是使用的额外空间，但这并不是一个好的解决方案。一个简单的改进方案是使用+的额外空间，但这仍然不是最好的解决方案。你能想出一个仅使用常量空间的解决方案吗？",1,3
73,41,2,114,题库,2,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个满足下述两条属性的整数矩阵：给你一个整数，如果在矩阵中，返回；否则，返回。,"每行中的整数从左到右按非递减顺序排列。每行的第一个整数大于前一行的最后一个整数。m==matrix.lengthn==matrix[i].length1<=m,n<=100-10<=matrix[i][j],target<=10",1,3
74,107,2,54,题库,2,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个包含红色、白色和蓝色、共个元素的数组，对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数、和分别表示红色、白色和蓝色。必须在不使用库内置的sort函数的情况下解决这个问题。,n==nums.length1<=n<=300nums[i]为或你能想出一个仅使用常数空间的一趟扫描算法吗？,1,3
75,53,3,98,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串、一个字符串。返回中涵盖所有字符的最小子串。如果中不存在涵盖所有字符的子串，则返回空字符串。,"对于中重复字符，我们寻找的子字符串中该字符数量必须不少于中该字符数量。如果中存在这样的子串，我们保证它是唯一的答案。m==s.lengthn==t.length1<=m,n<=10和由英文字母组成",1,3
76,33,2,15,题库,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数和，返回范围中所有可能的个数的组合。你可以按返回答案。,1<=n<=201<=k<=n,1,1
77,52,2,48,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，数组中的元素。返回该数组所有可能的子集（幂集）。解集包含重复的子集。你可以按返回解集。,1<=nums.length<=10-10<=nums[i]<=10nums中的所有元素互不相同,1,3
78,146,3,80,题库,2,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二维字符网格和一个字符串单词。如果存在于网格中，返回；否则，返回。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。你可以使用搜索剪枝的技术来优化解决方案，使其在更大的情况下可以更快解决问题？,"m==board.lengthn=board[i].length1<=m,n<=61<=word.length<=15board和word仅由大小写英文字母组成",1,3
79,156,2,46,题库,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个有序数组，请你删除重复出现的元素，使得出现次数超过两次的元素，返回删除后数组的新长度。不要使用额外的数组空间，你必须在并在使用O(1)额外空间的条件下完成。为什么返回数值是整数，但输出的答案是数组呢？请注意，输入数组是以方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:,1<=nums.length<=3*10-10<=nums[i]<=10nums已按升序排列,1,2
80,156,2,137,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,已知存在一个按非降序排列的整数数组，数组中的值不必互不相同。在传递给函数之前，在预先未知的某个下标（）上进行了，使数组变为（下标计数）。例如，在下标处经旋转后可能变为。给你的数组和一个整数，请你编写一个函数来判断给定的目标值是否存在于数组中。如果中存在这个目标值，则返回，否则返回。你必须尽可能减少整个操作步骤。,1<=nums.length<=5000-10<=nums[i]<=10题目数据保证nums在预先未知的某个下标上进行了旋转-10<=target<=10这是搜索旋转排序数组的延伸题目，本题中的nums可能包含重复元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？,1,2
81,17,2,49,题库,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个已排序的链表的头，。返回。,"链表中节点数目在范围[0,300]-100<=Node.val<=100题目数据保证链表已经按升序",1,2
82,17,2,49,题库,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个已排序的链表的头，。返回。,"链表中节点数目在范围[0,300]-100<=Node.val<=100题目数据保证链表已经按升序",1,1
83,62,2,38,题库,1,0,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为1。求在该柱状图中，能够勾勒出来的矩形的最大面积。,1<=heights.length<=100<=heights[i]<=10,1,3
84,39,5,77,题库,2,1,2,0,0,0,0,0,0,1,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个仅包含和、大小为的二维二进制矩阵，找出只包含的最大矩形，并返回其面积。,"rows==matrix.lengthcols==matrix[0].length1<=row,cols<=200matrix[i][j]为'0'或'1'",1,5
85,64,2,49,题库,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表的头节点和一个特定值，请你对链表进行分隔，使得所有的节点都出现在的节点之前。你应当两个分区中每个节点的初始相对位置。,"链表中节点的数目在范围[0,200]-100<=Node.val<=100-200<=x<=200",1,2
86,59,3,190,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"使用下面描述的算法可以扰乱字符串得到字符串：
给你两个的字符串和，判断是否是的扰乱字符串。如果是，返回；否则，返回。",在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串，则可以将其分成两个子字符串和，且满足s=x+y决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，可能是s=x+y或者s=y+x和这两个子字符串上继续从步骤1开始递归执行此算法。s1.length==s2.length1<=s1.length<=30和由小写英文字母组成,1,2
87,148,3,80,题库,2,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个按排列的整数数组和，另有两个整数和，分别表示和中的元素数目。请你到中，使合并后的数组同样按排列。最终，合并后数组不应由函数返回，而是存储在数组中。为了应对这种情况，的初始长度为，其中前个元素表示应合并的元素，后个元素为，应忽略。的长度为。你可以设计实现一个时间复杂度为的算法解决此问题吗？,"nums1.length==m+nnums2.length==n0<=m,n<=2001<=m+n<=200-10<=nums1[i],nums2[j]<=10",1,3
88,15,2,90,题库,0,1,0,0,1,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，返回任一有效的。,"每个整数都在范围[0,2-1]内（含和-1第一个整数是一个整数在序列中出现不超过一次每对整数的二进制表示恰好一位不同，且第一个和最后一个整数的二进制表示恰好一位不同1<=n<=16",1,3
89,64,2,34,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集包含重复的子集。返回的解集中，子集可以按排列。,1<=nums.length<=10-10<=nums[i]<=10,1,3
90,142,3,71,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一条包含字母的消息通过以下映射进行了：要已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，可以映射为：注意，消息不能分组为，因为不能映射为，这是由于和在映射中并不等价。给你一个只含数字的字符串，请计算并返回方法的。题目数据保证答案肯定是一个的整数。,"""AAJF""，将消息分组为(11106)""KJF""，将消息分组为(11106)1<=s.length<=100只包含数字，并且可能包含前导零。",1,2
91,55,2,53,题库,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你单链表的头指针和两个整数和，其中。请你反转从位置到位置的链表节点，返回。
你可以使用一趟扫描完成反转吗？",链表中节点数目为1<=n<=500-500<=Node.val<=5001<=left<=right<=n,1,1
92,112,3,106,题库,1,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,正好由四个整数（每个整数位于到之间组成，且不能含有前导），整数之间用分隔。给定一个只包含数字的字符串，用以表示一个IP地址，返回所有可能的，这些地址可以通过在中插入来形成。你重新排序或删除中的任何数字。你可以按顺序返回答案。,"例如：""0.1.2.201""""192.168.1.1""是IP地址，但是""0.011.255.245""""192.168.1.312""和""192.168@1.1""是IP地址。1<=s.length<=20仅由数字组成",1,2
93,36,3,35,题库,0,1,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个二叉树的根节点，返回。递归算法很简单，你可以通过迭代算法完成吗？,"树中节点数目在范围[0,100]-100<=Node.val<=100",1,4
94,44,2,7,题库,0,2,3,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你生成并返回所有由个节点组成且节点值从到互不相同的不同。可以按返回答案。,1<=n<=8,1,5
95,47,2,8,题库,0,1,3,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，求恰由个节点组成且节点值从到互不相同的有多少种？返回满足题意的二叉搜索树的种数。,1<=n<=19,1,5
96,88,3,117,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定三个字符串、、，请你帮忙验证是否是由和组成的。两个字符串和的定义与过程如下，其中每个字符串都会被分割成若干子字符串：意味着字符串和连接。您能否仅使用额外的内存空间来解决它?,"s=s+s+...+st=t+t+...+t|n-m|<=1是+t+s+t+s+t+...或者+s+t+s+t+s+...0<=s1.length,s2.length<=1000<=s3.length<=200、和都由小写英文字母组成",1,2
97,39,2,84,题库,0,1,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二叉树的根节点，判断其是否是一个有效的二叉搜索树。二叉搜索树定义如下：,"节点的左子树只包含小于当前节点的数。节点的右子树只包含当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。树中节点数目范围在[1,10<=Node.val<=2-1",1,4
98,64,2,33,题库,0,1,3,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉搜索树的根节点，该树中的两个节点的值被错误地交换。。使用空间复杂度的解法很容易实现。你能想出一个只使用空间的解决方案吗？,"树上节点的数目在范围[2,1000]<=Node.val<=2-1",1,4
99,64,3,37,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两棵二叉树的根节点和，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。,"两棵树上的节点数目都在范围[0,100]-10<=Node.val<=10",1,4
100,43,2,36,题库,0,2,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二叉树的根节点，检查它是否轴对称。你可以运用递归和迭代两种方法解决这个问题吗？,"树中节点数目在范围[1,1000]-100<=Node.val<=100",1,4
101,36,3,38,题库,0,1,2,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根节点，返回其节点值的。（即逐层地，从左到右访问所有节点）。,"树中节点数目在范围[0,2000]-1000<=Node.val<=1000",1,3
102,55,3,36,题库,0,1,2,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根节点，返回其节点值的。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。,"树中节点数目在范围[0,2000]-100<=Node.val<=100",1,3
103,44,2,36,题库,0,2,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个二叉树，返回其最大深度。二叉树的是指从根节点到最远叶子节点的最长路径上的节点数。,"树中节点的数量在[0,10区间内。-100<=Node.val<=100",1,4
104,39,2,168,题库,1,1,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数数组和，其中是二叉树的，是同一棵树的，请构造二叉树并返回其根节点。,"1<=preorder.length<=3000inorder.length==preorder.length-3000<=preorder[i],inorder[i]<=3000preorder和inorder均无重复元素inorder均出现在preorderpreorder为二叉树的前序遍历序列inorder为二叉树的中序遍历序列",1,5
105,43,2,167,题库,1,1,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数数组和，其中是二叉树的中序遍历，是同一棵树的后序遍历，请你构造并返回这颗。,"1<=inorder.length<=3000postorder.length==inorder.length-3000<=inorder[i],postorder[i]<=3000inorder和postorder都由的值组成postorder中每一个值都在inorderinorder是树的中序遍历postorder是树的后序遍历",1,5
106,46,3,38,题库,0,1,2,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根节点，返回其节点值。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）,"树中节点数目在范围[0,2000]-1000<=Node.val<=1000",1,3
107,72,2,47,题库,1,1,3,0,0,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，其中元素已经按排列，请你将其转换为一棵二叉搜索树。二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过1」的二叉树。,1<=nums.length<=10-10<=nums[i]<=10nums按严格递增顺序排列,1,5
108,70,2,37,题库,0,1,4,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个单链表的头节点，其中的元素，将其转换为高度平衡的二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树的左右两个子树的高度差不超过1。,"head中的节点数在[0,2*10范围内-10<=Node.val<=10",1,5
109,65,3,34,题库,0,1,2,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树的左右两个子树的高度差的绝对值不超过1。,"树中的节点数在范围[0,5000]-10<=Node.val<=10",1,3
110,59,2,35,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。叶子节点是指没有子节点的节点。,"树中节点数的范围在[0,10-1000<=Node.val<=1000",1,4
111,77,3,61,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你二叉树的根节点和一个表示目标和的整数。判断该树中是否存在的路径，这条路径上所有节点值相加等于目标和。如果存在，返回；否则，返回。是指没有子节点的节点。,"树中节点的数目在范围[0,5000]-1000<=Node.val<=1000-1000<=targetSum<=1000",1,4
112,48,3,60,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根节点和一个整数目标和，找出所有路径总和等于给定目标和的路径。是指没有子节点的节点。,"树中节点总数在范围[0,5000]-1000<=Node.val<=1000-1000<=targetSum<=1000",1,4
113,45,3,112,题库,0,1,4,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根结点，请你将它展开为一个单链表：你可以使用原地算法（额外空间）展开这棵树吗？,"展开后的单链表应该同样使用TreeNode，其中right子指针指向链表中下一个结点，而左子指针始终为null展开后的单链表应该与二叉树先序遍历顺序相同。树中结点数在范围[0,2000]-100<=Node.val<=100",1,5
114,44,2,34,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个字符串和，统计并返回在的中出现的个数。题目数据保证答案符合32位带符号整数范围。,"1<=s.length,t.length<=1000和由英文字母组成",1,2
115,113,2,89,题库,0,2,3,0,0,0,0,1,0,0,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：填充它的每个next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置为。初始状态下，所有next指针都被设置为。,"树中节点的数量在[0,2-1]范围内-1000<=node.val<=1000你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。",1,5
116,82,2,85,题库,0,2,3,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树：填充它的每个next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置为。初始状态下，所有next指针都被设置为。,"树中的节点数在范围[0,6000]-100<=Node.val<=100你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。",1,5
117,20,2,14,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非负整数生成「杨辉三角」的前行。,1<=numRows<=30,1,2
118,38,3,15,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非负索引，返回「杨辉三角」的第行。你可以优化你的算法到空间复杂度吗？,0<=rowIndex<=33,1,2
119,94,2,143,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。在这里指的是与相同或者等于的两个结点。也就是说，如果正位于当前行的下标，那么下一步可以移动到下一行的下标或。,1<=triangle.length<=200triangle[0].length==1triangle[i].length==triangle[i-1].length+1-10<=triangle[i][j]<=10你可以只使用O(n)的额外空间（为三角形的总行数）来解决这个问题吗？,1,2
120,103,2,36,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个数组，它的第个元素表示一支给定股票第天的价格。你只能选择买入这只股票，并选择在卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回。,1<=prices.length<=100<=prices[i]<=10,1,2
121,75,3,38,题库,1,2,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中表示某支股票第天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候只能持有股票。你也可以先购买，然后在出售。返回。,1<=prices.length<=3*100<=prices[i]<=10,1,3
122,89,4,36,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个数组，它的第个元素是一支给定的股票在第天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成交易。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。,1<=prices.length<=100<=prices[i]<=10,1,2
123,92,2,37,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,二叉树中的被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中。该路径节点，且不一定经过根节点。是路径中各节点值的总和。给你一个二叉树的根节点，返回其。,"树中节点数目范围是[1,3*10-1000<=Node.val<=1000",1,4
124,95,3,32,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个。字母和数字都属于字母数字字符。给你一个字符串，如果它是，返回；否则，返回。,1<=s.length<=2*10仅由可打印的ASCII字符组成,1,2
125,106,2,279,题库,1,2,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,按字典完成从单词到单词转化，一个表示此过程的是形式上像这样的单词序列，并满足：给你两个单词和，以及一个字典。请你找出并返回所有从到的，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表的形式返回。,每对相邻的单词之间仅有单个字母不同。转换过程中的每个单词1<=i<=k）必须是字典wordList中的单词。注意，beginWord不必是字典wordList中的单词。==endWord1<=beginWord.length<=5endWord.length==beginWord.length1<=wordList.length<=500wordList[i].length==beginWord.lengthbeginWordendWord和wordList[i]由小写英文字母组成beginWord!=endWordwordList中的所有单词互不相同,1,4
126,54,2,264,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,字典中从单词和的是一个按下述规格形成的序列：给你两个单词和和一个字典，返回。如果不存在这样的转换序列，返回。,每一对相邻的单词只差一个字母。对于1<=i<=k时，每个都在wordList中。注意，beginWord不需要在wordList中。==endWord1<=beginWord.length<=10endWord.length==beginWord.length1<=wordList.length<=5000wordList[i].length==beginWord.lengthbeginWordendWord和wordList[i]由小写英文字母组成beginWord!=endWordwordList中的所有字符串互不相同,1,3
127,66,2,34,题库,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个未排序的整数数组，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为的算法解决此问题。,0<=nums.length<=10-10<=nums[i]<=10,1,3
128,79,2,67,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个二叉树的根节点，树中每个节点都存放有一个到之间的数字。
每条从根节点到叶节点的路径都代表一个数字：计算从根节点到叶节点生成的。是指没有子节点的节点。","例如，从根节点到叶节点的路径1->2->3表示数字123树中节点的数目在范围[1,1000]0<=Node.val<=9树的深度不超过",1,3
129,42,2,63,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个的矩阵，由若干字符和，找到所有被围绕的区域，并将这些区域里所有的用填充。
","m==board.lengthn==board[i].length1<=m,n<=200board[i][j]为'X'或'O'",1,5
130,55,2,25,题库,1,2,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你将分割成一些子串，使每个子串都是。返回所有可能的分割方案。是正着读和反着读都一样的字符串。,1<=s.length<=16仅由小写英文字母组成,1,3
131,37,3,27,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，请你将分割成一些子串，使每个子串都是回文。返回符合要求的。,1<=s.length<=2000仅由小写英文字母组成,1,2
132,190,4,0,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你无向图中一个节点的引用，请你返回该图的（克隆）。图中的每个节点都包含它的值（）和其邻居的列表（）。简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为1（），第二个节点值为2（），以此类推。该图在测试用例中使用邻接列表表示。是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。给定节点将始终是图中的第一个节点（值为1）。你必须将作为对克隆图的引用返回。,,1,4
133,136,2,56,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一条环路上有个加油站，其中第个加油站有汽油升。你有一辆油箱容量无限的的汽车，从第个加油站开往第个加油站需要消耗汽油升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组和，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回。如果存在解，则它是的。,"gas.length==ncost.length==n1<=n<=100<=gas[i],cost[i]<=10",1,2
134,69,2,81,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,个孩子站成一排。给你一个整数数组表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：请你给每个孩子分发糖果，计算并返回需要准备的。,每个孩子至少分配到个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。n==ratings.length1<=n<=2*100<=ratings[i]<=2*10,1,2
135,88,3,66,题库,1,0,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。,1<=nums.length<=3*10-3*10<=nums[i]<=3*10除了某个元素只出现一次以外，其余每个元素均出现两次。,1,2
136,81,2,60,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，除某个元素仅出现外，其余每个元素都恰出现请你找出并返回那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。,1<=nums.length<=3*10<=nums[i]<=2-1nums中，除某个元素仅出现外，其余每个元素都恰出现,1,2
137,252,3,123,题库,0,0,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。构造这个链表的。深拷贝应该正好由个节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的指针和指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。。例如，如果原链表中有和两个节点，其中。那么在复制链表中对应的两个节点和，同样有。返回复制链表的头节点。用一个由个节点组成的链表来表示输入/输出中的链表。每个节点用一个表示：你的代码接受原链表的头节点作为传入参数。,val：一个表示Node.val的整数。random_index：随机指针指向的节点索引（范围从到n-1）；如果不指向任何节点，则为null0<=n<=1000-10<=Node.val<=10Node.random为null或指向链表中的节点。,1,2
138,74,3,106,题库,2,2,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串和一个字符串列表作为字典。请你判断是否可以利用字典中出现的单词拼接出。不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。,1<=s.length<=3001<=wordDict.length<=10001<=wordDict[i].length<=20和wordDict[i]仅有小写英文字母组成wordDict中的所有字符串互不相同,1,6
139,84,3,101,题库,2,3,1,1,0,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串和一个字符串字典，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。词典中的同一个单词可能在分段中被重复使用多次。,1<=s.length<=201<=wordDict.length<=10001<=wordDict[i].length<=10和wordDict[i]仅有小写英文字母组成wordDict中所有字符串都,1,7
140,146,3,49,题库,0,0,2,0,1,0,0,0,0,1,1,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个链表的头节点，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数来表示链表尾连接到链表中的位置（索引从0开始）。。仅仅是为了标识链表的实际情况。，则返回。否则，返回。你能用（即，常量）内存解决此问题吗？,"链表中节点的数目范围是[0,10-10<=Node.val<=10pos为或者链表中的一个有效索引",1,3
141,147,3,53,题库,0,0,2,0,1,0,0,0,0,1,1,0,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个链表的头节点，返回链表开始入环的第一个节点。如果链表中有某个节点，可以通过连续跟踪指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数来表示链表尾连接到链表中的位置（）。如果是，则在该链表中没有环。，仅仅是为了标识链表的实际情况。链表。你是否可以使用空间解决此题？,"链表中节点的数目范围在范围[0,10-10<=Node.val<=10pos的值为或者链表中的一个有效索引",1,3
142,60,2,32,题库,0,1,2,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个单链表的头节点，单链表表示为：请将其重新排列后变为：不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。,"链表的长度范围为[1,5*101<=node.val<=1000",1,4
143,41,5,35,题库,0,1,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你二叉树的根节点，返回它节点值的遍历。递归算法很简单，你可以通过迭代算法完成吗？,"树中节点数目在范围[0,100]-100<=Node.val<=100",1,4
144,41,3,36,题库,0,1,3,0,0,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一棵二叉树的根节点，返回其节点值的。递归算法很简单，你可以通过迭代算法完成吗？,"树中节点的数目在范围[0,100]-100<=Node.val<=100",1,4
145,17,1,257,题库,0,0,3,0,0,0,1,0,0,1,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,函数和必须以的平均时间复杂度运行。,"LRUCache(intcapacity)以正整数作为容量capacity初始化LRU缓存intget(intkey)如果关键字key存在于缓存中，则返回关键字的值，否则返回voidput(intkey,intvalue)如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该最久未使用的关键字。1<=capacity<=30000<=key<=100000<=value<=10最多调用2*10次get和put",1,4
146,118,2,40,题库,1,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定单个链表的头，使用对链表进行排序，并返回。算法的步骤:下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。对链表进行插入排序。,"列表中的节点数在[1,5000]范围内-5000<=Node.val<=5000",1,2
147,48,3,35,题库,1,2,1,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你链表的头结点，请将其按排列并返回。你可以在时间复杂度和常数级空间复杂度下，对链表进行排序吗？,"链表中节点的数目在范围[0,5*10-10<=Node.val<=10",1,5
148,35,2,67,题库,1,0,1,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组，其中表示平面上的一个点。求最多有多少个点在同一条直线上。,"1<=points.length<=300points[i].length==2-10<=x,y<=10points中的所有点互不相同",1,4
149,93,3,326,题库,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串数组，表示一个根据表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。逆波兰表达式主要有以下两个优点：,"有效的算符为'+''-''*'和'/'每个操作数（运算对象）都可以是一个整数或者另一个表达式。两个整数之间的除法总是向零截断表达式中不含除零运算。输入是一个根据逆波兰表示法表示的算术表达式。答案及所有中间计算结果可以用32位整数表示。1<=tokens.length<=10tokens[i]是一个算符（""+""""-""""*""或""/""），或是在范围[-200,200]内的一个整数平常使用的算式则是一种中缀表达式，如(1+2)*(3+4)该算式的逆波兰表达式写法为((12+)(34+)*)去掉括号后表达式无歧义，上式即便写成12+34+*也可以依据次序计算出正确结果。适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中",1,3
150,184,3,41,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你反转字符串中的顺序。是由非空格字符组成的字符串。中使用至少一个空格将字符串中的分隔开。返回顺序颠倒且之间用单个空格连接的结果字符串。输入字符串中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用额外空间复杂度的解法。,1<=s.length<=10包含英文大小写字母、数字和空格''中至少存在一个单词,1,2
151,81,2,61,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。测试用例的答案是一个整数。是数组的连续子序列。,1<=nums.length<=2*10-10<=nums[i]<=10nums的任何前缀或后缀的乘积都是一个32-位整数,1,2
152,135,3,133,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"已知一个长度为的数组，预先按照升序排列，经由到次后，得到输入数组。例如，原数组在变化后可能得到：
注意，数组的结果为数组。给你一个元素值的数组，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的。你必须设计一个时间复杂度为的算法解决此问题。","若旋转次，则可以得到[4,5,6,7,0,1,2]若旋转次，则可以得到[0,1,2,4,5,6,7]n==nums.length1<=n<=5000-5000<=nums[i]<=5000nums中的所有整数互不相同nums原来是一个升序排序的数组，并进行了至次旋转",1,2
153,179,2,119,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"已知一个长度为的数组，预先按照升序排列，经由到次后，得到输入数组。例如，原数组在变化后可能得到：
注意，数组的结果为数组。给你一个可能存在元素值的数组，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的。你必须尽可能减少整个过程的操作步骤。这道题与类似，但可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？","若旋转次，则可以得到[4,5,6,7,0,1,4]若旋转次，则可以得到[0,1,4,4,5,6,7]n==nums.length1<=n<=5000-5000<=nums[i]<=5000nums原来是一个升序排序的数组，并进行了至次旋转",1,2
154,33,1,167,题库,0,0,1,0,0,0,1,1,0,0,1,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个支持，，操作，并能在常数时间内检索到最小元素的栈。实现类:,"MinStack()初始化堆栈对象。voidpush(intval)将元素val推入堆栈。voidpop()删除堆栈顶部的元素。inttop()获取堆栈顶部的元素。intgetMin()获取堆栈中的最小元素。<=val<=2-1poptop和getMin操作总是在非空栈上调用pushpoptop,andgetMin最多被调用3*10",1,2
155,195,3,280,题库,0,0,2,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个单链表的头节点和，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回。图示两个链表在节点开始相交题目数据整个链式结构中不存在环。，函数返回结果后，链表必须。的输入如下（你设计的程序此输入）：评测系统将根据这些输入创建链式数据结构，并将两个头节点和传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被。你能否设计一个时间复杂度、仅用内存的解决方案？,"intersectVal-相交的起始节点的值。如果不存在相交节点，这一值为listA-第一个链表listB-第二个链表skipA-在listA中（从头节点开始）跳到交叉节点的节点数skipB-在listB中（从头节点开始）跳到交叉节点的节点数listA中节点数目为listB中节点数目为1<=m,n<=3*101<=Node.val<=100<=skipA<=m0<=skipB<=n如果listA和listB没有交点，intersectVal为如果listA和listB有交点，intersectVal==listA[skipA]==listB[skipB]",1,3
156,97,2,61,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回所在位置即可。你可以假设。你必须实现时间复杂度为的算法来解决此问题。,1<=nums.length<=1000<=nums[i]<=2-1对于所有有效的都有nums[i]!=nums[i+1],1,2
157,61,2,32,题库,4,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个无序的数组，返回。如果数组元素个数小于2，则返回。您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。,1<=nums.length<=100<=nums[i]<=10,1,4
158,251,3,169,题库,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个版本号和，请你比较它们。版本号由一个或多个修订号组成，各修订号由一个连接。每个修订号由组成，可能包含。每个版本号至少包含一个字符。修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。例如，和都是有效的版本号。比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较。也就是说，修订号和修订号。如果版本号没有指定某个下标处的修订号，则该修订号视为。例如，版本小于版本，因为它们下标为的修订号相同，而下标为的修订号分别为和，。返回规则如下：,"如果version1version2返回如果version1version2返回除此之外返回1<=version1.length,version2.length<=500version1和version2仅包含数字和'.'version1和version2都是有效版本号version1和version2的所有修订号都可以存储在32位整数",1,2
159,82,3,42,题库,1,0,1,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数，分别表示分数的分子和分母，以。如果小数部分为循环小数，则将循环的部分括在括号内。如果存在多个答案，只需返回。对于所有给定的输入，答案字符串的长度小于。,"<=numerator,denominator<=2-1denominator!=0",1,3
160,130,3,89,题库,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，该数组已按，请你从数组中找出满足相加之和等于目标数的两个数。如果设这两个数分别是和，则。以长度为2的整数数组的形式返回这两个整数的下标和。你可以假设每个输入，而且你重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。,2<=numbers.length<=3*10-1000<=numbers[i]<=1000numbers按非递减顺序排列-1000<=target<=1000仅存在一个有效答案,1,3
161,29,4,20,题库,1,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，返回它在Excel表中相对应的列名称。例如：,1<=columnNumber<=2-1,1,2
162,101,2,40,题库,2,1,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个大小为的数组，返回其中的多数元素。多数元素是指在数组中出现次数的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。尝试设计时间复杂度为O(n)、空间复杂度为O(1)的算法解决此问题。,n==nums.length1<=n<=5*10-10<=nums[i]<=10,1,5
163,29,3,72,题库,1,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，表示Excel表格中的列名称。返回。例如：,"1<=columnTitle.length<=7columnTitle仅由大写英文组成columnTitle在范围[""A"",""FXSHRXW""]",1,2
164,47,3,8,题库,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数，返回结果中尾随零的数量。提示你可以设计并实现对数时间复杂度的算法来解决此问题吗？,0<=n<=10,1,1
165,128,1,301,题库,0,0,4,0,0,0,2,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"实现一个二叉搜索树迭代器类，表示一个按中序遍历二叉搜索树（BST）的迭代器：
注意，指针初始化为一个不存在于BST中的数字，所以对的首次调用将返回BST中的最小元素。你可以假设调用总是有效的，也就是说，当调用时，BST的中序遍历中至少存在一个下一个数字。","BSTIterator(TreeNoderoot)初始化BSTIterator类的一个对象。BST的根节点root会作为构造函数的一部分给出。指针应初始化为一个不存在于BST中的数字，且该数字小于BST中的任何元素。booleanhasNext()如果向指针右侧遍历存在数字，则返回true；否则返回falseintnext()将指针向右移动，然后返回指针处的数字。树中节点的数目在范围[1,100<=Node.val<=10最多调用次hasNext和next操作你可以设计一个满足下述条件的解决方案吗？next()和hasNext()操作均摊时间复杂度为O(1)，并使用O(h)内存。其中是树的高度。",1,6
166,332,2,74,题库,2,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,恶魔们抓住了公主并将她关在了地下城的。地下城是由个房间组成的二维网格。我们英勇的骑士最初被安置在的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至0或以下，他会立即死亡。有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为），要么包含增加骑士健康点数的魔法球（若房间里的值为，则表示骑士将增加健康点数）。为了尽快解救公主，骑士决定每次只或移动一步。返回确保骑士能够拯救到公主所需的最低初始健康点数。任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。,"m==dungeon.lengthn==dungeon[i].length1<=m,n<=200-1000<=dungeon[i][j]<=1000",1,3
167,65,1,0,题库,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表:表:编写一个SQL查询来报告表中每个人的姓、名、城市和州。如果的地址不在表中，则报告为空。以返回结果表。查询结果格式如下所示。,,1,0
168,43,2,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,查询并返回表中第二高的薪水。如果不存在第二高的薪水，查询应该返回。查询结果如下例所示。,,1,1
169,42,2,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,表:查询表中第高的工资。如果没有第个最高工资，查询结果应该为。查询结果格式如下所示。,,1,1
170,43,1,78,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表:查询并对分数进行排序。排名按以下规则计算:按降序返回结果表。查询结果格式如下所示。,分数应按从高到低排列。如果两个分数相等，那么两个分数的排名应该相同。在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。,1,1
171,68,2,33,题库,3,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,给定一组非负整数，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。输出结果可能非常大，所以你需要返回一个字符串而不是整数。,1<=nums.length<=1000<=nums[i]<=10,1,4
172,47,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,表：找出所有至少连续出现三次的数字。返回的结果表中的数据可以按排列。结果格式如下面的例子所示：,,1,1
173,42,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表：编写一个SQL查询来查找收入比经理高的员工。以返回结果表。查询结果格式如下所示。,,1,1
174,62,1,0,题库,0,0,0,0,0,0,1,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表:编写一个SQL查询来报告所有重复的电子邮件。请注意，可以保证电子邮件字段不为NULL。以返回结果表。查询结果格式如下例。,,1,1
175,35,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表：表：找出所有从不点任何东西的顾客。以返回结果表。结果格式如下所示。,,1,1
176,43,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,"表：表：查找出每个部门中薪资最高的员工。
按返回结果表。
查询结果格式如下例所示。",,1,1
177,88,1,0,题库,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,表:表:公司的主管们感兴趣的是公司每个部门中谁赚的钱最多。一个部门的是指一个员工的工资在该部门的工资中。编写一个SQL查询，找出每个部门中。以返回结果表。查询结果格式如下所示。,,1,1
178,87,2,56,题库,1,0,1,0,4,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"由一系列核苷酸组成，缩写为,,和.。在研究时，识别DNA中的重复序列非常有用。给定一个表示的字符串，返回所有在DNA分子中出现不止一次的的序列(子字符串)。你可以按返回答案。","例如，""ACGAATTCCG""是一个DNA序列0<=s.length<=10s[i]'A''C''G'or'T'",1,6
179,109,2,49,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数，其中是某支给定的股票在第天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成笔交易。也就是说，你最多可以买次，卖次。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。,1<=k<=1001<=prices.length<=10000<=prices[i]<=1000,1,2
180,31,2,98,题库,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，将数组中的元素向右轮转个位置，其中是非负数。,1<=nums.length<=10<=nums[i]<=2-10<=k<=10尽可能想出更多的解决方案，至少有不同的方法可以解决这个问题。你可以使用空间复杂度为O(1)的原地算法解决这个问题吗？,1,3
181,42,3,182,题库,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,颠倒给定的32位无符号整数的二进制位。:如果多次调用这个函数，你将如何优化你的算法？,请注意，在某些语言（如Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在Java中，编译器使用二进制补码记法来表示有符号整数。因此，在示例2中，输入表示有符号整数，输出表示有符号整数-1073741825输入是一个长度为的二进制字符串,1,2
182,57,4,181,题库,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为'1'的个数（也被称为）。：,请注意，在某些语言（如Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在Java中，编译器使用二进制补码记法来表示有符号整数。因此，在示例3中，输入表示有符号整数输入必须是长度为的二进制串如果多次调用这个函数，你将如何优化你的算法？,1,2
183,67,1,100,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,写一个bash脚本以统计一个文本文件中每个单词出现的频率。为了简单起见，你可以假设：假设内容如下：你的脚本应当输出（以词频降序排列）：,words.txt只包括小写字母和''每个单词只由小写字母组成。单词间由一个或多个空格字符分隔。不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。你可以使用一行Unixpipes实现吗？,1,1
184,157,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个包含电话号码列表（一行一个电话号码）的文本文件，写一个单行bash脚本输出所有有效的电话号码。你可以假设一个有效的电话号码必须满足以下两种格式：(xxx)xxx-xxxx或xxx-xxx-xxxx。（x表示一个数字）你也可以假设每行前后没有多余的空格字符。假设内容如下：你的脚本应当输出下列有效的电话号码：,,1,1
185,50,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个文件，转置它的内容。你可以假设每行列数相同，并且每个字段由分隔。假设文件内容如下：应当输出：,,1,1
186,93,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,"给定一个文本文件，请只打印这个文件中的第十行。假设有如下内容：你的脚本应当显示第十行：
1.如果文件少于十行，你应当输出什么？
2.至少有三种不同的解法，请尝试尽可能多的方法来解题。",,1,1
187,142,1,0,题库,0,0,0,0,0,0,1,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表:所有重复的电子邮件，只保留一个具有最小的唯一电子邮件。（对于SQL用户，请注意你应该编写一个语句而不是语句。）（对于Pandas用户，请注意你应该直接修改表。）运行脚本后，显示的答案是表。驱动程序将首先编译并运行您的代码片段，然后再显示表。表的最终顺序。返回结果格式如下示例所示。,,1,1
188,43,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：找出与之前（昨天的）日期相比温度更高的所有日期的。返回结果。结果格式如下例子所示。,,1,1
189,106,2,34,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，。给定一个代表每个房屋存放金额的非负整数数组，计算你，一夜之内能够偷窃到的最高金额。,1<=nums.length<=1000<=nums[i]<=400,1,2
190,46,3,38,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。,"二叉树的节点个数的范围是[0,100]-100<=Node.val<=100",1,4
191,96,2,62,题库,2,2,0,1,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由（陆地）和（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。,"m==grid.lengthn==grid[i].length1<=m,n<=300grid[i][j]的值为'0'或'1'",1,5
192,34,3,19,题库,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和，表示区间，返回此区间内所有数字的结果（包含、端点）。,0<=left<=right<=2-1,1,1
193,37,2,95,题库,0,0,1,0,1,1,0,1,0,0,0,1,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写一个算法来判断一个数是不是快乐数。定义为：如果是就返回；不是，则返回。,对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。如果这个过程结果为1，那么这个数就是快乐数。1<=n<=2-1,1,3
194,37,3,41,题库,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你一个链表的头节点和一个整数，请你删除链表中所有满足的节点，并返回。
","列表中的节点数目在范围[0,101<=Node.val<=500<=val<=50",1,2
195,8,3,10,题库,2,0,0,0,0,2,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定整数，返回。,0<=n<=5*10,1,4
196,127,3,51,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个字符串和，判断它们是否是同构的。如果中的字符可以按某种映射关系替换得到，那么这两个字符串是同构的。每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。,1<=s.length<=5*10t.length==s.length和由任意有效的ASCII字符组成,1,2
197,61,3,40,题库,0,1,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,EASY,"给你单链表的头节点，请你反转链表，并返回反转后的链表。
链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？","链表中节点的数目范围是[0,5000]-5000<=Node.val<=5000",1,2
198,96,2,149,题库,0,2,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你这个学期必须选修门课程，记为到。在选修某些课程之前需要一些先修课程。先修课程按数组给出，其中，表示如果要学习课程则先学习课程。请你判断是否可能完成所有课程的学习？如果可以，返回；否则，返回。,"例如，先修课程对[0,1]表示：想要学习课程，你需要先完成课程1<=numCourses<=20000<=prerequisites.length<=5000prerequisites[i].length==20<=a,b<numCoursesprerequisites[i]中的所有课程对互不相同",1,4
199,82,1,287,题库,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,"（发音类似""try""）或者说是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现Trie类：","Trie()初始化前缀树对象。voidinsert(Stringword)向前缀树中插入字符串wordbooleansearch(Stringword)如果字符串word在前缀树中，返回true（即，在检索之前已经插入）；否则，返回falsebooleanstartsWith(Stringprefix)如果之前已经插入的字符串word的前缀之一为prefix，返回true；否则，返回false1<=word.length,prefix.length<=2000word和prefix仅由小写英文字母组成insertsearch和startsWith调用次数不超过3*10",1,4
200,59,3,91,题库,1,1,0,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给定一个含有个正整数的数组和一个正整数找出该数组中满足其和的长度最小的，并返回其长度如果不存在符合条件的子数组，返回。,"1<=target<=101<=nums.length<=101<=nums[i]<=10如果你已经实现O(n)时间复杂度的解法,请尝试设计一个O(nlog(n))时间复杂度的解法。",1,4
201,95,3,156,题库,0,2,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现在你总共有门课需要选，记为到。给你一个数组，其中，表示在选修课程前先选修。返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回就可以了。如果不可能完成所有课程，返回。,"例如，想要学习课程，你需要先完成课程，我们用一个匹配来表示：[0,1]1<=numCourses<=20000<=prerequisites.length<=numCourses*(numCourses-1)prerequisites[i].length==20<=a,b<numCourses!=b,b互不相同",1,4
202,46,1,231,题库,1,1,0,1,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你设计一个数据结构，支持添加新单词和查找字符串是否与任何先前添加的字符串匹配。实现词典类：,WordDictionary()初始化词典对象voidaddWord(word)将word添加到数据结构中，之后可以对它进行匹配boolsearch(word)如果数据结构中存在字符串与word匹配，则返回true；否则，返回falseword中可能包含一些'.'，每个都可以表示任何一个字母。1<=word.length<=25addWord中的word由小写英文字母组成search中的word由'.'或小写英文字母组成最多调用次addWord和search,1,4
203,95,2,139,题库,3,1,0,1,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个二维字符网格和一个单词（字符串）列表，。单词必须按照字母顺序，通过内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。,"m==board.lengthn==board[i].length1<=m,n<=12board[i][j]是一个小写英文字母1<=words.length<=3*101<=words[i].length<=10words[i]由小写英文字母组成words中的所有字符串互不相同",1,5
204,126,3,35,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，。给定一个代表每个房屋存放金额的非负整数数组，计算你，今晚能够偷窃到的最高金额。,1<=nums.length<=1000<=nums[i]<=1000,1,2
205,53,2,27,题库,2,0,0,0,2,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。,0<=s.length<=5*10仅由小写英文字母组成,1,4
206,82,2,37,题库,2,2,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定整数数组和整数，请返回数组中第个最大的元素。请注意，你需要找的是数组排序后的第个最大的元素，而不是第个不同的元素。你必须设计并实现时间复杂度为的算法解决此问题。,1<=k<=nums.length<=10-10<=nums[i]<=10,1,5
207,54,3,33,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,找出所有相加之和为的个数的组合，且满足下列条件：返回。该列表不能包含相同的组合两次，组合可以以任何顺序返回。,只使用数字1到9每个数字最多使用一次2<=k<=91<=n<=60,1,2
208,43,3,34,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你一个整数数组。如果任一值在数组中出现，返回；如果数组中每个元素互不相同，返回。
",1<=nums.length<=10-10<=nums[i]<=10,1,3
209,252,2,125,题库,1,1,2,2,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,城市的是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回。每个建筑物的几何信息由数组表示，其中三元组表示：你可以假设所有的建筑都是完美的长方形，在高度为的绝对平坦的表面上。应该表示为由“关键点”组成的列表，格式，并按进行。。列表中最后一个点是最右侧建筑物的终点，坐标始终为，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。输出天际线中不得有连续的相同高度的水平线。例如是不正确的答案；三条高度为5的线应该在最终输出中合并为一个：,left是第座建筑物左边缘的坐标。right是第座建筑物右边缘的坐标。height是第座建筑物的高度。1<=buildings.length<=100<=left<right<=2-11<=height<=2-1buildings按left非递减排序,1,7
210,45,3,42,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组和一个整数，判断数组中是否存在两个和，满足且。如果存在，返回；否则，返回。,1<=nums.length<=10-10<=nums[i]<=100<=k<=10,1,3
211,41,2,129,题库,3,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和两个整数和。找出满足下述条件的下标对：如果存在，返回否则，返回。,i!=jabs(i-j)<=indexDiffabs(nums[i]-nums[j])<=valueDiff2<=nums.length<=10-10<=nums[i]<=101<=indexDiff<=nums.length0<=valueDiff<=10,1,5
212,33,3,66,题库,2,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个由和组成的二维矩阵内，找到只包含的最大正方形，并返回其面积。,"m==matrix.lengthn==matrix[i].length1<=m,n<=300matrix[i][j]为'0'或'1'",1,3
213,142,3,50,题库,0,2,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵的根节点，求出该树的节点个数。的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第层，则该层包含个节点。遍历树来统计节点是一种时间复杂度为的简单解决方案。你可以设计一个更快的算法吗？,"树中节点的数目范围是[0,5*100<=Node.val<=5*10题目数据保证输入的树是完全二叉树",1,4
214,45,2,114,题库,0,0,0,0,0,2,0,0,0,0,1,1,1,0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你平面上两个的矩形，请你计算并返回两个矩形覆盖的总面积。每个矩形由其顶点和顶点坐标表示：,"第一个矩形由其左下顶点(ax1,ay1)和右上顶点(ax2,ay2)定义。第二个矩形由其左下顶点(bx1,by1)和右上顶点(bx2,by2)定义。-10<=ax1,ay1,ax2,ay2,bx1,by1,bx2,by2<=10",1,2
215,64,3,150,题库,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串表达式，请你实现一个基本计算器来计算并返回它的值。注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如。,"1<=s.length<=3*10由数字、'+''-''('')'、和''组成表示一个有效的表达式'+'不能用作一元运算(例如，""+1""和""+(2+3)""无效)'-'可以用作一元运算(即""-1""和""-(2+3)""是有效的)输入中不存在两个连续的操作符每个数字和运行的计算将适合于一个有符号的32位整数",1,4
216,63,1,266,题库,0,0,2,0,0,0,1,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（、、和）。实现类：你能否仅用一个队列来实现栈。,"voidpush(intx)将元素x压入栈顶。intpop()移除并返回栈顶元素。inttop()返回栈顶元素。booleanempty()如果栈是空的，返回true；否则，返回false你只能使用队列的基本操作——也就是pushtobackpeek/popfromfrontsize和isempty这些操作。你所使用的语言也许不支持队列。你可以使用list（列表）或者deque（双端队列）来模拟一个队列,只要是标准的队列操作即可。1<=x<=9最多调用100次pushpoptop和empty每次调用pop和top都保证栈不为空",1,3
217,28,3,35,题库,0,2,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一棵二叉树的根节点，翻转这棵二叉树，并返回其根节点。,"树中节点数目范围在[0,100]-100<=Node.val<=100",1,4
218,103,3,107,题库,1,0,1,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串表达式，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。你可以假设给定的表达式总是有效的。所有中间结果将在的范围内。不允许使用任何将字符串作为数学表达式计算的内置函数，比如。,"1<=s.length<=3*10由整数和算符('+','-','*','/')组成，中间由一些空格隔开表示一个有效表达式表达式中的所有整数都是非负整数，且在范围[0,2-1]题目数据保证答案是一个32-bit整数",1,3
219,76,2,78,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个的整数数组。返回。也就是说，的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于的数字。列表中的每个区间范围应该按如下格式输出：,"""a->b""，如果a!=b""a""，如果a==b0<=nums.length<=20<=nums[i]<=2-1nums中的所有值都互不相同nums按升序排列",1,1
220,62,3,36,题库,2,0,1,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个大小为的整数数组，找出其中所有出现超过次的元素。尝试设计时间复杂度为O(n)、空间复杂度为O(1)的算法解决此问题。,1<=nums.length<=5*10-10<=nums[i]<=10,1,4
221,92,2,33,题库,0,1,3,0,0,0,0,1,0,0,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉搜索树的根节点，和一个整数，请你设计一个算法查找其中第个最小元素（从1开始计数）。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第小的值，你将如何优化算法？,树中的节点数为1<=k<=n<=100<=Node.val<=10,1,4
222,75,5,8,题库,0,1,0,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，请你判断该整数是否是2的幂次方。如果是，返回；否则，返回。如果存在一个整数使得，则认为是2的幂次方。你能够不使用循环/递归解决此问题吗？,<=n<=2-1,1,3
223,44,1,350,题库,0,0,2,0,0,0,1,0,0,1,1,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（、、、）：实现类：,"voidpush(intx)将元素x推到队列的末尾intpop()从队列的开头移除并返回元素intpeek()返回队列开头的元素booleanempty()如果队列为空，返回true；否则，返回false使用标准的栈操作——也就是只有pushtotoppeek/popfromtopsize,和isempty操作是合法的。你所使用的语言也许不支持栈。你可以使用list或者deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。1<=x<=9最多调用100次pushpoppeek和empty假设所有操作都是有效的（例如，一个空的队列不会调用pop或者peek操作）你能否实现每个操作均摊时间复杂度为O(1)的队列？换句话说，执行个操作的总时间复杂度为O(n)，即使其中一个操作可能花费较长时间。",1,3
224,29,2,8,题库,0,2,0,0,0,1,0,0,0,0,1,1,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个整数，计算所有小于等于的非负整数中数字出现的个数。,0<=n<=10,1,3
225,60,2,29,题库,0,1,2,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个单链表的头节点，请你判断该链表是否为回文链表。如果是，返回；否则，返回。你能否用时间复杂度和空间复杂度解决此题？,"链表中节点数目在范围[1,100<=Node.val<=9",1,4
226,142,2,35,题库,0,1,3,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个二叉搜索树,找到该树中两个指定节点的最近公共祖先。中最近公共祖先的定义为：“对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（）。”例如，给定如下二叉搜索树:root=[6,2,8,0,4,7,9,null,null,3,5]",所有节点的值都是唯一的。p、q为不同节点且均存在于给定的二叉搜索树中。,1,4
227,93,3,64,题库,0,1,2,0,0,0,0,1,0,0,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个二叉树,找到该树中两个指定节点的最近公共祖先。中最近公共祖先的定义为：“对于有根树T的两个节点p、q，最近公共祖先表示为一个节点x，满足x是p、q的祖先且x的深度尽可能大（）。”","树中节点数目在范围[2,10内。-10<=Node.val<=10所有Node.val互不相同p!=q和均存在于给定的二叉树中。",1,3
228,107,2,234,题库,0,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,有一个单链表的，我们想删除它其中的一个节点。给你一个需要删除的节点。你将第一个节点。链表的所有值都是，并且保证给定的节点不是链表中的最后一个节点。删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：,"给定节点的值不应该存在于链表中。链表中的节点数应该减少1。node前面的所有值顺序相同。node后面的所有值顺序相同。对于输入，你应该提供整个链表head和要给出的节点nodenode不应该是链表的最后一个节点，而应该是链表中的一个实际节点。我们将构建链表，并将节点传递给你的函数。输出将是调用你函数后的整个链表。链表中节点的数目范围是[2,1000]-1000<=Node.val<=1000链表中每个节点的值都是需要删除的节点node是链表中的节点，且不是末尾节点",1,1
229,105,2,69,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，返回。题目数据数组之中任意元素的全部前缀元素和后缀的乘积都在整数范围内。请且在时间复杂度内完成此题。你可以在的额外空间复杂度内完成这个题目吗？（出于对空间复杂度分析的目的，输出数组额外空间。）,2<=nums.length<=10-30<=nums[i]<=30数组nums之中任意元素的全部前缀元素和后缀的乘积都在32位整数范围内,1,2
230,71,2,51,题库,1,0,3,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，有一个大小为的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的个数字。滑动窗口每次只向右移动一位。返回。,1<=nums.length<=10-10<=nums[i]<=101<=k<=nums.length,1,5
231,32,2,140,题库,2,2,0,0,0,0,0,0,0,1,1,0,1,0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,编写一个高效的算法来搜索矩阵中的一个目标值。该矩阵具有以下特性：,"每行的元素从左到右升序排列。每列的元素从上到下升序排列。m==matrix.lengthn==matrix[i].length1<=n,m<=300-10<=matrix[i][j]<=10每行的所有元素从左到右升序排列每列的所有元素从上到下升序排列-10<=target<=10",1,4
232,92,2,74,题库,1,3,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由数字和运算符组成的字符串，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以返回答案。生成的测试用例满足其对应输出值符合32位整数范围，不同结果的数量不超过。,"1<=expression.length<=20expression由数字和算符'+''-'和'*'组成。输入表达式中的所有整数值在范围[0,99]",1,5
233,94,2,34,题库,2,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个字符串和，编写一个函数来判断是否是的字母异位词。若和中每个字符出现的次数都相同，则称和互为字母异位词。如果输入字符串包含unicode字符怎么办？你能否调整你的解法来应对这种情况？,"1<=s.length,t.length<=5*10和仅包含小写字母",1,3
234,42,2,36,题库,1,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二叉树的根节点，按，返回所有从根节点到叶子节点的路径。是指没有子节点的节点。,"树中节点的数目在范围[1,100]-100<=Node.val<=100",1,5
235,66,2,11,题库,1,0,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非负整数，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。你可以不使用循环或者递归，在时间复杂度内解决这个问题吗？,0<=num<=2-1,1,3
236,94,3,62,题库,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。你可以按返回答案。你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。,2<=nums.length<=3*10<=nums[i]<=2-1除两个只出现一次的整数外，nums中的其他数字都出现两次,1,2
237,161,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"表：
表：的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量)/(非禁止用户生成的订单总数)。写一段SQL语句查出至期间非禁止用户（）的取消率。非禁止用户即banned为No的用户，禁止用户即banned为Yes的用户。返回结果表中的数据可以按任意顺序组织。其中取消率需要四舍五入保留。查询结果格式如下例所示。",,1,1
238,43,3,8,题库,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,就是只包含质因数、和的正整数。给你一个整数，请你判断是否为。如果是，返回；否则，返回。,<=n<=2-1,1,1
239,34,2,10,题库,0,1,2,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你找出并返回第个。就是只包含质因数、和/或的正整数。,1<=n<=1690,1,4
240,64,4,50,题库,2,1,1,0,1,1,0,0,0,0,1,1,1,0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个包含中个数的数组，找出这个范围内没有出现在数组中的那个数。你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?,n==nums.length1<=n<=100<=nums[i]<=nnums中的所有数字都独一无二,1,6
241,17,3,11,题库,1,1,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,将非负整数转换为其对应的英文表示。,0<=num<=2-1,1,3
242,109,2,50,题库,3,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中表示研究者的第篇论文被引用的次数。计算并返回该研究者的。根据维基百科上：代表“高引用次数”，一名科研人员的是指他（她）至少发表了篇论文，并且每篇论文被引用次。如果有多种可能的值，是其中最大的那个。,n==citations.length1<=n<=50000<=citations[i]<=1000,1,3
243,131,2,62,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中表示研究者的第篇论文被引用的次数，已经按照。计算并返回该研究者的h指数。：h代表“高引用次数”（highcitations），一名科研人员的指数是指他（她）的（篇论文中）有篇论文分别被引用了次。请你设计并实现对数时间复杂度的算法解决此问题。,n==citations.length1<=n<=100<=citations[i]<=1000citations按升序排列,1,2
244,178,2,14,题库,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。假设你有个版本，你想找出导致之后所有版本出错的第一个错误的版本。你可以通过调用接口来判断版本号是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用API的次数。,1<=bad<=n<=2-1,1,2
245,66,2,8,题库,0,2,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，返回。是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，、、和都是完全平方数，而和不是。,1<=n<=10,1,3
246,72,3,37,题库,1,1,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个仅包含数字的字符串和一个目标值整数，在的数字之间添加运算符（不是一元）、或，返回能够得到的表达式。注意，返回表达式中的操作数包含前导零。,1<=num.length<=10num仅含数字<=target<=2-1,1,3
247,78,2,32,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个数组，编写一个函数将所有移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。:你能尽量减少完成的操作次数吗？,1<=nums.length<=10<=nums[i]<=2-1,1,2
248,106,1,233,题库,1,0,0,0,0,0,2,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你在设计一个迭代器，在集成现有迭代器拥有的和操作的基础上，还额外支持操作。实现类：每种语言可能有不同的构造函数和迭代器，但均支持和函数。你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？,PeekingIterator(Iterator<int>nums)使用指定整数迭代器nums初始化迭代器。intnext()返回数组中的下一个元素，并将指针移动到下个元素处。boolhasNext()如果数组中存在下一个元素，返回true；否则，返回falseintpeek()返回数组中的下一个元素，但移动指针。1<=nums.length<=10001<=nums[i]<=1000next和peek的调用均有效nexthasNext和peek最多调用1000,1,3
249,73,2,111,题库,1,1,0,0,2,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个包含个整数的数组，其数字都在范围内（包括和），可知至少存在一个重复的整数。假设只有，返回。你设计的解决方案必须数组且只用常量级的额外空间。,1<=n<=10nums.length==n+11<=nums[i]<=nnums中只有一个整数出现两次或多次，其余整数均只出现如何证明nums中至少存在一个重复的数字?你可以设计一个线性级时间复杂度O(n)的解决方案吗？,1,4
250,207,2,180,题库,3,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,根据，，简称为，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。给定一个包含个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：即为（live），或即为（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你网格面板的当前状态，返回下一个状态。,"m==board.lengthn==board[i].length1<=m,n<=25board[i][j]为或你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？",1,3
251,70,3,91,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一种规律和一个字符串，判断是否遵循相同的规律。这里的指完全匹配，例如，里的每个字母和字符串中的每个非空单词之间存在着双向连接的对应规律。,1<=pattern.length<=300pattern只包含小写英文字母1<=s.length<=3000只包含小写英文字母和''不包含任何前导或尾随对空格中每个单词都被单个空格,1,2
252,75,3,69,题库,0,0,0,0,0,2,1,1,0,0,0,1,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你和你的朋友，两个人一起玩：假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为的情况下赢得游戏。如果可以赢，返回；否则，返回。,桌子上有一堆石头。你们轮流进行自己的回合，你作为先手每一回合，轮到的人拿掉1-3块石头。拿掉最后一块石头的人就是获胜者。1<=n<=2-1,1,3
253,117,1,232,题库,1,0,1,0,1,0,2,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。实现MedianFinder类:初始化对象。将数据流中的整数添加到数据结构中。返回到目前为止所有元素的中位数。与实际答案相差以内的答案将被接受。,"例如arr=[2,3,4]的中位数是例如arr=[2,3]的中位数是(2+3)/2=2.5MedianFinder()初始化MedianFinder对象。voidaddNum(intnum)将数据流中的整数num添加到数据结构中。doublefindMedian()返回到目前为止所有元素的中位数。与实际答案相差以内的答案将被接受。-10<=num<=10在调用findMedian之前，数据结构中至少有一个元素最多5*10次调用addNum和findMedian",1,5
254,235,4,34,题库,1,2,2,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列/反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。输入输出格式与LeetCode目前使用的方式一致，详情请参阅。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。,"树中结点数在范围[0,10-1000<=Node.val<=1000",1,6
255,152,2,183,题库,1,0,1,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你在和朋友一起玩游戏，该游戏规则如下：写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：给你一个秘密数字和朋友猜测的数字，请你返回对朋友这次猜测的提示。提示的格式为，是公牛个数，是奶牛个数，表示公牛，表示奶牛。请注意秘密数字和朋友猜测的数字都可能含有重复数字。,"猜测数字中有多少位属于数字和确切位置都猜对了（称为""Bulls""，公牛），有多少位属于数字猜对了但是位置不对（称为""Cows""，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。1<=secret.length,guess.length<=1000secret.length==guess.lengthsecret和guess仅由数字组成",1,3
256,75,3,62,题库,1,2,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，找到其中最长严格递增子序列的长度。是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，是数组的子序列。,1<=nums.length<=2500-10<=nums[i]<=10你能将算法的时间复杂度降低到O(nlog(n))吗?,1,3
257,60,3,42,题库,1,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,给你一个由若干括号和字母组成的字符串，删除最小数量的无效括号，使得输入的字符串有效。返回所有可能的结果。答案可以按返回。,1<=s.length<=25由小写英文字母以及括号'('和')'组成中至多含个括号,1,3
258,25,1,205,题库,1,0,0,0,1,0,1,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给定一个整数数组，处理以下类型的多个查询:实现类：,"NumArray(int[]nums)使用数组nums初始化对象intsumRange(inti,intj)返回数组nums中索引left和right之间的元素的，包含left和right两点（也就是nums[left]+nums[left+1]+...+nums[right]1<=nums.length<=10-10<=nums[i]<=100<=i<=j<nums.length最多调用次sumRange",1,3
259,14,1,289,题库,2,0,0,0,1,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,以下类型的多个请求：实现类：,"计算其子矩形范围内元素的总和，该子矩阵的左上角为(row1,col1)右下角为(row2,col2)NumMatrix(int[][]matrix)给定整数矩阵matrix进行初始化intsumRegion(introw1,intcol1,introw2,intcol2)返回左上角(row1,col1)右下角(row2,col2)所描述的子矩阵的元素m==matrix.lengthn==matrix[i].length1<=m,n<=200-10<=matrix[i][j]<=100<=row1<=row2<m0<=col1<=col2<n最多调用次sumRegion方法",1,4
260,167,2,29,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是一个字符串，组成它的数字可以形成累加序列。一个有效的必须包含3个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。给你一个只包含数字的字符串，编写一个算法来判断给定输入是否是。如果是，返回；否则，返回。累加序列里的数，除数字0之外，以0开头，所以不会出现或者的情况。你计划如何处理由过大的整数输入导致的溢出?,1<=num.length<=35num仅由数字（-）组成,1,2
261,20,1,312,题库,1,0,0,2,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，请你完成两类查询。实现类：,"NumArray(int[]nums)用整数数组nums初始化对象voidupdate(intindex,intval)将nums[index]的值为valintsumRange(intleft,intright)返回数组nums中索引left和索引right之间（包含）的nums元素的（即，nums[left]+nums[left+1],...,nums[right]1<=nums.length<=3*10-100<=nums[i]<=1000<=index<nums.length-100<=val<=1000<=left<=right<nums.length调用update和sumRange方法次数不大于3*10",1,4
262,104,2,67,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，其中第表示第天的股票价格。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。,卖出股票后，你无法在第二天买入股票(即冷冻期为1天)。1<=prices.length<=50000<=prices[i]<=1000,1,2
263,198,2,65,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,树是一个无向图，其中任何两个顶点只通过一条路径连接。换句话说，一个任何没有简单环路的连通图都是一棵树。给你一棵包含个节点的树，标记为到。给定数字和一个有条无向边的列表（每一个边都是一对标签），其中表示树中节点和之间存在一条无向边。可选择树中任何一个节点作为根。当选择节点作为根节点时，设结果树的高度为。在所有可能的树中，具有最小高度的树（即，）被称为。请你找到所有的并按返回它们的根节点标签列表。,"1<=n<=2*10edges.length==n-10<=a,b<n!=b所有,b互不相同给定的输入是一棵树，并且不会有重复的边",1,4
264,63,2,92,题库,1,1,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是一个正整数，并满足其所有质因数都出现在质数数组中。给你一个整数和一个整数数组，返回第个。题目数据保证第个在带符号整数范围内。,1<=n<=101<=primes.length<=1002<=primes[i]<=1000题目数据保证primes[i]是一个质数primes中的所有值都互不相同，且按递增顺序排列,1,3
265,41,3,34,题库,1,3,1,2,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，按要求返回一个新数组。数组有该性质：的值是右侧小于的元素的数量。,1<=nums.length<=10-10<=nums[i]<=10,1,7
266,51,3,60,题库,2,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串数组，找出并返回的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回。,2<=words.length<=10001<=words[i].length<=1000words[i]仅包含小写字母,1,3
267,144,3,8,题库,0,0,0,0,0,1,1,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,初始时有个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第轮，你每个灯泡就切换第个灯泡的开关。直到第轮，你只需要切换最后一个灯泡的开关。找出并返回轮后有多少个亮着的灯泡。,0<=n<=10,1,2
268,137,3,0,题库,0,1,2,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定长度分别为和的两个数组，其元素由构成，表示两个自然数各位上的数字。现在从这两个数组中选出个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。求满足该条件的最大数。结果返回一个表示该最大数的长度为的数组。请尽可能地优化你算法的时间和空间复杂度。,,1,3
269,87,3,48,题库,1,2,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，表示不同面额的硬币；以及一个整数，表示总金额。计算并返回可以凑成总金额所需的。如果没有任何一种硬币组合能组成总金额，返回。你可以认为每种硬币的数量是无限的。,1<=coins.length<=121<=coins[i]<=2-10<=amount<=10,1,3
270,76,2,68,题库,2,2,0,0,0,0,0,1,0,0,0,1,0,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，将它重新排列成的顺序。你可以假设所有输入数组都可以得到满足题目要求的结果。你能用O(n)时间复杂度和/或原地O(1)额外空间来实现吗？,1<=nums.length<=5*100<=nums[i]<=5000题目数据保证，对于给定的输入nums，总能产生满足题目要求的结果,1,4
271,74,4,8,题库,0,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数，写一个函数来判断它是否是3的幂次方。如果是，返回；否则，返回。整数是3的幂次方需满足：存在整数使得你能不使用循环或者递归来完成本题吗？,<=n<=2-1,1,2
272,57,2,70,题库,1,3,1,2,0,0,0,0,0,1,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组以及两个整数和。求数组中，值位于范围（包含和）之内的。表示在中，位置从到的元素之和，包含和(≤)。,1<=nums.length<=10<=nums[i]<=2-1-10<=lower<=upper<=10题目数据保证答案是一个32位的整数,1,7
273,128,2,35,题库,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给定单链表的头节点，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。节点的索引被认为是，节点的索引为，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在的额外空间复杂度和的时间复杂度下解决这个问题。,n==链表中的节点数0<=n<=10-10<=Node.val<=10,1,1
274,63,3,66,题库,2,4,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个整数矩阵，找出其中的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。你在方向上移动或移动到（即不允许环绕）。,"m==matrix.lengthn==matrix[i].length1<=m,n<=2000<=matrix[i][j]<=2-1",1,8
275,73,3,52,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个已排序的正整数数组和一个正整数从区间内选取任意个数字补充到nums中，使得区间内的任何数字都可以用nums中某几个数字的和来表示。请返回。,1<=nums.length<=10001<=nums[i]<=10nums按升序排列1<=n<=2-1,1,2
276,197,3,84,题库,1,0,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,序列化二叉树的一种方法是使用。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如。例如，上面的二叉树可以被序列化为字符串，其中代表一个空节点。给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。每个以逗号分隔的字符或为一个整数或为一个表示指针的。你可以认为输入格式总是有效的不允许重建树。,"例如它永远不会包含两个连续的逗号，比如""1,,3""1<=preorder.length<=10preorder由以逗号“，”分隔的[0,100]范围内的整数和“#”组成",1,4
277,145,2,132,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一份航线列表，其中表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。所有这些机票都属于一个从（肯尼迪国际机场）出发的先生，所以该行程必须从开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。假定所有机票至少存在一种合理的行程。且所有的机票必须都用一次且只能用一次。,"例如，行程[""JFK"",""LGA""]与[""JFK"",""LGB""]相比就更小，排序更靠前。1<=tickets.length<=300tickets[i].length==2from.length==3.length==3from和由大写英文字母组成from!=to",1,3
278,82,3,34,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，判断这个数组中是否存在长度为的递增子序列。如果存在这样的三元组下标且满足，使得，返回；否则，返回。你能实现时间复杂度为，空间复杂度为的解决方案吗？,1<=nums.length<=5*10<=nums[i]<=2-1,1,2
279,101,3,40,题库,1,0,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组。从平面上的点开始，先向北移动米，然后向西移动米，向南移动米，向东移动米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。判断你所经过的路径是否相交。如果相交，返回；否则，返回。,1<=distance.length<=101<=distance[i]<=10,1,3
280,37,3,61,题库,2,0,1,1,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一组的单词，找出所有的索引对，使得列表中的两个单词，，可拼接成回文串。,1<=words.length<=50000<=words[i].length<=300words[i]由小写英文字母组成,1,4
281,118,2,29,题库,0,2,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为。除了之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果，房屋将自动报警。给定二叉树的。返回。,"树的节点数在[1,10范围内0<=Node.val<=10",1,4
282,39,2,107,题库,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，对于中的每个，计算其二进制表示中，返回一个长度为的数组作为答案。,0<=n<=10很容易就能实现时间复杂度为O(nlogn)的解决方案，你可以在线性时间复杂度O(n)内用一趟扫描解决此问题吗？你能不使用任何内置函数解决此问题吗？（如，C++中的__builtin_popcount,1,2
283,136,2,179,题库,0,1,3,0,0,0,2,1,0,0,0,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个嵌套的整数列表。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。实现扁平迭代器类：你的代码将会用下述伪代码检测：如果与预期的扁平化列表匹配，那么你的代码将会被判为正确。,"NestedIterator(List<NestedInteger>nestedList)用嵌套列表nestedList初始化迭代器。intnext()返回嵌套列表的下一个整数。booleanhasNext()如果仍然存在待迭代的整数，返回true；否则，返回false1<=nestedList.length<=500嵌套列表中的整数值在范围[-10,10",1,6
284,74,3,8,题库,0,1,0,0,1,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数，写一个函数来判断它是否是4的幂次方。如果是，返回；否则，返回。整数是4的幂次方需满足：存在整数使得你能不使用循环或者递归来完成本题吗？,<=n<=2-1,1,3
285,35,2,8,题库,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个正整数，将其拆分为个的和（），并使这些整数的乘积最大化。返回。,2<=n<=58,1,2
286,77,2,35,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组的形式给出。不要给另外的数组分配额外的空间，你必须、使用O(1)的额外空间解决这一问题。,1<=s.length<=10s[i]都是ASCII码表中的可打印字符,1,2
287,61,2,31,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括、、、、，且可能以大小写两种形式出现不止一次。,1<=s.length<=3*10由可打印的ASCII字符组成,1,2
288,62,2,72,题库,3,2,2,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你返回其中出现频率前高的元素。你可以按返回答案。你所设计算法的时间复杂度优于，其中是数组大小。,"1<=nums.length<=10的取值范围是[1,数组中不相同的元素的个数]题目数据保证答案唯一，换句话说，数组中前个高频元素的集合是唯一的",1,8
289,31,2,60,题库,2,1,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个数组和，返回。输出结果中的每个元素一定是的。我们可以。,"1<=nums1.length,nums2.length<=10000<=nums1[i],nums2[i]<=1000",1,5
290,92,2,159,题库,2,1,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数数组和，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。,"1<=nums1.length,nums2.length<=10000<=nums1[i],nums2[i]<=1000如果给定的数组已经排好序呢？你将如何优化你的算法？如果nums1的大小比nums2小，哪种方法更优？如果nums2的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？",1,5
291,84,1,153,题库,0,1,1,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个由非负整数组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。实现类：如果存在大量合并，并且与数据流的大小相比，不相交区间的数量很小，该怎么办?,"SummaryRanges()使用一个空数据流初始化对象。voidaddNum(intval)向数据流中加入整数valint[][]getIntervals()以不相交区间[start,end的列表形式返回对数据流中整数的总结。0<=val<=10最多调用addNum和getIntervals方法3*10",1,3
292,124,2,55,题库,2,2,0,0,0,0,0,0,0,1,0,1,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个二维整数数组，其中，表示第个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。：不允许旋转信封。,"1<=envelopes.length<=10envelopes[i].length==21<=w,h<=10",1,4
293,68,1,471,题库,0,0,3,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近条推文。实现类：,"Twitter()初始化简易版推特对象voidpostTweet(intuserId,inttweetId)根据给定的tweetId和userId创建一条新推文。每次调用此函数都会使用一个不同的tweetIdList<Integer>getNewsFeed(intuserId)检索当前用户新闻推送中最近条推文的ID。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须按照时间顺序由最近到最远排序voidfollow(intfollowerId,intfolloweeId)ID为followerId的用户开始关注ID为followeeId的用户。voidunfollow(intfollowerId,intfolloweeId)ID为followerId的用户不再关注ID为followeeId的用户。1<=userId,followerId,followeeId<=5000<=tweetId<=10所有推特的ID都互不相同postTweetgetNewsFeedfollow和unfollow方法最多调用3*10",1,4
294,31,2,7,题库,0,2,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,"给你一个整数，统计并返回各位数字都不同的数字的个数，其中。
",0<=n<=8,1,3
295,81,2,79,题库,2,1,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的矩阵和一个整数，找出并返回矩阵内部矩形区域的不超过的最大数值和。题目数据保证总会存在一个数值和不超过的矩形区域。如果行数远大于列数，该如何设计解决方案？,"m==matrix.lengthn==matrix[i].length1<=m,n<=100-100<=matrix[i][j]<=100-10<=k<=10",1,5
296,78,3,86,题库,0,2,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有两个水壶，容量分别为和升。水的供应是无限的。确定是否有可能使用这两个壶准确得到升。如果可以得到升水，最后请用以上水壶中的一或两个来盛放取得的升水。你可以：,"装满任意一个水壶清空任意一个水壶从一个水壶向另外一个水壶倒水，直到装满或者倒空1<=jug1Capacity,jug2Capacity,targetCapacity<=10",1,3
297,82,2,11,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数。如果是一个完全平方数，则返回，否则返回。是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。不能使用任何内置的库函数，如。,1<=num<=2-1,1,2
298,70,2,96,题库,2,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个由正整数组成的集合，请你找出并返回其中最大的整除子集，子集中每一元素对都应当满足：
如果存在多个有效解子集，返回其中任何一个均可。",answer[i]%answer[j]==0，或answer[j]%answer[i]==01<=nums.length<=10001<=nums[i]<=2*10nums中的所有整数互不相同,1,4
299,31,2,16,题库,0,0,0,0,1,1,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和，运算符和​​​​​​​，计算并返回两整数之和。,"-1000<=a,b<=1000",1,2
300,38,4,41,题库,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你的任务是计算对取模，是一个正整数，是一个非常大的正整数且会以数组形式给出。,1<=a<=2-11<=b.length<=20000<=b[i]<=9不含前导0,1,2
301,58,3,85,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定两个以的整数数组和,以及一个整数。定义一对值，其中第一个元素来自，第二个元素来自。请找到和最小的个数对,...。","1<=nums1.length,nums2.length<=10-10<=nums1[i],nums2[i]<=10nums1和nums2均为升序排列1<=k<=1000",1,2
302,63,4,165,题库,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,猜数字游戏的规则如下：你可以通过调用一个预先定义好的接口来获取猜测结果，返回值一共有3种可能的情况（，或）：返回我选出的数字。,每轮游戏，我都会从到随机选择一个数字。请你猜选出的是哪个数字。如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。-1：我选出的数字比你猜的数字小pick<num1：我选出的数字比你猜的数字大pick>num0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick==num1<=n<=2-11<=pick<=n,1,2
303,41,3,9,题库,0,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们正在玩一个猜数游戏，游戏规则如下：给你一个特定的数字，返回能够的最小现金数，。,1<=n<=200,1,3
304,169,3,158,题库,1,2,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如，是一个，因为差值是正负交替出现的。可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组，返回中作为的。你能否用时间复杂度完成此题?,"例如，[1,7,4,9,2,5]是一个摆动序列，因为差值(6,-3,5,-7,3)是正负交替出现的。相反，[1,4,7,2,5]和[1,7,4,5,5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。1<=nums.length<=10000<=nums[i]<=1000",1,3
305,112,2,64,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由整数组成的数组，和一个目标整数。请你从中找出并返回总和为的元素组合的个数。题目数据保证答案符合32位整数范围。如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？,1<=nums.length<=2001<=nums[i]<=1000nums中的所有元素互不相同1<=target<=1000,1,2
306,77,2,195,题库,3,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个矩阵，其中每行和每列元素均按升序排序，找到矩阵中第小的元素。
请注意，它是的第小元素，而不是第个的元素。你必须找到一个内存复杂度优于的解决方案。",n==matrix.lengthn==matrix[i].length1<=n<=300-10<=matrix[i][j]<=10题目数据matrix中的所有行和列都按非递减顺序排列1<=k<=n你能否用一个恒定的内存(即O(1)内存复杂度)来解决这个问题?你能在O(n)的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（thispaper）很有趣。,1,5
307,31,1,282,题库,1,0,1,0,0,2,1,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,实现类：你必须实现类的所有函数，并满足每个函数的时间复杂度为。,RandomizedSet()初始化RandomizedSet对象boolinsert(intval)当元素val不存在时，向集合中插入该项，并返回true；否则，返回falseboolremove(intval)当元素val存在时，从集合中移除该项，并返回true；否则，返回falseintgetRandom()随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有相同的概率被返回。<=val<=2-1最多调用insertremove和getRandom函数2*在调用getRandom方法时，数据结构中至少存在一个元素。,1,5
308,93,1,332,题库,1,0,1,0,0,2,1,1,0,0,0,0,1,0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。实现类:您必须实现类的函数，使每个函数的时间复杂度为。生成测试用例时，只有在中时，才会调用。,RandomizedCollection()初始化空的RandomizedCollection对象。boolinsert(intval)将一个val项插入到集合中，即使该项已经存在。如果该项不存在，则返回true，否则返回falseboolremove(intval)如果存在，从集合中移除一个val项。如果该项存在，则返回true，否则返回false。注意，如果val在集合中出现多次，我们只删除其中一个。intgetRandom()从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量线性相关<=val<=2-1insertremove和getRandom最多被调用2*10当调用getRandom时，数据结构中至少有一个元素,1,5
309,39,1,172,题库,0,0,1,0,0,3,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点。实现类：,"Solution(ListNodehead)使用整数数组初始化对象。intgetRandom()从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。链表中的节点数在范围[1,10-10<=Node.val<=10至多调用getRandom方法如果链表非常大且长度未知，该怎么处理？你能否在不使用额外空间的情况下解决此问题？",1,4
310,52,3,68,题库,1,0,1,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串：和，判断能不能由里面的字符构成。如果可以，返回；否则返回。中的每个字符只能在中使用一次。,"1<=ransomNote.length,magazine.length<=10ransomNote和magazine由小写英文字母组成",1,3
311,52,1,155,题库,1,0,0,0,0,2,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是的。实现class:,Solution(int[]nums)使用整数数组nums初始化对象int[]reset()重设数组到它的初始状态并返回int[]shuffle()返回数组随机打乱后的结果1<=nums.length<=50-10<=nums[i]<=10nums中的所有元素都是唯一的最多可以调用次reset和shuffle,1,3
312,62,2,80,题库,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串s表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果。列表中的每个元素只可能是整数或整数嵌套列表,"1<=s.length<=5*10由数字、方括号""[]""、负号'-'、逗号','用例保证是可解析的NestedInteger输入中的所有值的范围是[-10,10",1,3
313,45,2,10,题库,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，按字典序返回范围内所有整数。你必须设计一个时间复杂度为且使用额外空间的算法。,1<=n<=5*10,1,2
314,21,3,22,题库,1,0,2,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个字符串，找到。如果不存在，则返回。,1<=s.length<=10只包含小写字母,1,4
315,289,4,77,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：这里将作为根目录中的唯一目录。包含两个子目录和。包含文件和子目录；包含子目录，该子目录下包含文件。在文本格式中，如下所示(⟶表示制表符)：如果是代码表示，上面的文件系统可以写为。和分别是换行符和制表符。文件系统中的每个文件和文件夹都有一个唯一的，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用连接。上面例子中，指向的是。每个目录名由字母、数字和/或空格组成，每个文件名遵循的格式，其中和由字母、数字和/或空格组成。给定一个以上述格式表示文件系统的字符串，返回文件系统中。如果系统中没有文件，返回。,1<=input.length<=10input可能包含小写或大写的英文字母，一个换行符'\n'，一个制表符'\t'，一个点'.'，一个空格''，和数字。,1,3
316,57,2,45,题库,2,0,1,0,1,0,0,1,0,0,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个字符串和，它们只包含小写字母。字符串由字符串随机重排，然后在随机位置添加一个字母。请找出在中被添加的字母。,0<=s.length<=1000t.length==s.length+1和只包含小写字母,1,4
317,49,2,121,题库,0,1,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,列表由在范围中的所有整数组成，并按严格递增排序。请你对应用下述算法：给你整数，返回最后剩下的数字。,从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。1<=n<=10,1,2
318,69,3,65,题库,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组，其中表示一个坐标轴平行的矩形。这个矩形的左下顶点是，右上顶点是。如果所有矩形一起精确覆盖了某个矩形区域，则返回；否则，返回。,"1<=rectangles.length<=2*10rectangles[i].length==4-10<=x,y,a,b<=10",1,2
319,170,2,48,题库,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定字符串和，判断是否为的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，是的一个子序列，而不是）。如果有大量输入的S，称作S1,S2,...,Sk其中k>=10亿，你需要依次检查它们是否为T的子序列。在这种情况下，你会怎样改变代码？特别感谢添加此问题并且创建所有测试用例。",0<=s.length<=1000<=t.length<=10^4两个字符串都只由小写字符组成。,1,3
320,118,2,35,题库,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个表示数据的整数数组，返回它是否为有效的编码。中的一个字符可能的长度为，遵循以下的规则：这是UTF-8编码的工作方式：表示二进制形式的一位，可以是或。输入是整数数组。只有每个整数的用来存储数据。这意味着每个整数只表示1字节的数据。,1<=data.length<=2*100<=data[i]<=255,1,2
321,147,4,62,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个经过编码的字符串，返回它解码后的字符串。编码规则为:，表示其中方括号内部的正好重复次。注意保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数，例如不会出现像或的输入。,"1<=s.length<=30由小写英文字母、数字和方括号'[]'组成保证是一个的输入。中所有整数的取值范围为[1,300]",1,3
322,72,2,33,题库,1,1,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串和一个整数，请你找出中的最长子串，要求该子串中的每一字符出现次数都不少于。返回这一子串的长度。如果不存在这样的子字符串，则返回0。,1<=s.length<=10仅由小写英文字母组成1<=k<=10,1,4
323,56,2,81,题库,1,1,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个长度为的整数数组。假设是数组顺时针旋转个位置后的数组，我们定义的为：返回。生成的测试用例让答案符合整数。,F(k)=0*arr[0]+1*arr[1]+...+(n-1)*arr[n-1]n==nums.length1<=n<=10-100<=nums[i]<=100,1,3
324,25,3,9,题库,0,3,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个正整数，你可以做如下操作：返回变为所需的。,1<=n<=2-1,1,4
325,54,1,171,题库,0,0,1,0,0,3,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个可能含有的整数数组，请你随机输出给定的目标数字的索引。你可以假设给定的数字一定存在于数组中。实现类：,Solution(int[]nums)用数组nums初始化对象。intpick(inttarget)从nums中选出一个满足nums[i]==target的随机索引。如果存在多个有效的索引，则每个索引的返回概率应当相等。1<=nums.length<=2*10<=nums[i]<=2-1target是nums中的一个整数最多调用pick函数,1,4
326,225,3,200,题库,1,2,2,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个变量对数组和一个实数值数组作为已知条件，其中和共同表示等式。每个或是一个表示单个变量的字符串。另有一些以数组表示的问题，其中表示第个问题，请你根据已知条件找出的结果作为答案。返回。如果存在某个无法确定的答案，则用替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用替代这个答案。输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。,"1<=equations.length<=20equations[i].length==21<=A.length,B.length<=5values.length==equations.length0.0<values[i]<=20.01<=queries.length<=20queries[i].length==21<=C.length,D.length<=5,B,C,D由小写英文字母与数字组成",1,6
327,30,2,9,题库,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你在无限的整数序列中找出并返回第位上的数字。,1<=n<=2-1,1,2
328,123,2,96,题库,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,二进制手表顶部有4个LED代表，底部的6个LED代表。每个LED代表一个0或1，最低位在右侧。给你一个整数，表示当前亮着的LED的数量，返回二进制手表可以表示的所有可能时间。你可以返回答案。小时不会以零开头：分钟必须由两位数组成，可能会以零开头：,"例如，下面的二进制手表读取""3:25""例如，""01:00""是无效的时间，正确的写法应该是""1:00""例如，""10:2""是无效的时间，正确的写法应该是""10:02""0<=turnedOn<=10",1,2
329,60,3,54,题库,1,1,2,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个以字符串表示的非负整数和一个整数，移除这个数中的位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。,1<=k<=num.length<=10num仅由若干位数字（0-9）组成除了本身之外，num不含任何前导零,1,4
330,232,2,64,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一只青蛙想要过河。假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。青蛙可以跳上石子，但是不可以跳入水中。给你石子的位置列表（用单元格序号表示），请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时，青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了个单位，那么它接下来的跳跃距离只能选择为、或个单位。另请注意，青蛙只能向前方（终点的方向）跳跃。,2<=stones.length<=20000<=stones[i]<=2-1stones[0]==0stones按严格升序排列,1,2
331,20,2,36,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定二叉树的根节点，返回所有左叶子之和。,"节点数在[1,1000]范围内-1000<=Node.val<=1000",1,4
332,41,2,0,题库,0,0,0,0,1,1,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用方法。,,1,2
333,124,2,61,题库,2,1,0,2,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,假设有打乱顺序的一群人站成一个队列，数组表示队列中一些人的属性（不一定按顺序）。每个表示第个人的身高为，前面有个身高大于或等于的人。请你重新构造并返回输入数组所表示的队列。返回的队列应该格式化为数组，其中是队列中第个人的属性（是排在队列前面的人）。,1<=people.length<=20000<=h<=100<=k<people.length题目数据确保队列可以被重建,1,5
334,53,2,76,题库,2,1,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。,"m==heightMap.lengthn==heightMap[i].length1<=m,n<=2000<=heightMap[i][j]<=2*10",1,4
335,48,3,32,题库,1,1,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给定一个包含大写字母和小写字母的字符串，返回。在构造过程中，请注意。比如不能当做一个回文字符串。,1<=s.length<=2000只由小写和/或大写英文字母组成,1,3
336,59,3,59,题库,1,3,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个非负整数数组和一个整数，你需要将这个数组分成个非空的连续子数组。设计一个算法使得这个子数组各自和的最大值最小。,"1<=nums.length<=10000<=nums[i]<=101<=m<=min(50,nums.length)",1,5
337,44,3,118,题库,2,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，找出从到各个整数的FizzBuzz表示，并用字符串数组（）返回结果，其中：,"answer[i]==""FizzBuzz""如果同时是和的倍数。answer[i]==""Fizz""如果是的倍数。answer[i]==""Buzz""如果是的倍数。answer[i]==i（以字符串形式）如果上述条件全不满足。1<=n<=10",1,3
338,70,2,83,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果一个数列，并且任意两个相邻元素之差相同，则称该数列为等差数列。给你一个整数数组，返回数组中所有为等差数组的个数。是数组中的一个连续序列。,"例如，[1,3,5,7,9][7,7,7,7]和[3,-1,-5,-9]都是等差数列。1<=nums.length<=5000-1000<=nums[i]<=1000",1,2
339,51,3,32,题库,2,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个非空数组，返回此数组中。如果不存在，则返回数组中最大的数。你能设计一个时间复杂度的解决方案吗？,1<=nums.length<=10<=nums[i]<=2-1,1,2
340,78,3,64,题库,2,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个字符串形式的非负整数和，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如），也不能直接将输入的字符串转换为整数形式。,"1<=num1.length,num2.length<=10num1num2都只包含数字0-9num1num2都不包含任何前导零",1,3
341,42,2,34,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的数组。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。,1<=nums.length<=2001<=nums[i]<=100,1,2
342,171,2,68,题库,2,2,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个的矩形岛屿，与和相邻。处于大陆的左边界和上边界，而处于大陆的右边界和下边界。这个岛被分割成一个由若干方形单元格组成的网格。给定一个的整数矩阵，表示坐标上单元格。岛上雨水较多，如果相邻单元格的高度当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。返回网格坐标的，其中表示雨水从单元格流动。,"m==heights.lengthn==heights[r].length1<=m,n<=2000<=heights[r][c]<=10",1,4
343,170,2,63,题库,2,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的矩阵表示甲板，其中，每个单元格可以是一艘战舰或者是一个空位，返回在甲板上放置的的数量。只能水平或者垂直放置在上。换句话说，战舰只能按（行，列）或（行，列）的形状建造，其中可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔（即没有相邻的战舰）。你可以实现一次扫描算法，并只使用额外空间，并且不修改的值来解决这个问题吗？,"m==board.lengthn==board[i].length1<=m,n<=200board[i][j]是'.'或'X'",1,3
344,40,3,181,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,满足以下条件的密码被认为是强密码：给你一个字符串，返回在一步修改操作中，你可以：,"由至少个，至多个字符组成。包含至少一个小写字母，至少一个大写字母，和至少一个数字不包含连续三个重复字符(比如aaabb0""是弱密码,但是是强密码)。插入一个字符到passwordpassword中删除一个字符，或用另一个字符来替换password中的某个字符。1<=password.length<=50password由字母、数字、点'.'或者感叹号'!'组成",1,3
345,22,2,35,题库,1,0,1,1,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，返回的最大运算结果，其中。,1<=nums.length<=2*100<=nums[i]<=2-1,1,4
346,43,2,102,题库,1,0,1,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，其中包含字母顺序打乱的用英文单词表示的若干数字（）。按返回原始的数字。,"1<=s.length<=10s[i]为[""e"",""g"",""f"",""i"",""h"",""o"",""n"",""s"",""r"",""u"",""t"",""w"",""v"",""x"",""z""]这些字符之一保证是一个符合题目要求的字符串",1,3
347,83,2,39,题库,1,0,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串和一个整数。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行次。在执行上述操作后，返回包含相同字母的最长子字符串的长度。,1<=s.length<=10仅由大写英文字母组成0<=k<=s.length,1,3
348,268,5,77,题库,2,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个矩阵，矩阵由若干和组成。请你用四叉树表示该矩阵。你需要返回能表示矩阵的四叉树的根结点。注意，当为时，你可以把或者赋值给节点，两种值都会被判题机制。四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：我们可以按以下步骤为二维区域构建四叉树：如果你想了解更多关于四叉树的内容，可以参考。输出为使用层序遍历后四叉树的序列化形式，其中表示路径终止符，其下面不存在节点。它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示。如果或者的值为True，则表示它在列表中的值为；如果或者的值为False，则表示值为。,val：储存叶子结点所代表的区域的值。1对应True，0对应FalseisLeaf:当这个节点是一个叶子结点时为True，如果它有4个子节点则为False,1,4
349,64,2,29,题库,0,1,1,0,0,0,0,0,0,0,1,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个N叉树，返回其节点值的。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由null值分隔（参见示例）。,"树的高度不会超过1000树的节点总数在[0,10^4]之间",1,2
350,259,4,26,题库,0,1,2,0,0,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的。给定链表的头节点，将链表，以便所有节点都出现在单层双链表中。让是一个带有子列表的节点。子列表中的节点应该出现在中的和。返回以为例：序列化其中的每一级之后：为了将每一级都序列化到一起，我们需要每一级中添加值为null的元素，以表示没有节点连接到上一级的上级节点。合并所有序列化结果，并去除末尾的null。,节点数目不超过10001<=Node.val<=10,1,3
351,59,1,334,题库,0,0,3,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。实现类：每个函数都应当满足平均时间复杂度。,AllOne()初始化数据结构的对象。inc(Stringkey)字符串key的计数增加。如果数据结构中尚不存在key，那么插入计数为的keydec(Stringkey)字符串key的计数减少。如果key的计数在减少后为，那么需要将这个key从数据结构中删除。测试用例保证：在减少计数前，key存在于数据结构中。getMaxKey()返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串getMinKey()返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串1<=key.length<=10key由小写英文字母组成测试用例保证：在每次调用dec时，数据结构中总存在key最多调用incdecgetMaxKey和getMinKey方法5*10,1,4
352,232,3,137,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,基因序列可以表示为一条由8个字符组成的字符串，其中每个字符都是、、和之一。假设我们需要调查从基因序列变为所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。另有一个基因库记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库中）给你两个基因序列和，以及一个基因库，请你找出并返回能够使变化为所需的最少变化次数。如果无法完成此基因变化，返回。注意：起始基因序列默认是有效的，但是它并不一定会出现在基因库中。,"例如，""AACCGGTT""-->""AACCGGTA""就是一次基因变化。start.length==8end.length==80<=bank.length<=10bank[i].length==8startend和bank[i]仅由字符['A','C','G','T']组成",1,3
353,57,1,0,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。请注意，你可以假定字符串里不包括任何不可打印的字符。,,1,1
354,16,3,67,题库,2,2,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个区间的集合，其中。返回。,1<=intervals.length<=10intervals[i].length==2-5*10<=start<end<=5*10,1,4
355,84,3,77,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个区间数组，其中，且每个都。区间的可以记作区间，并满足，且。注意可能等于。返回一个由每个区间的在中对应下标组成的数组。如果某个区间不存在对应的，则下标处的值设为。,1<=intervals.length<=2*10intervals[i].length==2-10<=start<=end<=10每个间隔的起点都不相同,1,3
356,83,2,59,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的根节点，和一个整数，求该二叉树里节点值之和等于的的数目。不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。,"二叉树的节点个数的范围是[0,1000]-10<=Node.val<=10-1000<=targetSum<=1000",1,3
357,68,2,34,题库,1,0,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和，找到中所有的的子串，返回这些子串的起始索引。不考虑答案输出的顺序。指由相同字母重排列形成的字符串（包括相同的字符串）。,"1<=s.length,p.length<=3*10和仅包含小写字母",1,3
358,18,2,11,题库,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定整数和，返回中字典序第小的数字。,1<=k<=n<=10,1,1
359,78,2,9,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你总共有枚硬币，并计划将它们按阶梯状排列。对于一个由行组成的阶梯，其第行必须正好有枚硬币。阶梯的最后一行是不完整的。给你一个数字，计算并返回可形成的总行数。,1<=n<=2-1,1,2
360,91,3,48,题库,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组，其中的所有整数都在范围内，且每个整数出现或。请你找出所有出现的整数，并以数组形式返回。你必须设计并实现一个时间复杂度为且仅使用常量额外空间的算法解决此问题。,n==nums.length1<=n<=101<=nums[i]<=nnums中的每个元素出现或,1,2
361,131,3,89,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符数组，请使用下述算法压缩：从一个空字符串开始。对于中的每组：压缩后得到的字符串，需要转储到字符数组中。需要注意的是，如果组长度为或以上，则在数组中会被拆分为多个字符。请在，返回该数组的新长度。你必须设计并实现一个只使用常量额外空间的算法来解决此问题。,如果这一组长度为，则将字符追加到中。否则，需要向追加字符，后跟这一组的长度。1<=chars.length<=2000chars[i]可以是小写英文字母、大写英文字母、数字或符号,1,2
362,103,3,46,题库,0,0,2,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字0之外，这两个数字都不会以零开头。如果输入链表不能翻转该如何解决？,"链表的长度范围为[1,100]0<=node.val<=9输入数据保证链表代表的数字无前导0",1,3
363,100,2,130,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，返回中所有的数目。如果一个序列中，并且任意两个相邻元素之差相同，则称该序列为等差序列。数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。题目数据保证答案是一个整数。,"例如，[1,3,5,7,9][7,7,7,7]和[3,-1,-5,-9]都是等差序列。再例如，[1,1,2,5,7]不是等差序列。例如，[2,5,10]是[1,2,1,,4,1,的一个子序列。1<=nums.length<=1000<=nums[i]<=2-1",1,2
364,57,3,64,题库,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定平面上对的点，其中。是由点表示的元组，其中和之间的距离和和之间的欧式距离相等（）。返回平面上所有回旋镖的数量。,"n==points.length1<=n<=500points[i].length==2-10<=x,y<=10所有点都互不相同",1,3
365,100,2,35,题库,1,0,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个含个整数的数组，其中在区间内。请你找出所有在范围内但没有出现在中的数字，并以数组的形式返回结果。你能在不使用额外空间且时间复杂度为的情况下解决这个问题吗?你可以假定返回的数组不算在额外空间内。,n==nums.length1<=n<=101<=nums[i]<=n,1,2
366,154,2,45,题库,1,2,3,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。设计一个算法来序列化和反序列化。对序列化/反序列化算法的工作方式没有限制。您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。,"树中节点数范围是[0,100<=Node.val<=10题目数据输入的树是一棵二叉搜索树。",1,7
367,109,3,58,题库,0,0,3,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉搜索树的根节点和一个值，删除二叉搜索树中的对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：要求算法时间复杂度为O(h)，h为树的高度。,"节点数的范围[0,10-10<=Node.val<=10节点值唯一root是合法的二叉搜索树-10<=key<=10",1,3
368,60,3,30,题库,3,0,2,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串，根据字符出现的对其进行。一个字符出现的是它出现在字符串中的次数。返回。如果有多个答案，返回其中任何一个。,1<=s.length<=5*10由大小写英文字母和数字组成,1,6
369,158,3,57,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一些球形气球贴在一堵用XY平面表示的墙面上。墙面上的气球记录在整数数组，其中表示水平直径在和之间的气球。你不知道气球的确切y坐标。一支弓箭可以沿着x轴从不同点地射出。在坐标处射出一支箭，若有一个气球的直径的开始和结束坐标为且满足则该气球会被可以射出的弓箭的数量。弓箭一旦被射出之后，可以无限地前进。给你一个数组，。,1<=points.length<=10points[i].length==2<=xstart<xend<=2-1,1,3
370,45,2,62,题库,1,0,0,0,0,1,0,1,0,0,1,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组，每次操作将会使个元素增加。返回让数组所有元素相等的最小操作次数。,n==nums.length1<=nums.length<=10-10<=nums[i]<=10答案保证符合32-bit整数,1,2
371,33,2,159,题库,1,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你四个整数数组、、和，数组长度都是，请你计算有多少个元组能满足：,"0<=i,j,k,l<nnums1[i]+nums2[j]+nums3[k]+nums4[l]==0n==nums1.lengthn==nums2.lengthn==nums3.lengthn==nums4.length1<=n<=200<=nums1[i],nums2[i],nums3[i],nums4[i]<=2",1,2
372,146,2,51,题库,2,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子，都有一个胃口值这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干，都有一个尺寸。如果，我们可以将这个饼干分配给孩子，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。,"1<=g.length<=3*100<=s.length<=3*101<=g[i],s[j]<=2-1",1,4
373,51,3,40,题库,1,1,3,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，数组中共有个整数。由三个整数、和组成，并同时满足：和。如果中存在，返回；否则，返回。,n==nums.length1<=n<=2*10-10<=nums[i]<=10,1,5
374,153,3,198,题库,1,0,1,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,存在一个不含的数组，每个都表示位于下标的角色应该向前或向后移动的下标个数：因为数组是的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。数组中的由长度为的下标序列标识：如果中存在循环，返回；否则，返回。你能设计一个时间复杂度为且额外空间复杂度为的算法吗？,如果nums[i]是正数，（下标递增方向）移动|nums[i]|如果nums[i]是负数，（下标递减方向）移动|nums[i]|遵循上述移动规则将导致一组重复下标序列seq[0]->seq[1]->...->seq[k-1]->seq[0]->...所有nums[seq[j]]应当不是就是k>11<=nums.length<=5000-1000<=nums[i]<=1000nums[i]!=0,1,3
375,113,3,51,题库,0,1,0,0,0,2,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有桶液体，其中含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有分钟时间来确定哪桶液体是有毒的。喂猪的规则如下：给你桶的数目，和，返回。,1<=buckets<=10001<=minutesToDie<=minutesToTest<=100,1,3
376,33,3,24,题库,2,0,0,0,0,0,0,0,0,1,0,1,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非空的字符串，检查是否可以通过由它的一个子串重复多次构成。,1<=s.length<=10由小写英文字母组成,1,2
377,141,1,277,题库,0,0,3,0,0,0,1,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,请你为缓存算法设计并实现数据结构。实现类：为了确定最不常使用的键，可以为缓存中的每个键维护一个。使用计数最小的键是最久未使用的键。当一个键首次插入到缓存中时，它的使用计数器被设置为(由于put操作)。对缓存中的键执行或操作，使用计数器的值将会递增。函数和必须以的平均时间复杂度运行。,"LFUCache(intcapacity)-用数据结构的容量capacity初始化对象intget(intkey)-如果键key存在于缓存中，则获取键的值，否则返回voidput(intkey,intvalue)-如果键key已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量capacity时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最近最久未使用的键。1<=capacity<=100<=key<=100<=value<=10最多调用2*10次get和put方法",1,4
378,53,2,11,题库,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,两个整数之间的指的是这两个数字对应二进制位不同的位置的数目。给你两个整数和，计算并返回它们之间的汉明距离。,"0<=x,y<=2-1",1,1
379,57,2,48,题库,2,0,0,0,0,1,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组，返回使所有数组元素相等需要的最小操作数。在一次操作中，你可以使数组中的一个元素加或者减。,n==nums.length1<=nums.length<=10-10<=nums[i]<=10,1,3
380,169,3,62,题库,2,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,EASY,给定一个的二维网格地图，其中：表示陆地，表示水域。网格中的格子方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖”指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为1的正方形。网格为长方形，且宽度和高度均不超过100。计算这个岛屿的周长。,"row==grid.lengthcol==grid[i].length1<=row,col<=100grid[i][j]为或",1,4
381,186,3,46,题库,0,2,0,0,2,2,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"在""100game""这个游戏中，两名玩家轮流选择从到的任意整数，累计整数和，先使得累计整数和100的玩家，即为胜者。如果我们将游戏规则改为“玩家重复使用整数”呢？例如，两个玩家可以轮流从公共整数池中抽取从1到15的整数（不放回），直到累计整数和>=100。给定两个整数（整数池中可选择的最大数）和（累计和），若先出手的玩家能稳赢则返回，否则返回。假设两位玩家游戏时都表现。",1<=maxChoosableInteger<=200<=desiredTotal<=300,1,6
382,98,2,127,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,定义表示由个字符串连接构成。如果可以从中删除某些字符使其变为，则称字符串可以从字符串获得。现在给你两个字符串和和两个整数和。由此构造得到两个字符串，其中、。请你找出一个最大整数，以满足可以从获得。,"例如，str==[""abc"",3]==""abcabcabc""例如，根据定义，s1=""abc""可以从s2=""abdbe获得，仅需要删除加粗且用斜体标识的字符。1<=s1.length,s2.length<=100和由小写英文字母组成1<=n1,n2<=10",1,2
383,52,3,90,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,定义字符串为一个无限环绕的字符串，所以看起来是这样的：给你一个字符串，请你统计并返回中有多少也在中出现。,"""...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....""1<=s.length<=10由小写英文字母组成",1,2
384,150,3,100,题库,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串。如果是有效的IPv4地址，返回；如果是有效的IPv6地址，返回；如果不是上述类型的IP地址，返回。是形式的IP地址。其中且前导零。例如:、为有效IPv4地址，为无效IPv4地址;、为无效IPv4地址。是一个格式为的IP地址，其中:例如和是有效的IPv6地址，而和是无效的IPv6地址。,1<=x.length<=4是一个十六进制字符串，可以包含数字、小写英文字母('a'到'f')和大写英文字母('A'到'F')。中允许前导零。queryIP仅由英文字母，数字，字符'.'和':'组成。,1,1
385,111,3,42,题库,0,0,0,0,0,4,0,0,0,1,1,0,0,1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定方法可生成范围内的均匀随机整数，试写一个方法生成范围内的均匀随机整数。你只能调用且不能调用其他方法。请不要使用系统的方法。每个测试用例将有一个内部参数，即你实现的函数在测试时将被调用的次数。请注意，这不是传递给的参数。,1<=n<=10rand7()调用次数的期望值是多少?你能否尽量少调用rand7(),1,4
386,68,2,103,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,HARD,给你一个单词的字符串数组，请你找出并返回中的所有。定义为：一个完全由给定数组中的至少两个较短单词（不一定是不同的两个单词）组成的字符串。,1<=words.length<=101<=words[i].length<=30words[i]仅由小写英文字母组成。words中的所有字符串都是的。1<=sum(words[i].length)<=10,1,5
387,85,2,46,题库,1,2,0,0,2,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你将得到一个整数数组，其中是第个火柴棒的长度。你要用拼成一个正方形。你任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须。如果你能使这个正方形，则返回，否则返回。,1<=matchsticks.length<=151<=matchsticks[i]<=10,1,5
388,64,2,70,题库,2,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二进制字符串数组和两个整数和。请你找出并返回的最大子集的长度，该子集中有个和个。如果的所有元素也是的元素，集合是集合的。,"1<=strs.length<=6001<=strs[i].length<=100strs[i]仅由'0'和'1'组成1<=m,n<=100",1,3
389,132,3,64,题库,2,1,0,0,1,0,0,0,1,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,冬季已经来临。你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。在加热器的加热半径范围内的每个房屋都可以获得供暖。现在，给出位于一条水平线上的房屋和供暖器的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。：所有供暖器都遵循你的半径标准，加热的半径也一样。,"1<=houses.length,heaters.length<=3*101<=houses[i],heaters[i]<=10",1,4
390,63,2,49,题库,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,对整数的二进制表示取反（变，变）后，再转换为十进制表示，可以得到这个整数的补数。给你一个整数，输出它的补数。本题与1009相同,"例如，整数的二进制表示是""101""，取反后得到""010""，再转回十进制表示得到补数1<=num<2",1,1
391,52,2,53,题库,1,0,0,0,1,1,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,两个整数的指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组，请你计算并返回中任意两个数之间。,1<=nums.length<=100<=nums[i]<=10给定输入的对应答案符合32-bit整数范围,1,3
392,33,1,197,题库,0,0,0,0,0,4,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定圆的半径和圆心的位置，实现函数，在圆中产生均匀随机点。实现类:,"Solution(doubleradius,doublex_center,doubley_center)用圆的半径radius和圆心的位置(x_center,y_center)初始化对象randPoint()返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回[x,y]0<radius<=10-10<=x_center,y_center<=10randPoint最多被调用3*10",1,4
393,28,2,7,题库,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个整数n，返回。因为答案可能非常大，所以返回它对。,1<=n<=8,1,1
394,167,1,90,题库,1,0,2,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。例如：给你一个数组，有一个长度为的窗口从最左端滑动到最右端。窗口中有个数，每次窗口向右移动位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。给出=，以及=3。因此，返回该滑动窗口的中位数数组。,"[2,3,4]，中位数是[2,3]，中位数是(2+3)/2=2.5你可以假设始终有效，即：始终小于等于输入的非空数组的元素个数。与真实值误差在10^-5以内的答案将被视作正确答案。",1,4
395,101,2,51,题库,1,0,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,神奇字符串仅由和组成，并需要遵守下面的规则：的前几个元素是。如果将中连续的若干和进行分组，可以得到。每组中或者的出现次数分别是。上面的出现次数正是自身。给你一个整数，返回在神奇字符串的前个数字中的数目。,神奇字符串s的神奇之处在于，串联字符串中'1'和'2'的连续出现次数可以生成该字符串。1<=n<=10,1,2
396,136,2,38,题库,1,0,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个许可密钥字符串，仅由字母、数字字符和破折号组成。字符串由个破折号分成组。你也会得到一个整数。我们想要重新格式化字符串，使每一组包含个字符，除了第一组，它可以比短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。返回。,1<=s.length<=10只包含字母、数字和破折号'-'1<=k<=10,1,1
397,42,3,16,题库,0,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"以字符串的形式给出,以字符串的形式返回。如果的进制数的所有数位全为1，则称是的一个。","的取值范围是[3,10没有前导0",1,2
398,22,2,29,题库,1,0,0,0,0,0,0,0,0,1,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个二进制数组，计算其中最大连续的个数。,1<=nums.length<=10nums[i]不是就是,1,1
399,218,2,32,题库,1,2,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。玩家1和玩家2基于这个数组设计了一个游戏。玩家1和玩家2轮流进行自己的回合，玩家1先手。开始时，两个玩家的初始分值都是。每一回合，玩家从数组的任意一端取一个数字（即，或），取到的数字将会从数组中移除（数组长度减）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。如果玩家1能成为赢家，返回。如果两个玩家得分相等，同样认为玩家1是游戏的赢家，也返回。你可以假设每个玩家的玩法都会使他的分数最大化。,1<=nums.length<=200<=nums[i]<=10,1,5
400,170,4,264,题库,1,3,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你正在参与祖玛游戏的一个变种。在这个祖玛游戏变体中，桌面上有彩球，每个球的颜色可能是：红色、黄色、蓝色、绿色或白色。你的手中也有一些彩球。你的目标是桌面上所有的球。每一回合：给你一个字符串，表示桌面上最开始的那排球。另给你一个字符串，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的球数。如果不能移除桌上所有的球，返回。,从你手上的彩球中选出任意一颗，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。接着，如果有出现三个或者三个以上且颜色相同如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。如果桌面上所有球都被移除，则认为你赢得本场游戏。重复这个过程，直到你赢了游戏或者手中没有更多的球。1<=board.length<=161<=hand.length<=5board和hand由字符'R''Y''B''G'和'W'组成桌面上一开始的球中，不会有三个及三个以上颜色相同且连着的球,1,5
401,84,2,36,题库,1,1,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，找出并返回所有该数组中不同的递增子序列，递增子序列中。你可以按返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。,1<=nums.length<=15-100<=nums[i]<=100,1,4
402,94,3,11,题库,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"作为一位web开发者，懂得怎样去规划一个页面的尺寸是很重要的。所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为L和宽度为W且满足以下要求的矩形的页面。要求：返回一个，其中。
",1<=area<=10,1,1
403,39,2,0,题库,1,3,1,2,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个数组，如果且我们就将称作一个。你需要返回给定数组中的重要翻转对的数量。,,1,7
404,74,2,125,题库,1,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个非负整数数组和一个整数。向数组中的每个整数前添加或，然后串联起所有整数，可以构造一个：返回可以通过上述方法构造的、运算结果等于的不同的数目。,"例如，nums=[2,1]，可以在之前添加'+'，在之前添加'-'，然后串联起来得到表达式""+2-1""1<=nums.length<=200<=nums[i]<=10000<=sum(nums[i])<=1000-1000<=target<=1000",1,3
405,211,2,71,题库,2,0,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在《英雄联盟》的世界中，有一个叫“提莫”的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。当提莫攻击艾希，艾希的中毒状态正好持续秒。正式地讲，提莫在发起攻击意味着艾希在时间区间（含和）处于中毒状态。如果提莫在中毒影响结束再次攻击，中毒状态计时器将会，在新的攻击之后，中毒影响将会在秒后结束。给你一个的整数数组，其中表示提莫在秒时对艾希发起攻击，以及一个表示中毒持续时间的整数。返回艾希处于中毒状态的秒数。,"1<=timeSeries.length<=100<=timeSeries[i],duration<=10timeSeries按非递减顺序排列",1,2
406,131,2,99,题库,1,0,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,中数字的是指在中对应位置的比大的元素。给你两个的数组和，下标从开始计数，其中是的子集。对于每个，找出满足的下标，并且在确定的。如果不存在下一个更大元素，那么本次查询的答案是。返回一个长度为的数组作为答案，满足是如上所述的。你可以设计一个时间复杂度为的解决方案吗？,"1<=nums1.length<=nums2.length<=10000<=nums1[i],nums2[i]<=10nums1nums2中所有整数互不相同nums1中的所有整数同样出现在nums2",1,4
407,147,1,179,题库,1,1,1,0,1,3,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个由非重叠的轴对齐矩形的数组，其中表示是第个矩形的左下角点，是第个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。在给定的矩形覆盖的空间内的任何整数点都有可能被返回。，整数点是具有整数坐标的点。实现类:,"Solution(int[][]rects)用给定的矩形数组rects初始化对象。int[]pick()返回一个随机的整数点[u,v]在给定的矩形所覆盖的空间内。1<=rects.length<=100rects[i].length==4-10<=a<x<=10-10<=b<y<=10-a<=2000-b<=2000所有的矩形不重叠。pick最多被调用次。",1,7
408,40,2,67,题库,3,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的矩阵，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。,"m==mat.lengthn==mat[i].length1<=m,n<=101<=m*n<=10-10<=mat[i][j]<=10",1,3
409,42,3,125,题库,2,0,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组，只返回可以使用在同一行的字母打印出来的单词。键盘如下图所示。中：,"第一行由字符""qwertyuiop""组成。第二行由字符""asdfghjkl""组成。第三行由字符""zxcvbnm""组成。1<=words.length<=201<=words[i].length<=100words[i]由英文字母（小写和大写字母）组成",1,3
410,117,2,90,题库,0,1,3,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个含重复值的二叉搜索树（BST）的根节点，找出并返回BST中的所有（即，出现频率最高的元素）。如果树中有不止一个众数，可以按返回。假定BST满足如下定义：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）,"结点左子树中所含节点的值小于等于当前节点的值结点右子树中所含节点的值大于等于当前节点的值左子树和右子树都是二叉搜索树树中节点的数目在范围[1,10-10<=Node.val<=10",1,4
411,249,2,92,题库,2,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,假设力扣（LeetCode）即将开始。为了以更高的价格将股票卖给风险投资公司，力扣希望在IPO之前开展一些项目以增加其资本。由于资源有限，它只能在IPO之前完成最多个不同的项目。帮助力扣设计完成最多个不同项目后得到最大总资本的方式。给你个项目。对于每个项目，它都有一个纯利润，和启动该项目需要的最小资本。最初，你的资本为。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。总而言之，从给定项目中选择个不同项目的列表，以，并输出最终可获得的最多资本。答案保证在32位有符号整数范围内。,1<=k<=100<=w<=10n==profits.lengthn==capital.length1<=n<=100<=profits[i]<=100<=capital[i]<=10,1,4
412,82,2,34,题库,1,0,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个循环数组（的下一个元素是），返回。数字的是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出。,1<=nums.length<=10-10<=nums[i]<=10,1,3
413,23,2,12,题库,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数，将其转化为，并以字符串形式输出。,-10<=num<=10,1,1
414,119,2,158,题库,2,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个长度为的整数数组，其中是第位运动员在比赛中的得分。所有得分都。运动员将根据得分，其中名次第的运动员得分最高，名次第的运动员得分第高，依此类推。运动员的名次决定了他们的获奖情况：使用长度为的数组返回获奖，其中是第位运动员的获奖情况。,"名次第的运动员获金牌""GoldMedal""名次第的运动员获银牌""SilverMedal""名次第的运动员获铜牌""BronzeMedal""从名次第到第的运动员，只能获得他们的名次编号（即，名次第的运动员获得编号""x""n==score.length1<=n<=100<=score[i]<=10score中的所有值互不相同",1,3
415,50,2,10,题库,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,对于一个，如果它和除了它自身以外的所有之和相等，我们称它为。给定一个，如果是完美数，返回；否则返回。,1<=num<=10,1,1
416,103,2,29,题库,0,1,3,0,0,0,0,1,0,0,0,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二叉树的根结点，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。一个结点的定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。,"节点数在[1,10范围内-10<=Node.val<=10",1,4
417,53,3,8,题库,0,3,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,（通常用表示）形成的序列称为。该数列由和开始，后面的每一项数字都是前面两项数字的和。也就是：给定，请计算。,0<=n<=30,1,4
418,23,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,活动表：查询每位玩家。查询结果的格式如下所示：,,1,1
419,36,2,32,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的，请找出该二叉树的节点的值。假设二叉树中至少有一个节点。,"二叉树的节点个数的范围是[1,10<=Node.val<=2-1",1,4
420,182,2,69,题库,1,3,0,0,0,0,0,1,1,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,电子游戏“辐射4”中，任务要求玩家到达名为“的金属表盘，并使用表盘拼写特定关键词才能开门。给定一个字符串，表示刻在外环上的编码；给定另一个字符串，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的步数。最初，的第一个字符与方向对齐。您需要顺时针或逆时针旋转以使的一个字符在方向对齐，然后按下中心按钮，以此逐个拼写完中的所有字符。旋转拼出key字符的阶段中：,"1<=ring.length,key.length<=100ring和key只包含小写英文字母字符串key一定可以由字符串ring旋转拼出",1,4
421,28,2,32,题库,0,2,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一棵二叉树的根节点，请找出该二叉树中每一层的最大值。,"二叉树的节点个数的范围是[0,10<=Node.val<=2-1",1,4
422,75,2,27,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。,1<=s.length<=1000仅由小写英文字母组成,1,2
423,165,3,44,题库,1,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,假设有台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。在每一步操作中，你可以选择任意()台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。给定一个整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的。如果不能使每台洗衣机中衣物的数量相等，则返回。,n==machines.length1<=n<=100<=machines[i]<=10,1,2
424,105,3,66,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组表示不同面额的硬币，另给一个整数表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回。假设每一种面额的硬币有无限个。题目数据保证结果符合32位带符号整数。,1<=coins.length<=3001<=coins[i]<=5000coins中的所有值互不相同0<=amount<=5000,1,2
425,98,1,170,题库,0,0,1,0,0,3,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的二元矩阵，且所有值被初始化为。请你设计一个算法，随机选取一个满足的下标，并将它的值变为。所有满足的下标被选取的概率应当均等。尽量最少调用内置的随机函数，并且优化时间和空间复杂度。实现类：,"Solution(intm,intn)使用二元矩阵的大小和初始化该对象int[]flip()返回一个满足matrix[i][j]==0的随机下标[i,j]，并将其对应格子中的值变为voidreset()将矩阵中所有的值重置为1<=m,n<=10每次调用flip时，矩阵中至少存在一个值为0的格子。最多调用1000次flip和reset方法。",1,4
426,50,2,107,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,我们定义，在以下情况时，单词的大写用法是正确的：给你一个字符串。如果大写用法正确，返回；否则，返回。,"全部字母都是大写，比如""USA""单词中所有字母都不是大写，比如""leetcode""如果单词不只含有一个字母，只有首字母大写，比如""Google""1<=word.length<=100word由小写和大写英文字母组成",1,1
427,66,3,113,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串和，请返回的长度。如果不存在，则返回。定义如下：该序列为。字符串的子序列是在从中删除任意数量的字符后可以获得的字符串。,"例如，""abc""是""aebdc""的子序列，因为删除中斜体加粗的字符可以得到""abc""。""aebdc""的子序列还包括""aebdc""、""aeb""和(空字符串)。1<=a.length,b.length<=100和由小写英文字母组成",1,1
428,64,2,132,题库,3,0,1,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给定字符串列表，返回其中的长度。如果最长特殊序列不存在，返回。定义如下：该序列为某字符串。的可以通过删去字符串中的某些字符实现。,"例如，""abc""是""aebdc""的子序列，因为您可以删除中的下划线字符来得到""abc""""aebdc""的子序列还包括""aebdc""""aeb""和(空字符串)。2<=strs.length<=501<=strs[i].length<=10strs[i]只包含小写英文字母",1,5
429,93,3,84,题库,1,0,1,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：如果存在，返回；否则，返回。如果存在一个整数，令整数符合，则称是的一个倍数。始终视为的一个倍数。,子数组大小至少为2，且子数组元素总和为的倍数。1<=nums.length<=100<=nums[i]<=100<=sum(nums[i])<=2-11<=k<=2-1,1,4
430,90,2,96,题库,3,0,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个字符串和一个字符串数组，找出并返回中最长的字符串，该字符串可以通过删除中的某些字符得到。如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。,1<=s.length<=10001<=dictionary.length<=10001<=dictionary[i].length<=1000和dictionary[i]仅由小写英文字母组成,1,4
431,40,2,29,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,"给定一个二进制数组,找到含有相同数量的和的最长连续子数组，并返回该子数组的长度。",1<=nums.length<=10nums[i]不是就是,1,3
432,60,2,32,题库,1,2,0,0,2,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,假设有从1到n的n个整数。用这些整数构造一个数组（），只要满足下述条件，该数组就是一个：给你一个整数，返回可以构造的的。,perm[i]能够被整除能够被perm[i]整除1<=n<=15,1,5
433,60,2,110,题库,1,1,0,0,1,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的正整数数组，其中代表第个下标的权重。请你实现一个函数，它可以从范围内（含和）选出并返回一个下标。选取下标的为。,"例如，对于w=[1,3]，挑选下标的概率为1/(1+3)=0.25（即，25%），而选取下标的概率为3/(1+3)=0.75（即，75%1<=w.length<=101<=w[i]<=10pickIndex将被调用不超过",1,5
434,105,2,249,题库,2,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,让我们一起来玩扫雷游戏！给你一个大小为二维字符矩阵，表示扫雷游戏的盘面，其中：给你一个整数数组，其中表示在所有方块（或者）中的下一个点击位置（是行下标，是列下标）。根据以下规则，返回相应位置被点击后对应的盘面：,"'M'代表一个未挖出的地雷，'E'代表一个未挖出的空方块，'B'代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，'1'到'8'）表示有多少地雷与这块已挖出的方块相邻，'X'则表示一个已挖出的地雷。m==board.lengthn==board[i].length1<=m,n<=50board[i][j]为'M''E''B'或数字'1'到'8'中的一个click.length==20<=click<m0<=click<nboard[click][click为'M'或'E'",1,4
435,47,2,30,题库,0,2,3,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二叉搜索树的根节点，返回。差值是一个正数，其数值等于两值之差的绝对值。本题与783相同,"树中节点的数目范围是[2,100<=Node.val<=10",1,5
436,70,3,82,题库,2,1,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你在数组中找出k-diff数对，并返回不同的的数目。数对定义为一个整数对，并满足下述全部条件：，表示的绝对值。,"0<=i,j<nums.lengthi!=jnums[i]-nums[j]==k1<=nums.length<=10-10<=nums[i]<=100<=k<=10",1,5
437,146,1,182,题库,1,0,1,0,1,0,1,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,TinyURL是一种URL简化服务，比如：当你输入一个URL时，它将返回一个简化的URL。请你设计一个类来加密与解密TinyURL。加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。实现类：,Solution()初始化TinyURL系统对象。Stringencode(StringlongUrl)返回longUrl对应的TinyURL。Stringdecode(StringshortUrl)返回shortUrl原本的URL。题目数据保证给定的shortUrl是由同一个系统对象加密的。1<=url.length<=10题目数据保证url是一个有效的URL,1,4
438,61,2,66,题库,2,0,0,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,可以用字符串表示，遵循的形式，并满足下述条件：给你两个字符串表示的复数和，请你遵循复数表示形式，返回表示它们乘积的字符串。,"是一个整数，取值范围是[-100,100]也是一个整数，取值范围是[-100,100]==-1num1和num2都是有效的复数表示。",1,3
439,100,4,100,题库,0,1,3,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给出二叉树的根节点，该树的节点值各不相同，请你将其转换为累加树（GreaterSumTree），使每个节点的新值等于原树中大于或等于的值之和。提醒一下，二叉搜索树满足下列约束条件：本题和1038:相同,节点的左子树仅包含键小于节点键的节点。节点的右子树仅包含键大于节点键的节点。左右子树也必须是二叉搜索树。树中的节点数介于和之间。每个节点的值介于-10和之间。树中的所有值互不相同给定的树为二叉搜索树。,1,4
440,47,2,49,题库,3,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个24小时制（小时:分钟）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。,"2<=timePoints.length<=2*10timePoints[i]格式为""HH:MM""",1,4
441,82,2,32,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。请你找出并返回只出现一次的那个数。你设计的解决方案必须满足时间复杂度和空间复杂度。,1<=nums.length<=100<=nums[i]<=10,1,2
442,43,2,85,题库,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个字符串和一个整数，从字符串开头算起，每计数至个字符，就反转这字符中的前个字符。,如果剩余字符少于个，则将剩余字符全部反转。如果剩余字符小于但大于或等于个，则反转前个字符，其余字符保持原样。1<=s.length<=10仅由小写英文组成1<=k<=10,1,2
443,60,2,80,题库,2,2,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个由和组成的矩阵，请输出一个大小相同的矩阵，其中每一个格子是中对应位置元素到最近的的距离。两个相邻元素间的距离为。,"m==mat.lengthn==mat[i].length1<=m,n<=101<=m*n<=10mat[i][j]iseither0or1.mat中至少有一个",1,4
444,76,2,33,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一棵二叉树的根节点，返回该树的。二叉树的是指树中任意两个节点之间最长路径的。这条路径可能经过也可能不经过根节点。两节点之间路径的由它们之间边数表示。,"树中节点数目在范围[1,10-100<=Node.val<=100",1,3
445,94,3,36,题库,1,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给出一些不同颜色的盒子，盒子的颜色由不同的正数表示。你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续个盒子（），这样一轮之后你将得到个积分。返回。,1<=boxes.length<=1001<=boxes[i]<=100,1,3
446,131,2,129,题库,0,2,1,1,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,有个城市，其中一些彼此相连，另一些没有相连。如果城市与城市直接相连，且城市与城市直接相连，那么城市与城市间接相连。是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个的矩阵，其中表示第个城市和第个城市直接相连，而表示二者不直接相连。返回矩阵中的数量。,1<=n<=200n==isConnected.lengthn==isConnected[i].lengthisConnected[i][j]为或isConnected[i][i]==1isConnected[i][j]==isConnected[j][i],1,4
447,104,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Table:编写一个SQL查询，报告在首次登录的第二天再次登录的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。查询结果格式如下所示：,,1,1
448,107,2,110,题库,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：如果学生能够满足下面两个条件，则可以获得出勤奖励：如果学生可以获得出勤奖励，返回；否则，返回。,'A'：Absent，缺勤'L'：Late，迟到'P'：Present，到场总出勤计，学生缺勤（'A'少于两天。学生存在3天或3天以上的迟到（'L'）记录。1<=s.length<=1000s[i]为'A''L'或'P',1,1
449,148,3,86,题库,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
如果学生能够满足下面两个条件，则可以获得出勤奖励：给你一个整数，表示出勤记录的长度（次数）。请你返回记录长度为时，可能获得出勤奖励的记录情况。答案可能很大，所以返回对的结果。",'A'：Absent，缺勤'L'：Late，迟到'P'：Present，到场总出勤计，学生缺勤（'A'少于两天。学生存在3天或3天以上的迟到（'L'）记录。1<=n<=10,1,1
450,135,2,82,题库,1,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一正整数数组中的相邻整数将进行浮点除法。例如，[2,3,4]->2/3/4。但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，以便计算后的表达式的值为最大值。以字符串格式返回具有最大值的对应表达式。你的表达式不应该包含多余的括号。","例如，nums=[2,3,4]，我们将求表达式的值""2/3/4""1<=nums.length<=102<=nums[i]<=1000对于给定的输入只有一种最优除法。",1,3
451,167,2,110,题库,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你的面前有一堵矩形的、由行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。你现在要画一条的、穿过砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。给你一个二维数组，该数组包含这堵墙的相关信息。其中，是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线，并且返回。,n==wall.length1<=n<=101<=wall[i].length<=101<=sum(wall[i].length)<=2*10对于每一行sum(wall[i])是相同的1<=wall[i][j]<=2-1,1,2
452,95,2,9,题库,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数，请你找出符合条件的最小整数，其由重新排列中存在的每位数字组成，并且其值大于。如果不存在这样的正整数，则返回。，返回的整数应当是一个，如果存在满足题意的答案，但不是，同样返回。,1<=n<=2-1,1,3
453,43,2,65,题库,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。,1<=s.length<=5*10包含可打印的ASCII字符。不包含任何开头或结尾空格。里有一个词。中的所有单词都用一个空格隔开。,1,2
454,309,5,139,题库,0,1,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,二进制矩阵中的所有元素不是就是。给你两个四叉树，和。其中表示一个二进制矩阵，而表示另一个二进制矩阵。请你返回一个表示二进制矩阵的四叉树，它是和所表示的两个二进制矩阵进行的结果。注意，当为时，你可以把或者赋值给节点，两种值都会被判题机制。四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：我们可以按以下步骤为二维区域构建四叉树：如果你想了解更多关于四叉树的内容，可以参考。输出为使用层序遍历后四叉树的序列化形式，其中表示路径终止符，其下面不存在节点。它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示。如果或者的值为True，则表示它在列表中的值为；如果或者的值为False，则表示值为。,val：储存叶子结点所代表的区域的值。1对应True，0对应FalseisLeaf:当这个节点是一个叶子结点时为True，如果它有4个子节点则为FalsequadTree1和quadTree2都是符合题目要求的四叉树，每个都代表一个n*n的矩阵。n==2^x，其中0<=x<=9,1,2
455,79,2,28,题库,0,2,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给定一个N叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。N叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。,"树的深度不会超过1000树的节点数目位于[0,10之间。",1,3
456,22,2,50,题库,1,0,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你统计并返回。,1<=nums.length<=2*10-1000<=nums[i]<=1000-10<=k<=10,1,3
457,41,2,40,题库,3,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定长度为的整数数组，你的任务是将这些数分成对,例如，使得从到的总和最大。返回该。",1<=n<=10nums.length==2*n-10<=nums[i]<=10,1,4
458,109,3,36,题库,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二叉树的根节点，计算并返回的坡度。一个树的定义即为，该节点左子树的节点之和和右子树节点之和的。如果没有左子树的话，左子树的节点之和为0；没有右子树的话也是一样。空结点的坡度是0。的坡度就是其所有节点的坡度之和。,"树中节点数目的范围在[0,10-1000<=Node.val<=1000",1,3
459,62,2,43,题库,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个表示整数的字符串，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。“最近的”定义为两个整数最小。,"1<=n.length<=18只由数字组成不含前导0代表在[1,10-1]范围内的整数",1,2
460,96,1,50,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,索引从开始长度为的数组，包含到的所有整数。找到最大的集合并返回其大小，其中且遵守以下的规则。假设选择索引为的元素为的第一个元素，的下一个元素应该是，之后是以此类推，不断添加直到出现重复的元素。,1<=nums.length<=100<=nums[i]<nums.length中不含有重复的元素。,1,2
461,161,2,73,题库,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在MATLAB中，有一个非常有用的函数，它可以将一个矩阵重塑为另一个大小不同（）的新矩阵，但保留其原始数据。给你一个由二维数组表示的矩阵，以及两个正整数和，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的填充。如果具有给定参数的操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。,"m==mat.lengthn==mat[i].length1<=m,n<=100-1000<=mat[i][j]<=10001<=r,c<=300",1,3
462,51,2,34,题库,1,0,1,0,2,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串和，写一个函数来判断是否包含的排列。如果是，返回；否则，返回。换句话说，的排列之一是的。,"1<=s1.length,s2.length<=10和仅包含小写字母",1,4
463,26,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表:查询的经理。以返回结果表。查询结果格式如下所示。,,1,1
464,87,2,84,题库,1,1,2,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两棵二叉树和。检验中是否包含和具有相同结构和节点值的子树。如果存在，返回；否则，返回。二叉树的一棵子树包括的某个节点和这个节点的所有后代节点。也可以看做它自身的一棵子树。,"root树上的节点数量范围是[1,2000]subRoot树上的节点数量范围是[1,1000]-10<=root.val<=10-10<=subRoot.val<=10",1,5
465,146,3,53,题库,1,0,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,Alice有枚糖，其中第枚糖的类型为。Alice注意到她的体重正在增长，所以前去拜访了一位医生。医生建议Alice要少摄入糖分，只吃掉她所有糖的即可（是一个偶数）。Alice非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。给你一个长度为的整数数组，返回：Alice。,n==candyType.length2<=n<=10是一个偶数-10<=candyType[i]<=10,1,2
466,117,2,53,题库,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的网格和一个球。球的起始坐标为。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你可以移动次球。给你五个整数、、、以及，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对后的结果。,"1<=m,n<=500<=maxMove<=500<=startRow<m0<=startColumn<n",1,1
467,39,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,选出所有bonus<1000的员工的name及其bonus。表单表单输出示例：,,1,1
468,88,3,34,题库,2,1,2,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，你需要找出一个，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的子数组，并输出它的长度。你可以设计一个时间复杂度为的解决方案吗？,1<=nums.length<=10-10<=nums[i]<=10,1,6
469,35,2,53,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个单词和，返回使得和所需的。可以删除任意一个字符串中的一个字符。,"1<=word1.length,word2.length<=500word1和word2只包含小写英文字母",1,2
470,32,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表:找出那些的客户的客户的姓名。以返回结果表。结果格式如下所示。,,1,1
471,61,1,93,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,表：请你编写一个SQL查询，报告2016年()所有满足下述条件的投保人的投保金额之和：四舍五入的。查询结果格式如下例所示。,"他在2015年的投保额(tiv_2015)至少跟一个其他投保人在2015年的投保额相同。他所在的城市必须与其他投保人都不同（也就是说(lat,lon)不能跟其他任何一个投保人完全相同）。",1,1
472,71,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,EASY,表:查找下了的客户的。测试用例生成后，比任何其他客户下了更多的订单。查询结果格式如下所示。如果有多位顾客订单数并列最多，你能找到他们所有的吗？,,1,1
473,73,2,62,题库,1,0,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个数组，其中表示树在花园中的位置。你被要求用最短长度的绳子把整个花园围起来，因为绳子很贵。只有把，花园才围得很好。返回。所有给定的点都是的。,"1<=points.length<=3000points[i].length==20<=x,y<=100所有给定的点都是唯一",1,3
474,76,2,42,题库,0,1,2,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定一个n叉树的根节点，返回。n叉树在输入中按层序遍历进行序列化表示，每组子节点由空值分隔（请参见示例）。
递归法很简单，你可以使用迭代法完成此题吗?","节点总数在范围[0,100<=Node.val<=10n叉树的高度小于或等于1000",1,3
475,74,2,42,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个n叉树的根节点，返回。n叉树在输入中按层序遍历进行序列化表示，每组子节点由空值分隔（请参见示例）。递归法很简单，你可以使用迭代法完成此题吗?,"节点总数在范围[0,100<=Node.val<=10n叉树的高度小于或等于1000",1,3
476,61,1,0,题库,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：,,1,2
477,101,3,179,题库,2,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个表示分数加减运算的字符串，你需要返回一个字符串形式的计算结果。这个结果应该是不可约分的分数，即。如果最终结果是一个整数，例如，你需要将它转换成分数形式，其分母为。所以在上述例子中,应该被转换为。","输入和输出字符串只包含'0'到'9'的数字，以及'/''+'和'-'输入和输出分数格式均为±分子/分母。如果输入的第一个分数或者输出的分数是正数，则'+'会被省略掉。输入只包含合法的最简分数，每个分数的的范围是[1,10]。如果分母是1，意味着这个分数实际上是一个整数。输入的分数个数范围是[1,10]。最终结果的分子与分母保证是32位整数范围内的有效整数。",1,3
478,63,3,57,题库,0,0,0,0,0,2,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定2D空间中四个点的坐标,,和，如果这四个点构成一个正方形，则返回。点的坐标表示为。。一个有四条等边和四个等角(90度角)。","p1.length==p2.length==p3.length==p4.length==2-10<=x,y<=10",1,2
479,118,3,36,题库,2,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,和谐数组是指一个数组里元素的最大值和最小值之间的差别。现在，给你一个整数数组，请你在所有可能的子序列中找到最长的和谐子序列的长度。数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。,1<=nums.length<=2*10-10<=nums[i]<=10,1,3
480,65,1,49,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表：如果一个国家满足下述两个条件之一，则认为该国是：编写解决方案找出的国家名称、人口和面积。按返回结果表。返回结果格式如下例所示。,面积至少为300万平方公里（即，3000000km），或者人口至少为2500万（即25000000,1,1
481,28,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表:查询的所有班级。以返回结果表。查询结果格式如下所示。,,1,1
482,48,3,59,题库,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的矩阵，初始化时所有的和一个操作数组，其中意味着当所有的和时，应该加1。在，计算并返回。,"1<=m,n<=4*100<=ops.length<=10ops[i].length==21<=a<=m1<=b<=n",1,2
483,106,2,133,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。你需要帮助他们用找出他们。如果答案不止一个，则输出所有答案并且不考虑顺序。你可以假设答案总是存在。,"1<=list1.length,list2.length<=10001<=list1[i].length,list2[i].length<=30list1[i]和list2[i]由空格''和英文字母组成。list1的所有字符串都是的。list2中的所有字符串都是的。",1,3
484,39,3,8,题库,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给定一个正整数，请你统计在范围的非负整数中，有多少个整数的二进制表示中不存在。,1<=n<=10,1,1
485,58,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,"表：
编写一个SQL查询以找出每行的人数大于或等于且连续的三行或更多行记录。返回按的结果表。查询结果格式如下所示。",,1,1
486,153,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在Facebook或者Twitter这样的社交应用中，人们经常会发好友申请也会收到其他人的好友申请。表：写一个查询语句，找出拥有最多的好友的人和他拥有的好友数目。生成的测试用例保证拥有最多好友数目的只有1个人。查询结果格式如下例所示。在真实世界里，可能会有多个人拥有好友数相同且最多，你能找到所有这些人吗？,,1,1
487,132,2,80,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给你一个整数数组表示花坛，由若干和组成，其中表示没种植花，表示种植了花。另有一个数，能否在不打破种植规则的情况下种入朵花？能则返回，不能则返回。,1<=flowerbed.length<=2*10flowerbed[i]为或flowerbed中不存在相邻的两朵花0<=n<=flowerbed.length,1,2
488,105,2,36,题库,1,1,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,给你二叉树的根节点，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。空节点使用一对空括号对表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。,"树中节点的数目范围是[1,10-1000<=Node.val<=1000",1,4
489,52,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表:表:表:查询没有任何与名为的公司相关的订单的所有销售人员的姓名。以返回结果表。查询结果格式如下所示。,,1,1
490,106,1,178,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个表，是树节点的编号，是它父节点的树中每个节点属于以下三种类型之一：写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为：如果树中只有一个节点，你只需要输出它的根属性。,"叶子：如果这个节点没有任何孩子节点。根：如果这个节点是整棵树的根，即没有父节点。内部节点：如果这个节点既不是叶子节点也不是根节点。节点'1'是根节点，因为它的父节点是NULL，同时它有孩子节点'2'和'3'。节点'2'是内部节点，因为它有父节点'1'，也有孩子节点'4'和'5'。节点'3','4'和'5'都是叶子节点，因为它们都有父节点同时没有孩子节点。",1,1
491,203,2,434,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个目录信息列表，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按返回。一组重复的文件至少包括具有完全相同内容的文件。列表中的单个目录信息字符串的格式如下：这意味着，在目录下，有个文件(,...)的内容分别是(,...)。注意：且。如果，则表示该目录是根目录。是由构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：","""root/d1/d2/.../dmf1.txt(f1_content)f2.txt(f2_content)...fn.txt(fn_content)""""directory_path/file_name.txt""1<=paths.length<=2*101<=paths[i].length<=30001<=sum(paths[i].length)<=5*10paths[i]由英文字母、数字、字符'/''.''('')'和''组成你可以假设在同一目录中没有任何文件或目录共享相同的名称。你可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用单个空格分隔。假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？如果文件内容非常大（GB级别），您将如何修改您的解决方案？如果每次只能读取1kb的文件，您将如何修改解决方案？修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？如何确保您发现的重复文件不是误报？",1,3
492,42,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表:对每三个线段报告它们是否可以形成一个三角形。以返回结果表。查询结果格式如下所示。,,1,1
493,35,2,36,题库,2,2,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个包含非负整数的数组，返回其中可以组成三角形三条边的三元组个数。,1<=nums.length<=10000<=nums[i]<=1000,1,5
494,161,2,37,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,给你两棵二叉树：和。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，null的节点将直接作为新二叉树的节点。返回合并后的二叉树。合并过程必须从两个树的根节点开始。,"两棵树中的节点数目在范围[0,2000]-10<=Node.val<=10",1,4
495,41,2,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表：是在表中只出现一次的数字。找出最大的。如果不存在，则返回。查询结果如下例所示。,,1,1
496,148,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个LED显示板做电影推荐，上面公布着影评和相关电影描述。作为该电影院的信息部主管，您需要编写一个SQL查询，找出所有影片描述为(不无聊)的并且的影片，结果请按等级排列。例如，下表:对于上面的例子，则正确的输出是为：,,1,1
497,180,3,46,题库,2,1,2,0,1,0,0,1,0,0,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个用字符数组表示的CPU需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在1个单位时间内执行完。在任何一个单位时间，CPU可以完成一个任务，或者处于待命状态。然而，两个的任务之间必须有长度为整数的冷却时间，因此至少有连续个单位时间内CPU在执行不同的任务，或者在待命状态。你需要计算完成所有任务所需要的。,"1<=task.length<=10tasks[i]是大写英文字母的取值范围为[0,100]",1,6
498,186,1,240,题库,1,0,2,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计你的循环队列实现。循环队列是一种线性数据结构，其操作表现基于FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。你的实现应该支持如下操作：,MyCircularQueue(k):构造器，设置队列长度为k。Front:从队首获取元素。如果队列为空，返回-1。Rear:获取队尾元素。如果队列为空，返回-1。enQueue(value):向循环队列插入一个元素。如果成功插入则返回真。deQueue():从循环队列中删除一个元素。如果成功删除则返回真。isEmpty():检查循环队列是否为空。isFull():检查循环队列是否已满。所有的值都在0至1000的范围内；操作数将在1至1000的范围内；请不要使用内置的队列库。,1,4
499,52,2,256,题库,0,2,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的根和两个整数和，在给定的深度处添加一个值为的节点行。注意，根节点位于深度。加法规则如下:,"给定整数depth，对于深度为depth-1的每个非空树节点cur，创建两个值为val的树节点作为cur的左子树根和右子树根。cur原来的左子树应该是新的左子树根的左子树。cur原来的右子树应该是新的右子树根的右子树。如果depth==1意味着depth-1根本没有深度，那么创建一个树节点，值val作为整个原始树的新根，而原始树就是新根的左子树。节点数在[1,10范围内树的深度在[1,10范围内-100<=Node.val<=100-10<=val<=101<=depth<=thedepthoftree+1",1,4
500,67,1,0,题库,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,表:编写解决方案来交换每两个连续的学生的座位号。如果学生的数量是奇数，则最后一个学生的id不交换。按返回结果表。查询结果格式如下所示。,,1,1
501,91,1,0,题库,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：请你编写一个SQL查询来交换所有的和（即，将所有变为，反之亦然），仅使用，且不产生中间临时表。注意，你必须仅使用一条update语句，且使用select语句。查询结果如下例所示。,,1,1
502,35,3,38,题库,2,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。,3<=nums.length<=10-1000<=nums[i]<=1000,1,3
503,99,2,20,题库,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,逆序对的定义如下：对于数组的第个和第个元素，如果满足且，则其为一个逆序对；否则不是。给你两个整数和，找出所有包含从到的数字，且恰好拥有个的不同的数组的个数。由于答案可能很大，只需要返回对取余的结果。,1<=n<=10000<=k<=1000,1,1
504,95,3,44,题库,2,1,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,这里有门不同的在线课程，按从到编号。给你一个数组，其中表示第门课将会上天课，并且必须在不晚于的时候完成。你的学期从第天开始。且不能同时修读两门及两门以上的课程。返回你最多可以修读的课程数目。,"1<=courses.length<=101<=duration,lastDay<=10",1,4
505,56,2,79,题库,2,1,2,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有个的整数列表。找到一个区间，使得个列表中的每个列表至少有一个数包含在其中。我们定义如果或者在时，则区间比小。,nums.length==k1<=k<=35001<=nums[i].length<=50-10<=nums[i][j]<=10nums[i]按非递减顺序排列,1,6
506,26,2,9,题库,0,1,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个非负整数，你要判断是否存在两个整数和，使得。,0<=c<=2-1,1,3
507,377,5,119,题库,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个CPU正在运行一个含有道函数的程序。每道函数都有一个位于和之间的唯一标识符。函数调用：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。给你一个由日志组成的列表，其中表示第条日志消息，该消息是一个按进行格式化的字符串。例如，意味着标识符为的函数调用在时间戳的；而意味着标识符为的函数调用在时间戳的。注意，函数可以。函数的定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行单位时间，另一次调用执行单位时间，那么该函数的为。以数组形式返回每个函数的，其中第个下标对应的值表示标识符的函数的独占时间。,"1<=n<=1001<=logs.length<=5000<=function_id<n0<=timestamp<=10两个开始事件不会在同一时间戳发生两个结束事件不会在同一时间戳发生每道函数都有一个对应""start""日志的""end""日志",1,2
508,50,2,30,题库,0,2,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,EASY,"给定一个非空二叉树的根节点,以数组的形式返回每一层节点的平均值。与实际答案相差以内的答案可以被接受。","树中节点数量在[1,10范围内<=Node.val<=2-1",1,4
509,260,2,131,题库,1,3,0,0,2,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在LeetCode商店中，有件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。给你一个整数数组表示物品价格，其中是第件物品的价格。另有一个整数数组表示购物清单，其中是需要购买第件物品的数量。还有一个数组表示大礼包，的长度为，其中表示第个大礼包中内含第件物品的数量，且（也就是数组中的最后一个整数）为第个大礼包的价格。返回满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。,n==price.lengthn==needs.length1<=n<=60<=price[i]<=100<=needs[i]<=101<=special.length<=100special[i].length==n+10<=special[i][j]<=50,1,6
510,249,3,68,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一条包含字母的消息通过以下的方式进行了：要一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，可以映射为：注意，像这样的分组是无效的，因为不可以映射为，因为与不同。上面描述的数字字母映射方案，编码消息中可能包含字符，可以表示从到的任一数字（不包括）。例如，编码字符串可以表示、、、、、、、或中的任意一条消息。对进行解码，相当于解码该字符串可以表示的任何编码消息。给你一个字符串，由数字和字符组成，返回该字符串的方法。由于答案数目可能非常大，返回的。,"""AAJF""对应分组(11106)""KJF""对应分组(11106)1<=s.length<=10s[i]是0-9中的一位数字或字符'*'",1,2
511,99,3,78,题库,2,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,求解一个给定的方程，将以字符串的形式返回。该方程仅包含，操作，变量和其对应系数。如果方程没有解或存在的解不为整数，请返回。如果方程有无限解，则返回。题目保证，如果方程中只有一个解，则的值是一个整数。,"3<=equation.length<=1000equation只有一个'='方程由绝对值在[0,100]范围内且无任何前导零的整数和变量'x'组成。​​​",1,3
512,13,1,529,题库,1,0,2,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计实现双端队列。实现类:,"MyCircularDeque(intk)：构造函数,双端队列最大为booleaninsertFront()：将一个元素添加到双端队列头部。如果操作成功返回true，否则返回falsebooleaninsertLast()：将一个元素添加到双端队列尾部。如果操作成功返回true，否则返回falsebooleandeleteFront()：从双端队列头部删除一个元素。如果操作成功返回true，否则返回falsebooleandeleteLast()：从双端队列尾部删除一个元素。如果操作成功返回true，否则返回falseintgetFront())：从双端队列头部获得一个元素。如果双端队列为空，返回intgetRear()：获得双端队列的最后一个元素。如果双端队列为空，返回booleanisEmpty()：若双端队列为空，则返回true，否则返回false。booleanisFull()：若双端队列满了，则返回true，否则返回false1<=k<=10000<=value<=1000insertFrontinsertLastdeleteFrontdeleteLastgetFrontgetRearisEmptyisFull调用次数不大于2000",1,4
513,67,2,41,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由个元素组成的整数数组和一个整数。请你找出平均数最大且的连续子数组，并输出该最大平均数。任何误差小于的答案都将被视为正确答案。,n==nums.length1<=k<=n<=10-10<=nums[i]<=10,1,2
514,112,2,32,题库,2,0,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,集合包含从到的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合并且。给定一个数组代表了集合发生错误后的结果。请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。,2<=nums.length<=101<=nums[i]<=10,1,4
515,102,2,48,题库,2,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由个数对组成的数对数组，其中且现在，我们定义一种关系，当且仅当时，数对才可以跟在后面。我们用这种形式来构造。找出并返回能够形成的。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。,n==pairs.length1<=n<=1000-1000<=left<right<=1000,1,4
516,100,2,26,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你统计并返回这个字符串中的数目。是正着读和倒过来读一样的字符串。是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。,1<=s.length<=1000由小写英文字母组成,1,2
517,174,2,215,题库,2,0,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在英语中，我们有一个叫做(root)的概念，可以词根添加其他一些词组成另一个较长的单词——我们称这个词为(successor)。例如，词根，跟随着单词(其他)，可以形成新的单词(另一个)。现在，给定一个由许多组成的词典和一个用空格分隔单词形成的句子。你需要将句子中的所有用替换掉。如果有许多可以形成它的，则用的词根替换它。你需要输出替换之后的句子。,"1<=dictionary.length<=10001<=dictionary[i].length<=100dictionary[i]仅由小写字母组成。1<=sentence.length<=10^6sentence仅由小写字母和空格组成。sentence中单词的总量在范围[1,1000]内。sentence中每个单词的长度在范围[1,1000]内。sentence中单词之间由一个空格隔开。sentence没有前导或尾随空格。",1,4
518,301,2,132,题库,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Dota2的世界里有两个阵营：（天辉）和（夜魇）Dota2参议院由来自两派的参议员组成。现在参议院希望对一个Dota2游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的项：给你一个字符串代表每个参议员的阵营。字母和分别代表了（天辉）和（夜魇）。然后，如果有个参议员，给定字符串的大小将是。以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在Dota2游戏中决定改变。输出应该是或。,禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利宣布胜利：如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。n==senate.length1<=n<=10senate[i]为'R'或'D',1,3
519,76,2,71,题库,0,1,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,最初记事本上只有一个字符。你每次可以对这个记事本进行两种操作：给你一个数字，你需要使用最少的操作次数，在记事本上输出个。返回能够打印出个的最少操作次数。,CopyAll（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。Paste（粘贴）：粘贴上一次复制的字符。1<=n<=1000,1,2
520,62,3,38,题库,0,1,3,0,0,0,0,0,1,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，返回所有。对于同一类的重复子树，你只需要返回其中任意的根结点即可。如果两棵树具有和，则认为二者是的。,"树中的结点数在[1,5000]范围内。-200<=Node.val<=200",1,4
521,50,2,67,题库,0,2,4,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个二叉搜索树和一个目标结果，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回。,"二叉树的节点个数的范围是[1,10-10<=Node.val<=10题目数据保证，输入的root是一棵的二叉搜索树-10<=k<=10",1,7
522,31,2,50,题库,1,1,4,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个不重复的整数数组。可以用下面的算法从递归地构建:返回。,1<=nums.length<=10000<=nums[i]<=1000nums中的所有整数互不相同,1,6
523,70,2,249,题库,0,2,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，请你构造一个下标从开始、大小为的字符串矩阵，用以表示树的。构造此格式化布局矩阵需要遵循以下规则：返回构造得到的矩阵。,"树的为height，矩阵的行数应该等于height+1矩阵的列数应该等于height+1-1根节点需要放置在的正中间，对应位置为res[0][(n-1)/2]对于放置在矩阵中的每个节点，设对应位置为res[r][c]，将其左子节点放置在res[r+1][c-2height-r-1，右子节点放置在res[r+1][c+2height-r-1继续这一过程，直到树中的所有节点都妥善放置。任意空单元格都应该包含空字符串树中节点数在范围[1,2-99<=Node.val<=99树的深度在范围[1,10]",1,4
524,177,2,44,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在二维平面上，有一个机器人从原点开始。给出它的移动顺序，判断这个机器人在完成移动后是否在。移动顺序由字符串表示。字符表示其第次移动。机器人的有效动作有（右），（左），（上）和（下）。如果机器人在完成所有动作后返回原点，则返回。否则，返回。机器人“面朝”的方向无关紧要。将始终使机器人向右移动一次，将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。,1<=moves.length<=2*10moves只包含字符'U''D''L'和'R',1,2
525,64,2,85,题库,2,1,1,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个的数组，两个整数和，从数组中找到最靠近（两数之差最小）的个数。返回的结果必须要是按升序排好的。整数比整数更接近需要满足：,"|a-x|<|b-x|或者|a-x|==|b-x|且a<b1<=k<=arr.length1<=arr.length<=10arr按排列-10<=arr[i],x<=10",1,6
526,59,3,90,题库,1,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个按排列的整数数组。请你判断是否能在将分割成的同时满足下述条件：如果可以分割并满足上述条件，则返回；否则，返回。,每个子序列都是一个连续递增序列（即，每个整数比前一个整数大）。所有子序列的长度为1<=nums.length<=10-1000<=nums[i]<=1000nums按非递减顺序排列,1,4
527,206,2,57,题库,2,0,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,是大小为的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。每个单元格的定义为：该单元格自身及其周围的8个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中9个单元格的平均值）。如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中4个单元格的平均值）。给你一个表示图像灰度的整数矩阵，返回对图像的每个单元格平滑处理后的图像。,"m==img.lengthn==img[i].length1<=m,n<=2000<=img[i][j]<=255",1,2
528,129,3,37,题库,0,2,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，返回树的。树的是所有层中最大的。每一层的被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的节点，这些节点也计入长度。题目数据保证答案将会在带符号整数范围内。,"树中节点的数目范围是[1,3000]-100<=Node.val<=100",1,4
529,51,2,82,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有台奇怪的打印机有以下两个特殊要求：给你一个字符串，你的任务是计算这个打印机打印它需要的最少打印次数。,打印机每次只能打印由同一个字符组成的序列。每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。1<=s.length<=100由小写英文字母组成,1,2
530,72,2,38,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组，请你判断在改变个元素的情况下，该数组能否变成一个非递减数列。我们是这样定义一个非递减数列的：对于数组中任意的，总满足。,n==nums.length1<=n<=10-10<=nums[i]<=10,1,1
531,67,2,83,题库,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和，请你构造一个答案列表，该列表应当包含从到的个不同正整数，并同时满足下述条件：返回列表。如果存在多种答案，只需返回其中。,"假设该列表是answer=[a,a,a,...,a，那么列表[|a-a|,|a-a|,|a-a|,...,|an-1-a中应该有且仅有个不同整数。1<=k<n<=10",1,2
532,86,2,21,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,几乎每一个人都用。但是你能在乘法表中快速找到第小的数字吗？乘法表是大小为的一个整数矩阵，其中（下标从开始）。给你三个整数、和，请你在大小为的乘法表中，找出并返回第小的数字。,"1<=m,n<=3*101<=k<=m*n",1,2
533,145,2,73,题库,0,1,3,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉搜索树的根节点，同时给定最小边界和最大边界。通过修剪二叉搜索树，使得所有节点的值在中。修剪树改变保留在树中的元素的相对结构(即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。,"树中节点数在范围[1,100<=Node.val<=10树中每个节点的值都是题目数据保证输入是一棵有效的二叉搜索树0<=low<=high<=10",1,4
534,36,2,0,题库,0,1,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个非负整数，你可以交换一次数字中的任意两位。返回你能得到的最大值。,,1,2
535,126,2,82,题库,0,1,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为或。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。更正式地说，即总成立。给出这样的一个二叉树，你需要输出所有节点中的。如果第二小的值不存在的话，输出-1,"树中节点数目在范围[1,25]1<=Node.val<=2-1对于树中每个节点root.val==min(root.left.val,root.right.val)",1,3
536,102,3,152,题库,0,2,0,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,房间中有只已经打开的灯泡，编号从到。墙上挂着。这4个开关各自都具有不同的功能，其中：你必须按压开关次。每次按压，你都需要从4个开关中选出一个来执行按压操作。给你两个整数和，执行完所有按压之后，返回的数量。,"开关1：反转当前所有灯的状态（即开变为关，关变为开）开关2：反转编号为偶数的灯的状态（即0,2,4,...开关3：反转编号为奇数的灯的状态（即1,3,...开关4：反转编号为j=3k+1的灯的状态，其中k=0,1,2,...（即1,4,7,10,...1<=n<=10000<=presses<=1000",1,4
537,25,2,36,题库,1,1,0,2,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个未排序的整数数组，。这个数列必须是递增的。,1<=nums.length<=2000-10<=nums[i]<=10,1,4
538,68,2,34,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个未经排序的整数数组，找到最长且，并返回该序列的长度。可以由两个下标和（）确定，如果对于每个，都有，那么子序列就是连续递增子序列。,1<=nums.length<=10-10<=nums[i]<=10,1,1
539,211,3,109,题库,2,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个的矩阵表示，在这个矩阵中：每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为（即变为地面）。你将从点开始工作，返回你砍完所有树需要走的最小步数。如果你无法砍完所有的树，返回。可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。,"表示障碍，无法触碰表示地面，可以行走比1大的数表示有树的单元格，可以行走，数值表示树的高度m==forest.lengthn==forest[i].length1<=m,n<=500<=forest[i][j]<=10",1,4
540,85,1,393,题库,1,0,1,1,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个使用单词列表进行初始化的数据结构，单词列表中的单词。如果给出一个单词，请判定能否只将这个单词中字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。实现类：,MagicDictionary()初始化对象voidbuildDict(String[]dictionary)使用字符串数组dictionary设定该数据结构，dictionary中的字符串互不相同boolsearch(StringsearchWord)给定一个字符串searchWord，判定能否只将字符串中一个字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回true；否则，返回false1<=dictionary.length<=1001<=dictionary[i].length<=100dictionary[i]仅由小写英文字母组成dictionary中的所有字符串互不相同1<=searchWord.length<=100searchWord仅由小写英文字母组成buildDict仅在search之前调用一次最多调用100次search,1,4
541,21,1,275,题库,1,0,1,1,0,0,1,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个map，满足以下几点:实现一个类：,"字符串表示键，整数表示值返回具有前缀等于给定字符串的键的值的总和MapSum()初始化MapSum对象voidinsert(Stringkey,intval)插入key-val键值对，字符串表示键key，整数表示值val。如果键key已经存在，那么原来的键值对key-value将被替代成新的键值对。intsum(stringprefix)返回所有以该前缀prefix开头的键key的值的总和。1<=key.length,prefix.length<=50key和prefix仅由小写英文字母组成1<=val<=1000最多调用次insert和sum",1,4
542,70,3,142,题库,1,2,1,0,0,0,0,1,0,0,0,0,1,1,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个只包含三种字符的字符串，支持的字符类型分别是、和。请你检验这个字符串是否为有效字符串，如果是有效字符串返回。有效字符串符合如下规则：,任何左括号'('必须有相应的右括号')'任何右括号')'必须有相应的左括号'('左括号'('必须在对应的右括号之前')''*'可以被视为单个右括号')'，或单个左括号'('，或一个空字符串。一个空字符串也被视为有效字符串。1<=s.length<=100s[i]为'('')'或'*',1,4
543,112,2,160,题库,1,1,0,0,0,1,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个长度为4的整数数组。你有张卡片，每张卡片上都包含一个范围在的数字。您应该使用运算符和括号和将这些卡片上的数字排列成数学表达式，以获得值24。你须遵守以下规则:如果可以得到这样的表达式，其计算结果为，则返回，否则返回。,"除法运算符'/'例如，4/(1-2/3)=4/(1/3)=12每个运算都在两个数字之间。特别是，不能使用“-”例如，如果cards=[1,1,1,1]，则表达式“-1-1-1-1”是不允许的。例如，如果cards=[1,2,1,2]，则表达式“12+12”无效。cards.length==41<=cards[i]<=9",1,3
544,47,3,24,题库,1,1,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，可以从中删除一个字符。请你判断是否能成为回文字符串：如果能，返回；否则，返回。,1<=s.length<=10由小写英文字母组成,1,3
545,121,3,135,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表，其中是你需要记录的第项操作，遵循下述规则：请你返回记录中所有得分的总和。,"1<=ops.length<=1000ops[i]为""C""""D""""+""，或者一个表示整数的字符串。整数范围是[-3*10,3*10对于""+""操作，题目数据保证记录此操作时前面总是存在两个有效的分数对于""C""和""D""操作，题目数据保证记录此操作时前面总是存在一个有效的分数",1,3
546,158,2,90,题库,0,2,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,树可以看成是一个连通且的图。给定往一棵个节点(节点值)的树中添加一条边后的图。添加的边的两个顶点包含在到中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为的二维数组，表示图中在和之间存在一条边。请找出一条可以删去的边，删除后可使得剩余部分是一个有着个节点的树。如果有多个答案，则返回数组中最后出现的那个。,n==edges.length3<=n<=1000edges[i].length==21<=ai<bi<=edges.lengthai!=biedges中无重复元素给定的图是连通的,1,4
547,259,2,52,题库,0,2,1,1,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在本问题中，有根树指满足以下条件的图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。输入一个有向图，该图由一个有着个节点（节点值不重复，从到）的树及一条附加的有向边构成。附加的边包含在到中的两个不同顶点间，这条附加的边不属于树中已存在的边。结果图是一个以边组成的二维数组。每个元素是一对，用以表示图中连接顶点和顶点的边，其中是的一个父节点。返回一条能删除的边，使得剩下的图是有个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。,"n==edges.length3<=n<=1000edges[i].length==21<=u,v<=n",1,4
548,78,4,40,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和，寻找重复叠加字符串的最小次数，使得字符串成为叠加后的字符串的子串，如果不存在则返回。字符串重复叠加0次是，重复叠加1次是，重复叠加2次是。,1<=a.length<=101<=b.length<=10和由小写英文字母组成,1,2
549,48,2,47,题库,0,1,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的，返回，这个路径中的。这条路径可以经过也可以不经过根节点。由它们之间的边数表示。,"树的节点数的范围是[0,10-1000<=Node.val<=1000树的深度将不超过1000",1,3
550,175,2,35,题库,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个的国际象棋棋盘上，一个骑士从单元格开始，并尝试进行次移动。行和列是的，所以左上单元格是，右下单元格是。象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。骑士继续移动，直到它走了步或离开了棋盘。返回。,"1<=n<=250<=k<=1000<=row,column<=n-1",1,1
551,114,2,58,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数，找出三个长度为、互不重叠、且全部数字和（项）最大的子数组，并返回这三个子数组。以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从开始）。如果有多个结果，返回字典序最小的一个。,1<=nums.length<=2*101<=nums[i]<21<=k<=floor(nums.length/3),1,2
552,213,1,35,题库,0,2,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,"给定一个保存员工信息的数据结构，它包含了员工，和。比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15,10,5。那么员工1的数据结构是[1,15,[2]]，员工2的数据结构是[2,10,[3]]，员工3的数据结构是[3,5,[]]。注意虽然员工3也是员工1的一个下属，但是由于下属，因此没有体现在员工1的数据结构中。现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。",一个员工最多有一个直系领导，但是可以有多个直系员工数量不超过2000。,1,3
553,173,2,98,题库,2,2,0,0,2,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,我们有种不同的贴纸。每个贴纸上都有一个小写的英文单词。您想要拼写出给定的字符串，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。返回你需要拼出的最小贴纸数量。如果任务不可能，则返回。在所有的测试用例中，所有的单词都是从个最常见的美国英语单词中随机选择的，并且被选择为两个随机单词的连接。,n==stickers.length1<=n<=501<=stickers[i].length<=101<=target.length<=15stickers[i]和target由小写英文单词组成,1,6
554,84,2,74,题库,3,0,2,1,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个单词列表和一个整数，返回前个出现次数最多的单词。返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，排序。尝试以时间复杂度和空间复杂度解决。,"1<=words.length<=5001<=words[i]<=10words[i]由小写英文字母组成。的取值范围是[1,words[i]的数量]",1,7
555,54,3,9,题库,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个正整数，检查它的二进制表示是否总是0、1交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。,1<=n<=2-1,1,1
556,117,2,53,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的二进制矩阵。是由一些相邻的(代表土地)构成的组合，这里的「相邻」要求两个必须在相邻。你可以假设的四个边缘都被（代表水）包围着。岛屿的面积是岛上值为的单元格的数目。计算并返回中最大的岛屿面积。如果没有岛屿，则返回面积为。,"m==grid.lengthn==grid[i].length1<=m,n<=50grid[i][j]为或",1,5
557,83,2,27,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个字符串，统计并返回具有相同数量和的非空（连续）子字符串的数量，并且这些子字符串中的所有和所有都是成组连续的。重复出现（不同位置）的子串也要统计它们出现的次数。,1<=s.length<=10s[i]为'0'或'1',1,2
558,76,2,48,题库,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,EASY,给定一个非空且只包含非负数的整数数组，数组的的定义是指数组里任一元素出现频数的最大值。你的任务是在中找到与拥有相同大小的度的最短连续子数组，返回其长度。,"nums.length在到50,000范围内。nums[i]是一个在到49,999范围内的整数。",1,2
559,42,2,50,题库,1,3,0,0,2,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组和一个正整数，找出是否有可能把这个数组分成个非空子集，其总和都相等。,"1<=k<=len(nums)<=160<nums[i]<10000每个元素的频率在[1,4]范围内",1,6
560,204,2,53,题库,1,0,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在二维平面上的x轴上，放置着一些方块。给你一个二维整数数组，其中表示：第个方块边长为，其左侧边与x轴上坐标点对齐。每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿y轴负方向下落，直到着陆到或者是。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。在每个方块掉落后，你必须记录目前所有已经落稳的。返回一个整数数组，其中表示在第块方块掉落后堆叠的最高高度。,1<=positions.length<=10001<=left<=101<=sideLength<=10,1,3
561,66,2,52,题库,0,0,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定二叉搜索树（BST）的根节点和一个整数值。你需要在BST中找到节点值等于的节点。返回以该节点为根的子树。如果节点不存在，则返回。,"数中节点数在[1,5000]范围内1<=Node.val<=10root是二叉搜索树1<=val<=10",1,3
562,116,3,79,题库,0,0,3,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。输入数据，新值和原始二叉搜索树中的任意节点值都不同。，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回。,"树中的节点数将在[0,10的范围内。-10<=Node.val<=10所有值Node.val是独一无二的。-10<=val<=10val在原始BST中不存在。",1,3
563,51,1,175,题库,0,0,4,0,0,0,2,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,设计一个找到数据流中第大元素的类（class）。注意是排序后的第大元素，不是第个不同的元素。请实现类：,"KthLargest(intk,int[]nums)使用整数和整数流nums初始化对象。intadd(intval)将val插入数据流nums后，返回当前数据流中第大的元素。1<=k<=100<=nums.length<=10-10<=nums[i]<=10-10<=val<=10最多调用add方法题目数据保证，在查找第大元素时，数组中至少有个元素",1,6
564,54,2,0,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定一个个元素有序的（升序）整型数组和一个目标值，写一个函数搜索中的，如果目标值存在返回下标，否则返回。
",,1,2
565,34,1,141,题库,1,0,2,0,1,0,1,0,0,0,1,1,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,不使用任何内建的哈希表库设计一个哈希集合（HashSet）。实现类：,voidadd(key)向哈希集合中插入值keyboolcontains(key)返回哈希集合中是否存在这个值keyvoidremove(key)将给定值key从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。0<=key<=10最多调用次addremove和contains,1,5
566,34,1,229,题库,1,0,2,0,1,0,1,1,0,0,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,不使用任何内建的哈希表库设计一个哈希映射（HashMap）。实现类：,"MyHashMap()用空映射初始化对象voidput(intkey,intvalue)向HashMap插入一个键值对(key,value)。如果key已经存在于映射中，则更新其对应的值valueintget(intkey)返回特定的key所映射的value；如果映射中不包含key的映射，返回voidremove(key)如果映射中存在key的映射，则移除key和它所对应的value0<=key,value<=10最多调用次putget和remove方法",1,5
567,115,1,461,题库,0,0,1,0,0,0,1,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你可以选择使用单链表或者双链表，设计并实现自己的链表。单链表中的节点应该具备两个属性：和。是当前节点的值，是指向下一个节点的指针/引用。如果是双向链表，则还需要属性以指示链表中的上一个节点。假设链表中的所有节点下标从开始。实现类：,"MyLinkedList()初始化MyLinkedList对象。intget(intindex)获取链表中下标为index的节点的值。如果下标无效，则返回voidaddAtHead(intval)将一个值为val的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。voidaddAtTail(intval)将一个值为val的节点追加到链表中作为链表的最后一个元素。voidaddAtIndex(intindex,intval)将一个值为val的节点插入到链表中下标为index的节点之前。如果index等于链表的长度，那么该节点会被追加到链表的末尾。如果index比长度更大，该节点将不会插入到链表中。voiddeleteAtIndex(intindex)如果下标有效，则删除链表中下标为index的节点。0<=index,val<=1000请不要使用内置的LinkedList库。调用getaddAtHeadaddAtTailaddAtIndex和deleteAtIndex的次数不超过2000",1,2
568,38,3,34,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。,1<=s.length<=100由ASCII字符集中的可打印字符组成,1,1
569,99,1,181,题库,2,1,1,0,0,2,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个整数和一个黑名单整数数组。设计一种算法，从范围内的任意整数中选取一个黑名单的整数。任何在上述范围内且不在黑名单中的整数都应该有被返回。优化你的算法，使它最小化调用语言随机函数的次数。实现类:,"Solution(intn,int[]blacklist)初始化整数和被加入黑名单blacklist的整数intpick()返回一个范围为[0,n-1]且不在黑名单blacklist中的随机整数1<=n<=100<=blacklist.length<=min(10,n-1)0<=blacklist[i]<nblacklist中所有值都pick最多被调用2*10",1,6
570,12,2,38,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和，返回。,"0<=s1.length,s2.length<=1000和由小写英文字母组成",1,2
571,45,2,44,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个整数数组和一个整数，请你返回子数组内所有元素的乘积严格小于的连续子数组的数目。
",1<=nums.length<=3*101<=nums[i]<=10000<=k<=10,1,2
572,146,2,50,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，其中表示第天的股票价格；整数代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。,1<=prices.length<=5*101<=prices[i]<5*100<=fee<5*10,1,2
573,53,1,355,题库,0,0,1,1,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为的范围并查询它们。表示所有的实数。实现类:,"RangeModule()初始化数据结构的对象。voidaddRange(intleft,intright)添加半开区间[left,right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间[left,right)中尚未跟踪的任何数字到该区间中。booleanqueryRange(intleft,intright)只有在当前正在跟踪区间[left,right)中的每一个实数时，才返回true，否则返回falsevoidremoveRange(intleft,intright)停止跟踪半开区间[left,right)中当前正在跟踪的每个实数。1<=left<right<=10在单个测试用例中，对addRange、queryRange和removeRange的调用总数不超过",1,3
574,45,2,58,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有两种特殊字符：给你一个以结尾的二进制数组，如果最后一个字符必须是一个一比特字符，则返回。,第一种字符可以用一比特表示第二种字符可以用两比特（或）表示1<=bits.length<=1000bits[i]为或,1,1
575,12,2,59,题库,1,2,0,0,3,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给两个整数数组和，返回。,"1<=nums1.length,nums2.length<=10000<=nums1[i],nums2[i]<=100",1,6
576,58,3,51,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,数对由整数和组成，其数对距离定义为和的绝对差值。给你一个整数数组和一个整数，数对由和组成且满足。返回第小的数对距离。,n==nums.length2<=n<=100<=nums[i]<=101<=k<=n*(n-1)/2,1,4
577,93,2,68,题库,3,0,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给出一个字符串数组组成的一本英语词典。返回中最长的一个单词，该单词是由词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。,1<=words.length<=10001<=words[i].length<=30所有输入的字符串words[i]都只包含小写字母。,1,5
578,217,2,128,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个列表，每个元素是一个字符串列表，其中第一个元素是，其余元素是表示该账户的邮箱地址。现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是的邮箱地址。账户本身可以以返回。,1<=accounts.length<=10002<=accounts[i].length<=101<=accounts[i][j].length<=30accounts[i][0]由英文字母组成accounts[i][j](forj>0)是有效的邮箱地址,1,5
579,264,2,306,题库,2,0,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给一个C++程序，删除程序中的注释。这个程序是一个数组，其中表示第行源码。这表示每行源码由分隔。在C++中有两种注释风格，行内注释和块注释。第一个有效注释优先于其他注释。如果一行在删除注释之后变为空字符串，那么输出该行。即，答案列表中的每个字符串都是非空的。样例中控制字符，单引号或双引号字符。此外，没有其他内容（如定义或宏）会干扰注释。我们保证每一个块注释最终都会被闭合，所以在行或块注释之外的总是开始新的注释。最后，隐式换行符通过块注释删除。有关详细信息，请参阅下面的示例。从源代码中删除注释后，需要以相同的格式返回源代码。,"字符串表示行注释，表示和其右侧的其余字符应该被忽略。字符串表示一个块注释，它表示直到下一个（非重叠）出现的之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。如果字符串出现在块注释中会被忽略。同样，如果字符串出现在行或块注释中也会被忽略。比如，source=""strings=""/*Notacomment.*/"";""不会出现在测试样例里。1<=source.length<=1000<=source[i].length<=80source[i]由可打印的ASCII字符组成。每个块注释都会被闭合。给定的源码中不会有单引号、双引号或其他控制字符。",1,2
580,159,3,38,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请计算数组的。数组是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果中心下标位于数组最左端，那么左侧数之和视为，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。如果数组有多个中心下标，应该返回的那一个。如果数组不存在中心下标，返回。本题与主站1991题相同：,1<=nums.length<=10-1000<=nums[i]<=1000,1,2
581,148,2,44,题库,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个头结点为的单链表和一个整数，请你设计一个算法将链表分隔为个连续的部分。每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过1。这可能会导致有些部分为null。这个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。返回一个由上述部分组成的数组。,"链表中节点的数目在范围[0,1000]0<=Node.val<=10001<=k<=50",1,1
582,220,3,145,题库,2,0,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串化学式，返回。原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。如果数量大于1，原子后会跟着数字表示原子的数量。如果数量等于1则不会跟数字。两个化学式连在一起可以构成新的化学式。由括号括起的化学式并佐以数字（可选择性添加）也是化学式。返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于1），以此类推。,"例如，""H2O""和""H2O2""是可行的，但""H1O2""这个表达是不可行的。例如""H2O2He3Mg4""也是化学式。例如""(H2O2)""和""(H2O2)3""是化学式。1<=formula.length<=1000formula由英文字母、数字、'('和')'组成formula总是有效的化学式",1,4
583,41,2,57,题库,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,是指可以被它包含的每一位数整除的数。不允许包含0。给定两个整数和，返回一个列表，。,例如，128是一个自除数，因为128%1==0128%2==0128%8==01<=left<=right<=10,1,1
584,122,1,154,题库,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"实现一个类来存放你的日程安排。如果要添加的日程安排不会造成，则可以存储这个新的日程安排。当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生。日程可以用一对整数和表示，这里的时间是半开区间，即,实数的范围为，。实现类：","MyCalendar()初始化日历对象。booleanbook(intstart,intend)如果可以将日程安排成功添加到日历中而不会导致重复预订，返回true。否则，返回false并且不要将该日程安排添加到日历中。0<=start<end<=10每个测试用例，调用book方法的次数最多不超过1000次。",1,4
585,112,2,37,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给你一个字符串，返回中不同的非空回文子序列个数。由于答案可能很大，请返回对的结果。字符串的子序列可以经由字符串删除0个或多个字符获得。如果一个序列与它反转后的序列一致，那么它是回文序列。如果存在某个,满足，则两个序列和不同。",1<=s.length<=1000s[i]仅包含'a''b''c'或'd',1,2
586,211,1,90,题库,0,1,1,1,0,0,1,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"实现一个类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。有一个方法。它意味着在到时间内增加一个日程安排，注意，这里的时间是半开区间，即,实数的范围为，。当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。每次调用方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回。否则，返回并且不要将该日程安排添加到日历中。请按照以下步骤调用类:","每个测试用例，调用MyCalendar.book函数最多不超过1000调用函数MyCalendar.book(start,end)时，start和end的取值范围为[0,10^9]",1,4
587,119,1,109,题库,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,当个日程安排有一些时间上的交叉时（例如个日程安排都在同一时间内），就会产生次预订。给你一些日程安排，请你在每个日程安排添加后，返回一个整数，表示所有先前日程安排会产生的最大次预订。实现一个类来存放你的日程安排，你可以一直添加新的日程安排。,"MyCalendarThree()初始化对象。intbook(intstart,intend)返回一个整数，表示日历中存在的次预订的最大值。0<=start<end<=10每个测试用例，调用book函数最多不超过400",1,4
588,168,2,82,题库,2,2,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"有一幅以的二维整数数组表示的图画，其中表示该图画的像素值大小。你也被给予三个整数,和。你应该从像素开始对图像进行上色。为了完成，从初始像素开始，记录初始坐标的像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为。最后返回。","m==image.lengthn==image[i].length1<=m,n<=500<=image[i][j],newColor<20<=sr<m0<=sc<n",1,4
589,164,3,63,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，表示在同一行的行星。对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。,2<=asteroids.length<=10-1000<=asteroids[i]<=1000asteroids[i]!=0,1,3
590,38,3,638,题库,1,1,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个类似Lisp语句的字符串表达式，求出其计算结果。表达式语法如下所示:,"表达式可以为整数，let表达式，add表达式，mult表达式，或赋值的变量。表达式的结果总是一个整数。(整数可以是正整数、负整数、0)let表达式采用""(letv...vexpr)""的形式，其中let总是以字符串""let""来表示，接下来会跟随一对或多对交替的变量和表达式，也就是说，第一个变量被分配为表达式的值，第二个变量被分配为表达式的值，依次类推；最终let表达式的值为expr表达式的值。add表达式表示为""(adde，其中add总是以字符串""add""来表示，该表达式总是包含两个表达式，最终结果是表达式的值与表达式的值之mult表达式表示为""(multe，其中mult总是以字符串""mult""表示，该表达式总是包含两个表达式，最终结果是表达式的值与表达式的值之积在该题目中，变量名以小写字符开始，之后跟随0个或多个小写字符或数字。为了方便，""add""""let""""mult""会被定义为""关键字""，不会用作变量名。最后，要说一下作用域的概念。计算变量名所对应的表达式时，在计算上下文中，首先检查最内层作用域（按括号计），然后按顺序依次检查外部作用域。测试用例中每一个表达式都是合法的。有关作用域的更多详细信息，请参阅示例。1<=expression.length<=2000exprssion中不含前导和尾随空格expressoin中的不同部分（token）之间用单个空格进行分隔答案和所有中间计算结果都符合32-bit整数范围测试用例中的表达式均为合法的且最终结果为整数",1,4
591,39,3,8,题库,0,1,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,当且仅当每个相邻位数上的数字和满足时，我们称这个整数是的。给定一个整数，返回。,0<=n<=10,1,2
592,71,3,50,题库,1,0,2,0,0,0,0,0,1,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，表示每天的温度，返回一个数组，其中是指对于第天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用来代替。,1<=temperatures.length<=1030<=temperatures[i]<=100,1,3
593,86,2,34,题库,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，你可以对它进行一些操作。每次操作中，选择任意一个，删除它并获得的点数。之后，你必须删除等于和的元素。开始你拥有个点数。返回你能通过这些操作获得的最大点数。,1<=nums.length<=2*101<=nums[i]<=10,1,3
594,64,2,347,题库,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,HARD,给你一个的网格，代表一块樱桃地，每个格子由以下三种数字的一种来表示：请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：,"表示这个格子是空的，所以你可以穿过它。表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。表示这个格子里有荆棘，挡着你的路。从位置(0,0)出发，最后到达(n-1,n-1)，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为或者的格子）；当到达(n-1,n-1)后，你要继续走，直到返回到(0,0)，只能向上或向左走，并且只能穿越有效的格子；当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为）；如果在(0,0)和(n-1,n-1)之间不存在一条可经过的路径，则无法摘到任何一个樱桃。n==grid.lengthn==grid[i].length1<=n<=50grid[i][j]为或grid[0][0]!=-1grid[n-1][n-1]!=-1",1,3
595,115,3,91,题库,0,2,3,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个网络节点，标记为到。给你一个列表，表示信号经过边的传递时间。，其中是源节点，是目标节点，是一个信号从源节点传递到目标节点的时间。现在，从某个节点发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回。,"1<=k<=n<=1001<=times.length<=6000times[i].length==31<=u,v<=n!=v0<=w<=100所有,v对都互不相同（即，不含重复边）",1,5
596,61,3,81,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符数组，该数组按排序，以及一个字符。里的字符。返回中大于的最小的字符。如果不存在这样的字符，则返回的第一个字符。,2<=letters.length<=10letters[i]是一个小写字母letters非递减顺序letters最少包含两个不同的字母target是一个小写字母,1,2
597,36,1,242,题库,1,0,1,1,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。实现类：,"WordFilter(string[]words)使用词典中的单词words初始化对象。f(stringpref,stringsuff)返回词典中具有前缀prefix和后缀suff的单词的下标。如果存在不止一个满足要求的下标，返回其中最大的下标。如果不存在这样的单词，返回1<=words.length<=101<=words[i].length<=71<=pref.length,suff.length<=7words[i]pref和suff仅由小写英文字母组成最多对函数执行次调用",1,4
598,96,2,35,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，其中是从楼梯第个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为或下标为的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。,2<=cost.length<=10000<=cost[i]<=999,1,2
599,54,3,47,题库,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，其中总是存在一个最大整数。请你找出数组中的最大元素并检查它是否。如果是，则返回，否则返回。,1<=nums.length<=500<=nums[i]<=100nums中的最大元素是唯一的,1,2
600,168,2,113,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串和一个字符串数组，请你找出中的。是一个包含中所有字母的单词。中的。。如果某个字母在中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。例如：，那么它的补全词应当包含字母、（忽略大写）和两个。可能的有、以及。请返回中的。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取中出现的那个。,1<=licensePlate.length<=7licensePlate由数字、大小写字母或空格''组成1<=words.length<=10001<=words[i].length<=15words[i]由小写英文字母组成,1,3
601,284,3,121,题库,3,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。假设世界由的二维矩阵组成，表示该区域未感染病毒，而表示该区域已感染病毒。可以在任意2个相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且。你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数;如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。,"m==isInfected.lengthn==isInfected[i].length1<=m,n<=50isInfected[i][j]iseitheror在整个描述的过程中，总有一个相邻的病毒区域，它将在下一轮严格地感染更多未受污染的方块",1,5
602,188,3,103,题库,2,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字：。每个拨轮可以自由旋转：例如把变为，变为。每次旋转都只能旋转一个拨轮的一位数字。锁的初始数字为，一个代表四个拨轮的数字的字符串。列表包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。字符串代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回。,1<=deadends.length<=500deadends[i].length==4target.length==4targetdeadends之中target和deadends[i]仅由若干位数字组成,1,4
603,136,2,183,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"有一个需要密码才能打开的保险箱。密码是位数,密码的每一位都是范围中的一个数字。保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住，如果匹配，则能够打开保险箱。在只知道密码位数和范围边界的前提下，请你找出并返回确保在输入的能够打开保险箱的任一密码序列。","例如，正确的密码是""345""，并且你输入的是""012345""输入之后，最后位输入是""0""，不正确。输入之后，最后位输入是""01""，不正确。输入之后，最后位输入是""012""，不正确。输入之后，最后位输入是""123""，不正确。输入之后，最后位输入是""234""，不正确。输入之后，最后位输入是""345""，正确，打开保险箱。1<=n<=41<=k<=101<=k<=4096",1,3
604,45,2,75,题库,0,1,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一根无限长的数轴上，你站在的位置。终点在的位置。你可以做一些数量的移动:给定整数，返回。,每次你可以选择向左或向右移动。次移动（从i==1开始，到i==numMoves），在选择的方向上走步。-10<=target<=10target!=0,1,2
605,215,2,202,题库,0,2,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在把积木堆成金字塔。每个块都有一个颜色，用一个字母表示。每一行的块比它下面的行，并且居中。为了使金字塔美观，只有特定的是允许的。一个三角形的图案由和叠在上面的组成。模式是以三个字母字符串的列表形式给出的，其中模式的前两个字符分别表示左右底部块，第三个字符表示顶部块。你从底部的一排积木开始，作为一个单一的字符串，你使用作为金字塔的底部。在给定和的情况下，如果你能一直构建到金字塔顶部，使金字塔中的都是允许的，则返回，否则返回。,"例如，""ABC""表示一个三角形图案，其中一个“C”块堆叠在一个'A'块(左)和一个'B'块(右)之上。请注意，这与""BAC""不同，""B""在左下角，""A""在右下角。2<=bottom.length<=60<=allowed.length<=216allowed[i].length==3所有输入字符串中的字母来自集合{'A','B','C','D','E','F','G'}allowed中所有值都是唯一的",1,3
606,66,3,136,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个二维整数数组，其中表示从到的所有整数，包括和。是一个名为的数组，并满足中的每个区间都有整数在中。返回包含集合可能的最小大小。,"例如，如果intervals=[[1,3],[3,7],[8,9]]，那么[1,2,4,7,8,9]和[2,3,4,8,9]都符合包含集合的定义。1<=intervals.length<=3000intervals[i].length==20<=start<end<=10",1,3
607,160,1,39,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,特殊的二进制序列是具有以下两个性质的二进制序列：给定一个特殊的二进制序列，以字符串形式表示。定义一个为首先选择的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？,0的数量与1的数量相等。二进制序列的每一个前缀码中1的数量要大于等于0的数量。,1,2
608,39,2,56,题库,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数和，在闭区间范围内，统计并返回的整数个数。就是二进制表示中的个数。,例如，的二进制表示10101有个计算置位。1<=left<=right<=100<=right-left<=10,1,2
609,98,2,26,题库,1,1,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是。返回一个表示每个字符串片段的长度的列表。,1<=s.length<=500仅由小写英文字母组成,1,4
610,124,2,54,题库,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个的矩阵中，除了在数组中给出的元素为，其他每个元素都为。表示返回。如果未找到加号标志，则返回。一个阶由组成的具有中心网格，以及4个从中心向上、向下、向左、向右延伸，长度为，由组成的臂。注意，只有加号标志的所有网格要求为，别的网格可能为也可能为。,"1<=n<=5001<=mines.length<=50000<=x,y<n每一对,y都不重复​​​​​​​",1,2
611,106,2,49,题库,0,3,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,对情侣坐在连续排列的个座位上，想要牵到对方的手。人和座位由一个整数数组表示，其中是坐在第个座位上的人的。情侣们按顺序编号，第一对是，第二对是，以此类推，最后一对是。返回。交换可选择任意两人，让他们站起来交换座位。,2n==row.length2<=n<=30是偶数0<=row[i]<2nrow中所有元素均无重复,1,5
612,64,2,142,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的矩阵。如果这个矩阵是托普利茨矩阵，返回；否则，返回如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是。,"m==matrix.lengthn==matrix[i].length1<=m,n<=200<=matrix[i][j]<=99如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？",1,2
613,37,2,23,题库,2,1,2,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串，检查是否能重新排布其中的字母，使得两相邻的字符不同。返回。,1<=s.length<=500只包含小写字母,1,6
614,71,2,32,题库,2,1,2,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组。将分割成若干，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。返回能将数组分成的最多块数？,1<=arr.length<=20000<=arr[i]<=10,1,5
615,95,2,41,题库,2,1,2,0,0,0,0,0,0,0,1,1,1,0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个长度为的整数数组，它表示在范围内的整数的排列。我们将分割成若干(即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。返回数组能分成的最多块数量。,n==arr.length1<=n<=100<=arr[i]<narr中每个元素都,1,5
616,111,3,556,题库,1,1,2,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个表达式如和一个求值映射，如（给定的形式为和），返回表示简化表达式的标记列表，例如表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。输出格式如下：你可以假设给定的表达式均有效。所有中间结果都在区间内。,"表达式交替使用块和符号，每个块和符号之间有一个空格。块要么是括号中的表达式，要么是变量，要么是非负整数。变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像""2x""或""-x""这样的前导系数或一元运算符。例如，expression=""1+2*3""的答案是[""7""]例如，我们永远不会写像“b*a*c”这样的项，只写“a*b*c”例如，""a*a*b*c""的次数为4。项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数1仍然要打印出来。格式良好的一个示例答案是[""-2*a*a*a"",""3*a*a*b"",""3*b*b"",""4*a"",""5*c"",""-6""]系数为例如，“0”的表达式输出为1<=expression.length<=250expression由小写英文字母，数字'+''-''*''('')'''组成expression不包含任何前空格或后空格expression中的所有符号都用一个空格隔开0<=evalvars.length<=1001<=evalvars[i].length<=20evalvars[i]由小写英文字母组成evalints.length==evalvars.length-100<=evalints[i]<=100",1,5
617,92,2,72,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串代表石头中宝石的类型，另有一个字符串代表你拥有的石头。中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。字母区分大小写，因此和是不同类型的石头。,"1<=jewels.length,stones.length<=50jewels和stones仅由英文字母组成jewels中的所有字符都是唯一的",1,2
618,115,3,66,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"在一个的板上（）有5块砖瓦，用数字来表示,以及一块空缺用来表示。一次定义为选择与一个相邻的数字（上下左右）进行交换.最终当板的结果是谜板被解开。给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回。",board.length==2board[i].length==30<=board[i][j]<=5board[i][j]中每个值都,1,3
619,92,2,122,题库,1,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组，表示由范围内所有整数组成的一个排列。的数目等于满足下述条件不同下标对的数目：的数目等于满足下述条件的下标的数目：当数组中的数量等于的数量时，返回；否则，返回。,"0<=i<j<nnums[i]>nums[j]0<=i<n-1nums[i]>nums[i+1]n==nums.length1<=n<=100<=nums[i]<nnums中的所有整数互不相同nums是范围[0,n-1]内所有数字组成的一个排列",1,2
620,99,1,54,题库,1,0,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"在一个由,和三个字符组成的字符串（例如）中进行移动操作。一次移动操作指用一个替换一个，或者用一个替换一个。现给定起始字符串和结束字符串，请编写代码，当且仅当存在一系列移动操作使得可以转换成时，返回。",1<=len(start)=len(end)<=10000startend中的字符串仅限于'L''R''X',1,2
621,161,2,72,题库,2,3,1,1,0,0,0,1,0,0,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在一个的整数矩阵中，每一个方格的值表示位置的平台高度。当开始下雨时，在时间为时，水池中的水位为。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。你从坐标方格的左上平台出发。返回,n==grid.lengthn==grid[i].length1<=n<=500<=grid[i][j]<ngrid[i][j]中每个值均无重复,1,7
622,72,3,43,题库,0,1,0,0,1,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"我们构建了一个包含行()的表。首先在第一行我们写上一个。接下来的每一行，将前一行中的替换为，替换为。给定行数和序数，返回第行中第个字符。（）
",例如，对于n=3，第行是，第行是，第3行是01101<=n<=301<=k<=2n-1,1,3
623,45,3,18,题库,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给定四个整数,，和，如果通过一系列的可以从起点到达终点，则返回，否则返回。从点可以到或者。","1<=sx,sy,tx,ty<=10",1,1
624,65,2,41,题库,1,1,1,0,0,1,0,0,1,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,森林中有未知数量的兔子。提问其中若干只兔子，将答案收集到一个整数数组中，其中是第只兔子的回答。给你数组，返回森林中兔子的最少数量。,1<=answers.length<=10000<=answers[i]<1000,1,4
625,78,3,56,题库,2,0,0,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个的二维网络仅由和组成。每次移动，你能任意交换两列或是两行的位置。返回。如果不存在可行的变换，输出。是指任意一格的上下左右四个方向的值均与本身不同的矩阵。,n==board.lengthn==board[i].length2<=n<=30board[i][j]将只包含,1,4
626,48,2,32,题库,0,2,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二叉搜索树的根节点，返回。差值是一个正数，其数值等于两值之差的绝对值。本题与530：相同,"树中节点的数目范围是[2,100]0<=Node.val<=10",1,5
627,49,2,34,题库,1,1,0,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串，通过将字符串中的每个字母转变大小写，我们可以获得一个新的字符串。返回。以返回输出。,1<=s.length<=12由小写英文字母、大写英文字母和数字组成,1,3
628,188,2,231,题库,0,2,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"存在一个，图中有个节点。其中每个节点都有一个介于到之间的唯一编号。给你一个二维数组，其中是一个节点数组，由节点的邻接节点组成。形式上，对于中的每个，都存在一条位于节点和节点之间的无向边。该无向图同时具有以下属性：
定义：如果能将一个图的节点集合分割成两个独立的子集和，并使图中的每一条边的两个节点一个来自集合，一个来自集合，就将这个图称为。如果图是二分图，返回；否则，返回。",不存在自环（graph[u]不包含不存在平行边（graph[u]不包含重复值）。如果在graph[u]内，那么也应该在graph[v]内（该图是无向图）这个图可能不是连通图，也就是说两个节点和之间可能不存在一条连通彼此的路径。graph.length==n1<=n<=1000<=graph[u].length<n0<=graph[u][i]<=n-1graph[u]不会包含graph[u]的所有值互不相同如果graph[u]包含，那么graph[v]也会包含,1,4
629,116,2,110,题库,2,1,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,"给你一个按递增顺序排序的数组和一个整数。数组由和若干组成，且其中所有整数互不相同。对于每对满足的和，可以得到分数。那么第个最小的分数是多少呢?以长度为的整数数组返回你的答案,这里且。你可以设计并实现时间复杂度小于的算法解决此问题吗？",2<=arr.length<=10001<=arr[i]<=3*10arr[0]==1arr[i]是一个i>0arr中的所有数字互不相同，且按严格递增排序1<=k<=arr.length*(arr.length-1)/2,1,4
630,114,2,126,题库,0,3,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个城市通过一些航班连接。给你一个数组，其中，表示该航班都从城市开始，以价格抵达。现在给定所有的城市和航班，以及出发城市和目的地，你的任务是找到出一条最多经过站中转的路线，使得从到的，并返回该价格。如果不存在这样的路线，则输出。,"1<=n<=1000<=flights.length<=(n*(n-1)/2)flights[i].length==30<=from,to<nfrom!=to1<=price<=10航班没有重复，且不存在自环0<=src,dst,k<nsrc!=dst",1,6
631,217,1,16,题库,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"我们称一个数X为好数,如果它的每位数字逐个地被旋转180度后，我们仍可以得到一个有效的，且和X不同的数。要求每位数字都要被旋转。如果一个数的每位数字被旋转以后仍然还是一个数字，则这个数是有效的。0,1,和8被旋转后仍然是它们自己；2和5可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2和5互为镜像）；6和9同理，除了这些以外其他的数字旋转以后都不再是有效的数字。现在我们有一个正整数,计算从到中有多少个数X是好数？","N的取值范围是[1,10000]",1,2
632,226,3,104,题库,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你在进行一个简化版的吃豆人游戏。你从点开始出发，你的目的地是。地图上有一些阻碍者，以数组给出，第个阻碍者从出发。所有输入均为。每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置的新位置。当然，也可以选择。所有动作发生。如果你可以在任何阻碍者抓住你到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者到达了一个位置（包括目的地）是逃脱成功。如果不管阻碍者怎么移动都可以成功逃脱时，输出；否则，输出。,"1<=ghosts.length<=100ghosts[i].length==2-10<=x,y<=10同一位置可能有多个阻碍者target.length==2-10<=xtarget,ytarget<=10",1,2
633,139,2,10,题库,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"有两种形状的瓷砖：一种是的多米诺形，另一种是形如""L""的托米诺形。两种形状都可以旋转。给定整数n，返回可以平铺的面板的方法的数量。的值。平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。",1<=n<=1000,1,1
634,98,2,62,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和。的所有字母都是的，并且以前按照一些自定义的顺序排序。对的字符进行置换，使其与排序的相匹配。更具体地说，如果在中的字符出现字符之前，那么在排列后的字符串中，也应该出现在之前。返回。,1<=order.length<=261<=s.length<=200order和由小写英文字母组成order中的所有字符都,1,3
635,69,1,99,题库,2,0,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定字符串和字符串数组,返回。字符串的是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。",例如，“ace”是“abcde”的子序列。1<=s.length<=5*101<=words.length<=50001<=words[i].length<=50words[i]都只由小写字母组成。,1,4
636,35,3,61,题库,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,是末尾是0的数量。回想一下，且。给定，找出返回能满足的非负整数的数量。,例如，f(3)=0，因为3!=6的末尾没有0；而f(11)=2，因为11!=39916800末端有2个0。0<=k<=10,1,2
637,92,3,196,题库,2,0,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串数组表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到所显示的状态时，才返回。井字游戏的棋盘是一个数组，由字符，和组成。字符代表一个空位。以下是井字游戏的规则：,玩家轮流将字符放入空位（''）中。玩家1总是放字符'X'，而玩家2总是放字符'O''X'和'O'只允许放置在空位中，不允许对已放有字符的位置进行填充。当有3个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。当所有位置非空时，也算为游戏结束。如果游戏结束，玩家不允许再放置字符。board.length==3board[i].length==3board[i][j]为'X''O'或'',1,2
638,73,2,50,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和两个整数：及。找出中连续、非空且其中最大元素在范围内的子数组，并返回满足条件的子数组的个数。生成的测试用例保证结果符合整数范围。,1<=nums.length<=100<=nums[i]<=100<=left<=right<=10,1,2
639,49,2,74,题库,2,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定两个字符串,和。如果在若干次旋转操作之后，能变成，那么返回。的就是将最左边的字符移动到最右边。","例如,若s='abcde'，在旋转一次之后结果就是'bcdea'1<=s.length,goal.length<=100和goal由小写英文字母组成",1,2
640,65,2,94,题库,0,3,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个有个节点的，请你找出所有从节点到节点的路径并输出（）是一个从节点可以访问的所有节点的列表（即从节点到节点存在一条有向边）。,n==graph.length2<=n<=150<=graph[i][j]<ngraph[i][j]!=i（即不存在自环）graph[i]中的所有元素互不相同保证输入为有向无环图（DAG）,1,4
641,114,2,147,题库,1,0,0,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组，我们可以将它按一个非负整数进行轮调，这样可以使数组变为的形式。此后，任何值小于或等于其索引的项都可以记作一分。在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标。如果有多个答案，返回满足条件的最小的下标。,"例如，数组为nums=[2,4,1,3,0]，我们按k=2进行轮调后，它将变成[1,3,0,2,4]。这将记为分，因为1>0[不计分]、3>1[不计分]、0<=2[计1分]、2<=3[计1分]，4<=4[计1分]。1<=nums.length<=100<=nums[i]<nums.length",1,2
642,343,3,42,题库,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们把玻璃杯摆成金字塔的形状，其中有个玻璃杯，有个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了-此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。现在当倾倒了非负整数杯香槟后，返回第行个玻璃杯所盛放的香槟占玻璃杯容积的比例（和都从0开始）。,0<=poured<=100<=query_glass<=query_row<100,1,1
643,45,2,161,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,HARD,我们有两个长度相等且不为空的整型数组和。在一次操作中，我们可以交换和的元素。返回。数组且。,"例如，如果nums1=[1,2,3,，nums2=[5,6,7,，你可以交换i=3处的元素，得到nums1=[1,2,3,4]和nums2=[5,6,7,8]用例保证可以实现操作。2<=nums1.length<=10nums2.length==nums1.length0<=nums1[i],nums2[i]<=2*10",1,2
644,147,2,108,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个有个节点的有向图，节点按到编号。图由一个的2D整数数组表示，是与节点相邻的节点的整数数组，这意味着从节点到中的每个节点都有一条边。如果一个节点没有连出的有向边，则该节点是。如果从该节点开始的所有可能路径都通向，则该节点为。返回一个由图中所有组成的数组作为答案。答案数组中的元素应当按排列。,"n==graph.length1<=n<=100<=graph[i].length<=n0<=graph[i][j]<=n-1graph[i]按严格递增顺序排列。图中可能包含自环。图中边的数目在范围[1,4*10内。",1,4
645,197,2,157,题库,2,0,0,1,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一个的二元网格，其中表示砖块，表示空白。砖块（不会掉落）的前提是：给你一个数组，这是需要依次消除砖块的位置。每当消除位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而。一旦砖块掉落，它会从网格中消失（即，它不会落在其他稳定的砖块上）。返回一个数组，其中表示第次消除操作对应掉落的砖块数目。，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。,"一块砖直接连接到网格的顶部，或者至少有一块相邻（4个方向之一）砖块稳定不会掉落时m==grid.lengthn==grid[i].length1<=m,n<=200grid[i][j]为或1<=hits.length<=4*10hits[i].length==20<=x<=m-10<=y<=n-1所有,y互不相同",1,3
646,122,2,166,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,EASY,国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，比如:为了方便，所有个英文字母的摩尔斯密码表如下：给你一个字符串数组，每个单词可以写成每个字母对应摩尔斯密码的组合。对中所有单词进行单词翻译，返回不同的数量。,"'a'对应"".-""'b'对应""-...""'c'对应""-.-.""，以此类推。例如，""cab""可以写成""-.-..--...""，(即""-.-.""+"".-""+""-...""字符串的结合)。我们将这样一个连接过程称作单词翻译1<=words.length<=1001<=words[i].length<=12words[i]由小写英文字母组成",1,3
647,79,2,32,题库,1,1,0,0,2,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给定你一个整数数组我们要将数组中的每个元素移动到数组或者数组中，使得数组和数组不为空，并且。如果可以完成则返回，否则返回。对于数组,是的所有元素的和除以长度。",1<=nums.length<=300<=nums[i]<=10,1,5
648,215,2,61,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,我们要把给定的字符串从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组，这个数组widths[0]代表'a'需要的单位，widths[1]代表'b'需要的单位，...，widths[25]代表'z'需要的单位。现在回答两个问题：至少多少行能放下，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。,"字符串的长度在[1,1000]的范围。只包含小写字母。widths是长度为的数组。widths[i]值的范围在[2,10]",1,2
649,192,2,57,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一座由个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从开始的整数矩阵，其中表示坐落于行列的建筑物的。城市的是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的可能不同。我们被允许为的高度增加。高度为的建筑物的高度也可以增加。然而，增加的建筑物高度从任何主要方向观察城市得到的。在从任何主要方向观测到的城市的前提下，返回建筑物可以增加的。,n==grid.lengthn==grid[r].length2<=n<=500<=grid[r][c]<=100,1,3
650,173,2,15,题库,0,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有的汤。一开始每种类型的汤有毫升。有四种分配操作：当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。不存在先分配ml的操作。需要返回的值：先分配完的概率+同时分配完的概率/2。返回值在正确答案的范围内将被认为是正确的。,0<=n<=10​​​​​​​,1,3
651,364,1,75,题库,2,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"有时候人们会用重复写一些字母来表示额外的感受，比如,。我们将相邻字母都相同的一串字符定义为相同字母组，例如：""h"",""eee"",""ll"",""ooo""。对于一个给定的字符串S，如果另一个单词能够通过将一些字母组扩张从而使其和S相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母），然后往其中添加相同的字母使其长度达到3或以上。例如，以""hello""为例，我们可以对字母组""o""扩张得到""hellooo""，但是无法以同样的方法得到""helloo""因为字母组""oo""长度小于3。此外，我们可以进行另一种扩张""ll""->""lllll""以获得""helllllooo""。如果，那么查询词""hello""是可扩张的，因为可以对它执行这两种扩张操作使得。输入一组查询单词，输出其中可扩张的单词数量。","1<=s.length,words.length<=1001<=words[i].length<=100和所有在words中的单词都只由小写字母组成。",1,3
652,198,3,32,题库,1,0,0,0,1,2,1,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,黑板上写着一个非负整数数组。Alice和Bob轮流从黑板上擦掉一个数字，Alice先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于的话，当前玩家游戏失败。另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为。并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于，这个玩家获胜。假设两个玩家每步都使用最优解，当且仅当Alice获胜时返回。,1<=nums.length<=10000<=nums[i]<2,1,5
653,128,2,186,题库,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,网站域名由多个子域名组成。顶级域名为，二级域名为，最低一级为。当访问域名时，同时也会隐式访问其父域名以及。是遵循或格式的一个域名表示，其中表示访问域名的次数，为域名本身。给你一个组成的数组，解析得到输入中每个子域名对应的，并以数组形式返回。可以按返回答案。,"例如，""9001discuss.leetcode.com""就是一个计数配对域名，表示discuss.leetcode.com被访问了9001次。1<=cpdomain.length<=1001<=cpdomain[i].length<=100cpdomain[i]会遵循""repd1.d2.d3或""repd1.d2格式rep是范围[1,10内的一个整数和由小写英文字母组成",1,4
654,71,2,42,题库,1,0,0,0,0,2,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个由平面上的点组成的数组，其中。从其中取任意三个不同的点组成三角形，返回能组成的最大三角形的面积。与真实值误差在内的答案将会视为正确答案,"3<=points.length<=50-50<=x,y<=50给出的所有点互不相同",1,3
655,110,2,50,题库,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定数组和一个整数。我们将给定的数组分成个相邻的非空子数组。由每个子数组内的平均值的总和构成。注意我们必须使用数组中的每一个数进行分组，并且分数不一定需要是整数。返回我们所能得到的最大是多少。答案误差在内被视为是正确的。,1<=nums.length<=1001<=nums[i]<=101<=k<=nums.length,1,3
656,63,3,27,题库,0,1,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根结点，此外树的每个结点的值要么是，要么是。返回移除了所有不包含的子树的原二叉树。节点的子树为本身加上所有的后代。,"树中节点的数目在范围[1,200]Node.val为或",1,3
657,98,2,193,题库,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组，表示一系列公交线路，其中每个表示一条公交线路，第辆公交车将会在上面循环行驶。现在从车站出发（初始时不在公交车上），要前往车站。期间仅可乘坐公交车。求出。如果不可能到达终点车站，返回。,"例如，路线routes[0]=[1,5,7]表示第辆公交车会一直按序列1->5->7->1->5->7->1->...这样的车站路线行驶。1<=routes.length<=5001<=routes[i].length<=10routes[i]中的所有值互不相同sum(routes[i].length)<=100<=routes[i][j]<100<=source,target<10",1,3
658,212,4,57,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"我们有一些二维坐标，如或，然后我们移除所有逗号，小数点和空格，得到一个字符串。返回所有可能的原始字符串到一个列表中。原始的坐标表示法不会存在多余的零，所以不会出现类似于""00"",""0.0"",""0.00"",""1.0"",""001"",""00.01""或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”形式的数字。最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。","4<=S.length<=12S[0]=""("",S[S.length-1]="")"",且字符串中的其他元素都是数字。",1,2
659,97,2,77,题库,1,0,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定链表头结点，该链表上的每个结点都有一个。同时给定列表，该列表是上述链表中整型值的一个子集。返回列表中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表中）构成的集合。,链表中节点数为1<=n<=100<=Node.val<nNode.val中所有值1<=nums.length<=n0<=nums[i]<nnums中所有值,1,3
660,126,2,79,题库,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"你的赛车可以从位置开始，并且速度为，在一条无限长的数轴上行驶。赛车也可以向负方向行驶。赛车可以按照由加速指令和倒车指令组成的指令序列自动行驶。
例如，在执行指令后，赛车位置变化为，速度变化为。给你一个目标位置，返回能到达目标位置的最短指令序列的长度。",当收到指令'A'position+=speedspeed*=2当收到指令'R'如果速度为正数，那么speed=-1否则speed=11<=target<=10,1,1
661,127,1,167,题库,1,0,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个段落(paragraph)和一个禁用单词列表(banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。,"1<=段落长度<=10000<=禁用单词个数<=1001<=禁用单词长度<=10答案是唯一的,且都是小写字母(即使在paragraph里是大写的，即使是一些特定的名词，答案都是小写的。)paragraph只包含字母、空格和下列标点符号!?',;.不存在没有连字符或者带有连字符的单词。单词里只包含字母，不会出现省略号或者其他标点符号。",1,3
662,55,2,170,题库,2,0,1,1,0,0,0,0,1,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,单词数组的由任意助记字符串和下标数组组成，且满足：给你一个单词数组，返回成功对进行编码的最小助记字符串的长度。,words.length==indices.length助记字符串以'#'字符结尾对于每个下标indices[i]的一个从indices[i]开始、到下一个'#'字符结束（但不包括'#'）的子字符串恰好与words[i]相等1<=words.length<=20001<=words[i].length<=7words[i]仅由小写字母组成,1,4
663,67,2,42,题库,2,0,0,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串和一个字符，且是中出现过的字符。返回一个整数数组，其中且是中从下标到离它的字符的。两个下标和之间的为，其中是绝对值函数。,1<=s.length<=10s[i]和均为小写英文字母题目数据保证在中至少出现一次,1,3
664,233,2,67,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"在桌子上有张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。我们可以先翻转任意张卡片，然后选择其中一张卡片。如果选中的那张卡片背面的数字与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出。其中,和分别代表第张卡片的正面和背面的数字。如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。","n==fronts.length==backs.length1<=n<=10001<=fronts[i],backs[i]<=2000",1,2
665,106,2,44,题库,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给出一个含有不重复整数元素的数组，每个整数均大于1。用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。满足条件的二叉树一共有多少个？答案可能很大，返回的结果。,1<=arr.length<=10002<=arr[i]<=10arr中的所有值互不相同,1,3
666,110,2,276,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由若干单词组成的句子，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。请你将句子转换为山羊拉丁文（）（一种类似于猪拉丁文-PigLatin的虚构语言）。山羊拉丁文的规则如下：返回将转换为山羊拉丁文后的句子。,"如果单词以元音开头（'a''e''i''o''u'），在单词后添加""ma""例如，单词""apple""变为""applema""如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加""ma""例如，单词""goat""变为""oatgma""根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从例如，在第一个单词后添加""a""，在第二个单词后添加""aa""，以此类推。1<=sentence.length<=150sentence由英文字母和空格组成sentence不含前导或尾随空格sentence中的所有单词由单个空格分隔",1,1
667,146,3,100,题库,2,1,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在社交媒体网站上有个用户。给你一个整数数组，其中是第个用户的年龄。如果下述任意一个条件为真，那么用户将不会向用户（）发送好友请求：否则，将会向发送一条好友请求。注意，如果向发送一条好友请求，不必也向发送一条好友请求。另外，用户不会向自己发送好友请求。返回在该社交媒体网站上产生的好友请求总数。,ages[y]<=0.5*ages[x]+7ages[y]>ages[x]ages[y]>100&&ages[x]<100n==ages.length1<=n<=2*101<=ages[i]<=120,1,4
668,46,2,243,题库,2,2,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"你有个工作和个工人。给定三个数组：,和，其中:每个工人只能安排工作，但是一个工作可以。返回。","difficulty[i]表示第个工作的难度，profit[i]表示第个工作的收益。worker[i]是第个工人的能力，即该工人只能完成难度小于等于worker[i]的工作。举个例子，如果3个工人都尝试完成一份报酬为的同样工作，那么总收益为。如果一个工人不能完成任何工作，他的收益为n==difficulty.lengthn==profit.lengthm==worker.length1<=n,m<=101<=difficulty[i],profit[i],worker[i]<=10",1,5
669,62,3,52,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个大小为二进制矩阵。只能将一格变成。返回执行此操作后，中最大的岛屿面积是多少？由一组上、下、左、右四个方向相连的形成。,n==grid.lengthn==grid[i].length1<=n<=500grid[i][j]为或,1,5
670,172,3,26,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"我们定义了一个函数来统计字符串中的唯一字符，并返回唯一字符的个数。例如：，则其中,,,,都是唯一字符，因为它们只出现一次，所以。本题将会给你一个字符串，我们需要返回的总和，其中是的子字符串。输入用例保证返回值为32位整数。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计的所有子字符串中的唯一字符）。",1<=s.length<=10^5只包含大写英文字符,1,3
671,11,2,15,题库,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个正整数，返回。,1<=n<=10​​​​​​​,1,2
672,142,4,25,题库,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"在一个由小写字母构成的字符串中，包含由一些连续的相同字符所构成的分组。例如，在字符串中，就含有,,,和这样的一些分组。分组可以用区间表示，其中和分别表示该分组的起始和终止位置的下标。上例中的分组用区间表示为。我们称所有包含大于或等于三个连续字符的分组为。找到每一个的区间，，返回结果。",1<=s.length<=1000仅含小写英文字母,1,1
673,107,3,459,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一条个人信息字符串，可能表示一个，也可能表示一串。返回按如下规则个人信息后的结果：一个电子邮件地址由以下部分组成：要想隐藏电子邮件地址中的个人信息：一个电话号码应当按下述格式组成：要想隐藏电话号码中的个人信息：,"一个，由大小写英文字母组成，后面跟着一个'@'字符，后面跟着一个，由大小写英文字母和一个位于中间的'.'字符组成。'.'不会是域名的第一个或者最后一个字符。和部分的大写英文字母应当转换成小写英文字母。中间的字母（即，除第一个和最后一个字母外）必须用5个""*****""替换。电话号码可以由10-13位数字组成后10位构成本地号码前面剩下的0-3位，构成国家代码利用{'+','-','(',')',''}这些分隔字符按某种形式对上述数字进行分隔移除所有分隔字符""***-***-XXXX""如果国家代码为0位数字""+*-***-***-XXXX""如果国家代码为1位数字""+**-***-***-XXXX""如果国家代码为2位数字""+***-***-***-XXXX""如果国家代码为3位数字""XXXX""是最后4位本地号码是一个的电子邮件或者电话号码如果8<=s.length<=40是由大小写英文字母，恰好一个'@'字符，以及'.'字符组成如果10<=s.length<=20是由数字、空格、字符'('')''-'和'+'组成",1,1
674,70,2,104,题库,3,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个的二进制矩阵，先翻转图像，然后图像并返回。翻转图片就是将图片的每一行都进行翻转，即逆序。图片的意思是图片中的全部被替换，全部被替换。,"例如，水平翻转[1,1,0]的结果是[0,1,1]例如，反转[0,1,1]的结果是[1,0,0]n==image.lengthn==image[i].length1<=n<=20images[i][j]==或",1,4
675,135,2,253,题库,3,0,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"你会得到一个字符串(索引从0开始)，你必须对它执行个替换操作。替换操作以三个长度均为的并行数组给出：,,。要完成第个替换操作:例如，如果，,，，那么替换的结果将是。所有替换操作必须发生，这意味着替换操作不应该影响彼此的索引。测试用例保证元素间。是字符串中连续的字符序列。","例如，一个s=""abc""，indices=[0,1]，sources=[""ab""，""bc""]的测试用例将不会生成，因为""ab""和""bc""替换重叠。1<=s.length<=1000k==indices.length==sources.length==targets.length1<=k<=1000<=indexes[i]<s.length1<=sources[i].length,targets[i].length<=50仅由小写英文字母组成sources[i]和targets[i]仅由小写英文字母组成",1,3
676,83,3,68,题库,0,2,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个无向、连通的树。树中有个标记为的节点以及条边。给定整数和数组，表示树中的节点和之间有一条边。返回长度为的数组，其中是树中第个节点与所有其他节点之间的距离之和。,"1<=n<=3*10edges.length==n-1edges[i].length==20<=a,b<n!=b给定的输入保证为有效的树",1,4
677,154,3,92,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个图像和，两个图像的大小都是，用大小相同的二进制正方形矩阵表示。二进制矩阵仅由若干和若干组成。其中一个图像，将所有的向左，右，上，或下滑动任何数量的单位；然后把它放在另一个图像的上面。该转换的是指两个图像具有的位置的数目。请注意，转换向任何方向旋转。越过矩阵边界的都将被清除。最大可能的重叠数量是多少？,n==img1.length==img1[i].lengthn==img2.length==img2[i].length1<=n<=30img1[i][j]为或img2[i][j]为或,1,2
678,116,3,77,题库,0,0,0,0,0,2,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,矩形以列表的形式表示，其中为左下角的坐标，是右上角的坐标。矩形的上下边平行于x轴，左右边平行于y轴。如果相交的面积为，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。给出两个矩形和。如果它们重叠，返回；否则，返回。,"rect1.length==4rect2.length==4-10<=rec1[i],rec2[i]<=10rec1和rec2表示一个面积不为零的有效矩形",1,2
679,161,3,24,题库,0,1,0,0,1,2,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,爱丽丝参与一个大致基于纸牌游戏规则的游戏，描述如下：爱丽丝以分开始，并在她的得分少于分时抽取数字。抽取时，她从的范围中随机获得一个整数作为分数进行累计，其中是一个整数。每次抽取都是独立的，其结果具有相同的概率。当爱丽丝获得分时，她就停止抽取数字。爱丽丝的分数不超过的概率是多少？与实际答案误差不超过的答案将被视为正确答案。,0<=k<=n<=101<=maxPts<=10,1,4
680,246,2,140,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡，该骨牌仍然保持不变。就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。给你一个字符串表示这一行多米诺骨牌的初始状态，其中：返回表示最终状态的字符串。,dominoes[i]='L'，表示第张多米诺骨牌被推向左侧，dominoes[i]='R'，表示第张多米诺骨牌被推向右侧，dominoes[i]='.'，表示没有推动第张多米诺骨牌。n==dominoes.length1<=n<=10dominoes[i]为'L''R'或'.',1,3
681,233,2,86,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,如果交换字符串中的两个不同位置的字母，使得它和字符串相等，那么称和两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。例如，和是相似的(交换与的位置)；和也是相似的，但是不与，，或相似。总之，它们通过相似性形成了两个关联组：和。注意，和是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。给你一个字符串列表。列表中的每个字符串都是中其它所有字符串的一个字母异位词。请问中有多少个相似字符串组？,1<=strs.length<=3001<=strs[i].length<=300strs[i]只包含小写字母。strs中的所有单词都具有相同的长度，且是彼此的字母异位词。,1,5
682,82,2,66,题库,2,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,的幻方是一个填充有的不同数字的矩阵，其中每行，每列以及两条对角线上的各数之和都相等。给定一个由整数组成的的，其中有多少个的“幻方”子矩阵？（每个子矩阵都是连续的）。,"row==grid.lengthcol==grid[i].length1<=row,col<=100<=grid[i][j]<=15",1,3
683,180,2,110,题库,0,2,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个房间，房间按从到编号。最初，除号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。给你一个数组其中是你进入号房间可以获得的钥匙集合。如果能进入房间返回，否则返回。,n==rooms.length2<=n<=10000<=rooms[i].length<=10001<=sum(rooms[i].length)<=30000<=rooms[i][j]<n所有rooms[i]的值互不相同,1,3
684,128,3,113,题库,1,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个数字字符串，比如，我们可以将它分成「斐波那契式」的序列。形式上，序列是一个非负整数列表，且满足：另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字本身。返回从拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回。,0<=f[i]<2，（也就是说，每个整数都符合32位有符号整数类型）f.length>=3对于所有的0<=i<f.length-2，都有f[i]+f[i+1]=f[i+2]1<=num.length<=200num中只含有数字,1,2
685,200,2,408,题库,2,0,0,0,0,2,1,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个由字符串组成的单词列表，其中长度均为。中的一个单词将被选作秘密单词。另给你一个辅助对象，你可以调用来猜单词，其中参数长度为6且必须是中的字符串。将会返回如下结果：每组测试用例都会包含一个参数，其中是你可以调用的最大次数。对于每组测试用例，在不超过允许猜测的次数的前提下，你应该调用来猜出秘密单词。最终，你将会得到以下结果：生成的测试用例保证你可以利用某种合理的策略（而不是暴力）猜到秘密单词。,"如果word不是words中的字符串，返回，或者一个整数，表示你所猜测的单词word与秘密单词secret的准确匹配（值和位置同时匹配）的数目。如果你调用Master.guess的次数大于allowedGuesses所限定的次数或者你没有用Master.guess猜到秘密单词，则得到""Eitheryoutooktoomanyguesses,oryoudidnotfindthesecretword.""如果你调用Master.guess猜到秘密单词，且调用Master.guess的次数小于或等于allowedGuesses，则得到""Youguessedthesecretwordcorrectly.""1<=words.length<=100words[i].length==6words[i]仅由小写英文字母组成words中所有字符串互不相同secret存在于words10<=allowedGuesses<=30",1,5
686,65,3,72,题库,2,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定和两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回。代表退格字符。如果对空文本输入退格字符，文本继续为空。,"1<=s.length,t.length<=200和只含有小写字母以及字符'#'你可以用O(n)的时间复杂度和O(1)的空间复杂度解决该问题吗？",1,4
687,49,2,166,题库,2,1,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,把符合下列属性的数组称为：给出一个整数数组，返回最长山脉子数组的长度。如果不存在山脉子数组，返回。,arr.length>=3存在下标0<i<arr.length-1arr[0]<arr[1]<...<arr[i-1]<arr[i]arr[i]>arr[i+1]>...>arr[arr.length-1]1<=arr.length<=100<=arr[i]<=10你可以仅用一趟扫描解决此问题吗？你可以用O(1)空间解决此问题吗？,1,4
688,102,2,57,题库,2,1,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,Alice手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是，并且由张连续的牌组成。给你一个整数数组其中是写在第张牌上的。如果她可能重新排列这些牌，返回；否则，返回。此题目与1296重复：,1<=hand.length<=100<=hand[i]<=101<=groupSize<=hand.length,1,4
689,116,2,89,题库,0,2,1,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,存在一个由个节点组成的无向连通图，图中的节点按从到编号。给你一个数组表示这个图。其中，是一个列表，由所有与节点直接相连的节点组成。返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。,n==graph.length1<=n<=120<=graph[i].length<ngraph[i]不包含如果graph[a]包含，那么graph[b]也包含输入的图总是连通图,1,5
690,86,2,111,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个由小写字母组成的字符串，和一个长度相同的整数数组。我们将字母表中的下一个字母称为原字母的（由于字母表是环绕的，将会变成）。对于每个，我们会将中的前个字母移位次。返回。,"例如，shift('a')='b'shift('t')='u',以及shift('z')='a'1<=s.length<=10由小写英文字母组成shifts.length==s.length0<=shifts[i]<=10",1,2
691,113,3,49,题库,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组表示一排座位，其中代表有人坐在第个座位上，代表座位上是空的（）。至少有一个空座位，且至少有一人已经坐在座位上。亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。返回他到离他最近的人的最大距离。,2<=seats.length<=2*10seats[i]为或至少有一个空座位至少有一个座位上有人,1,1
692,99,2,60,题库,1,0,1,1,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,HARD,给你一个轴对齐的二维数组。对于，其中（x1，y1）是矩形左下角的坐标，是该矩形的坐标，是该矩形的坐标。计算平面中所有所覆盖的。任何被两个或多个矩形覆盖的区域应只计算。返回。因为答案可能太大，返回的。,"1<=rectangles.length<=200rectanges[i].length=40<=x,y,x,y<=10",1,4
693,261,2,121,题库,1,1,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"有一组个人作为实验对象，从到编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为的人简称为""person""。给你一个数组，其中表示person比person更有钱。另给你一个整数数组，其中是person的安静值。中所给出的数据（也就是说，在person比person更有钱的同时，不会出现person比person更有钱的情况）。现在，返回一个整数数组作为答案，其中的前提是，在所有拥有的钱肯定不少于person的人中，person是最安静的人（也就是安静值最小的人）。","n==quiet.length1<=n<=5000<=quiet[i]<nquiet的所有值互不相同0<=richer.length<=n*(n-1)/20<=a,b<n!=bricher中的所有数对互不相同richer的观察在逻辑上是一致的",1,4
694,55,3,146,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"符合下列属性的数组称为：
给你由整数组成的山脉数组，返回满足的下标。你必须设计并实现时间复杂度为的解决方案。",arr.length>=3存在0<i<arr.length-1arr[0]<arr[1]<...arr[i-1]<arr[i]arr[i]>arr[i+1]>...>arr[arr.length-1]3<=arr.length<=100<=arr[i]<=10题目数据保证arr是一个山脉数组,1,2
695,229,3,100,题库,2,0,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一条单行道上，有辆车开往同一目的地。目的地是几英里以外的。给定两个整数数组和，长度都是，其中是第辆车的位置，是第辆车的速度(单位是英里/小时)。一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。返回到达目的地的。,n==position.length==speed.length1<=n<=100<target<=100<=position[i]<targetposition中每个值都0<speed[i]<=10,1,4
696,67,2,82,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,对于某些非负整数，如果交换中两个字母的位置恰好次，能够使结果字符串等于，则认为字符串和的给你两个字母异位词和，返回和的相似度的最小值。,"1<=s1.length<=20s2.length==s1.length和只包含集合{'a','b','c','d','e','f'}中的小写字母是的一个字母异位词",1,2
697,186,1,0,题库,0,0,2,0,0,0,1,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在考场里，一排有个座位，分别编号为。当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在0号座位上。)返回类，它有两个公开的函数：其中，函数会返回一个（整型数据），代表学生坐的位置；函数代表坐在座位上的学生现在离开了考场。每次调用时都保证有学生坐在座位上。,,1,3
698,27,4,45,题库,1,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个平衡括号字符串，按下述规则计算该字符串的分数：,得1分。得A+B分，其中A和B是平衡括号字符串。(A)得2*A分，其中A是平衡括号字符串。,1,2
699,104,2,66,题库,2,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,有名工人。给定两个数组和，其中，表示第名工人的工作质量，其最低期望工资为。现在我们想雇佣名工人组成一个在雇佣一组名工人时，我们必须按照下述规则向他们支付工资：给定整数，返回。在实际答案的以内的答案将被接受。。,"n==quality.length==wage.length1<=k<=n<=101<=quality[i],wage[i]<=10",1,4
700,127,2,13,题库,0,0,0,0,0,3,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为，，以及。正方形房间的墙壁长度为，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器的距离为。返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。,1<=q<=p<=1000,1,3
701,79,3,74,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串和，只要我们可以通过交换中的两个字母得到与相等的结果，就返回；否则返回。交换字母的定义是：取两个下标和（下标从开始）且满足，接着交换和处的字符。,"例如，在""abcd""中交换下标和下标的元素可以生成""cbad""1<=s.length,goal.length<=2*10和goal由小写英文字母组成",1,2
702,164,2,33,题库,1,1,0,0,0,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在柠檬水摊上，每一杯柠檬水的售价为美元。顾客排队购买你的产品，（按账单支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付美元、美元或美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付美元。注意，一开始你手头没有任何零钱。给你一个整数数组，其中是第位顾客付的账。如果你能给每位顾客正确找零，返回，否则返回。,1<=bills.length<=10bills[i]不是就是或是,1,2
703,134,2,53,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个大小为的二元矩阵，矩阵中每个元素的值为或。一次是指选择任一行或列，并转换该行或列中的每一个值：将所有都更改为，将所有都更改为。在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的就是这些数字的总和。在执行任意次后（含0次），返回可能的最高分数。,"m==grid.lengthn==grid[i].length1<=m,n<=20grid[i][j]为或",1,4
704,55,3,42,题库,1,1,3,0,2,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数，找出中和至少为的，并返回该子数组的长度。如果不存在这样的，返回。是数组中的一部分。,1<=nums.length<=10-10<=nums[i]<=101<=k<=10,1,7
705,58,2,69,题库,0,2,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树（具有根结点），一个目标结点，和一个整数值。返回到目标结点距离为的所有结点的值的列表。答案可以以返回。,"节点数在[1,500]范围内0<=Node.val<=500Node.val中所有值目标结点target是树上的结点。0<=k<=1000",1,4
706,243,3,154,题库,2,1,0,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个二维网格，其中：我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。假设k为钥匙/锁的个数，且满足，字母表中的前个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回。,"'.'代表一个空房间'#'代表一堵墙'@'是起点小写字母代表钥匙大写字母代表锁m==grid.lengthn==grid[i].length1<=m,n<=30grid[i][j]只含有'.''#''@''a'-以及'A'-'F'钥匙的数目范围是[1,6]每个钥匙都对应一个的字母每个钥匙正好打开一个对应的锁",1,4
707,93,3,49,题库,0,2,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个根为的二叉树，每个节点的深度是。返回包含原始树中所有的。如果一个节点在的任意节点之间具有最大的深度，则该节点是。一个节点的是该节点加上它的所有后代的集合。本题与力扣1123重复：,"树中节点的数量在[1,500]范围内。0<=Node.val<=500每个节点的值都是独一无二的。",1,5
708,114,3,26,题库,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,求出大于或等于的最小回文素数。回顾一下，如果一个数大于1，且其因数只有1和它自身，那么这个数是。例如，2，3，5，7，11以及13是素数。回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是例如，12321是回文数。,1<=N<=10^8答案肯定存在，且小于2*10^8,1,1
709,44,2,78,题库,3,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二维整数数组，返回的。矩阵的是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。,"m==matrix.lengthn==matrix[i].length1<=m,n<=10001<=m*n<=10-10<=matrix[i][j]<=10",1,3
710,107,3,8,题库,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个正整数，找到并返回的二进制表示中两个1之间的。如果不存在两个相邻的1，返回。如果只有将两个分隔开（可能不存在），则认为这两个1彼此。两个之间的距离是它们的二进制表示中位置的绝对差。例如，中的两个的距离为3。,1<=n<=10,1,1
711,68,2,8,题库,2,0,0,0,1,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定正整数，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到2的幂，返回；否则，返回。,1<=n<=10,1,4
712,50,2,69,题库,2,1,0,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个长度相等的数组和，相对于的可以用满足的索引的数目来描述。返回的排列，使其相对于的优势最大化。,"1<=nums1.length<=10nums2.length==nums1.length0<=nums1[i],nums2[i]<=10",1,4
713,241,3,86,题库,1,2,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,汽车从起点出发驶向目的地，该目的地位于出发位置东面英里处。沿途有加油站，用数组表示。其中表示第个加油站位于出发位置东面英里处，并且有升汽油。假设汽车油箱的容量是无限的，其中最初有升燃料。它每行驶1英里就会用掉1升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回。注意：如果汽车到达加油站时剩余燃料为，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为，仍然认为它已经到达目的地。,"1<=target,startFuel<=100<=stations.length<=5001<=position<positioni+1<target1<=fuel<10",1,4
714,119,2,40,题库,0,1,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个。举个例子，如上图所示，给定一棵叶值序列为的树。如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是的。如果给定的两个根结点分别为和的树是叶相似的，则返回；否则返回。,"给定的两棵树结点数在[1,200]范围内给定的两棵树上的值在[0,200]范围内",1,3
715,66,2,79,题库,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果序列满足下列条件，就说它是的：给定一个的正整数数组形成序列arr，找到中最长的斐波那契式的子序列的长度。如果一个不存在，返回0。,n>=3对于所有i+2<=n，都有X_i+X_{i+1}=X_{i+2}3<=arr.length<=10001<=arr[i]<arr[i+1]<=10^9,1,3
716,146,3,176,题库,2,0,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,机器人在一个无限大小的XY网格平面上行走，从点处开始出发，面向北方。该机器人可以接收以下三种类型的命令：在网格上有一些格子被视为障碍物。第个障碍物位于网格点。机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，并继续执行下一个命令。返回机器人距离原点的的。（即，如果距离为，则返回）,"：向左转：向右转1<=x<=9：向前移动个单位长度北方表示+Y方向。东方表示+X方向。南方表示-Y方向。西方表示-X方向。原点[0,0]可能会有障碍物。1<=commands.length<=10commands[i]的值可以取或者是范围[1,9]内的一个整数。0<=obstacles.length<=10-3*10<=x,y<=3*10答案保证小于",1,2
717,174,3,53,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,珂珂喜欢吃香蕉。这里有堆香蕉，第堆中有根香蕉。警卫已经离开了，将在小时后回来。珂珂可以决定她吃香蕉的速度（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉根。如果这堆香蕉少于根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在小时内吃掉所有香蕉的最小速度（为整数）。,1<=piles.length<=10piles.length<=h<=101<=piles[i]<=10,1,2
718,46,2,32,题库,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你单链表的头结点，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。,"链表的结点数范围是[1,100]1<=Node.val<=100",1,2
719,179,2,63,题库,1,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Alice和Bob用几堆石子在做游戏。一共有偶数堆石子，；每堆都有整数颗石子，数目为。游戏以谁手中的石子最多来决出胜负。石子的是，所以没有平局。Alice和Bob轮流进行，。每回合，玩家从行的或处取走整堆石头。这种情况一直持续到没有更多的石子堆为止，此时手中的玩家。假设Alice和Bob都发挥出最佳水平，当Alice赢得比赛时返回，当Bob赢得比赛时返回。,2<=piles.length<=500piles.length是1<=piles[i]<=500sum(piles[i])是,1,4
720,59,2,20,题库,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"一个正整数如果能被或整除，那么它是神奇的。给定三个整数,,，返回第个神奇的数字。因为答案可能很大，所以返回答案后的值。","1<=n<=102<=a,b<=4*10",1,2
721,124,2,106,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,集团里有名员工，他们可以完成各种各样的工作创造利润。第种工作会产生的利润，它要求名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。工作的任何至少产生利润的子集称为。并且工作的成员总数最多为。有多少种计划可以选择？因为答案很大，所以。,1<=n<=1000<=minProfit<=1001<=group.length<=1001<=group[i]<=100profit.length==group.length0<=profit[i]<=100,1,2
722,76,3,136,题库,1,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个编码字符串。请你找出并将其写入磁带。解码时，从编码字符串中，并采取以下步骤：现在，对于给定的编码字符串和索引，查找并返回解码字符串中的第个字母。,如果所读的字符是字母，则将该字母写在磁带上。如果所读的字符是数字（例如），则整个当前磁带总共会被重复写d-1次。2<=S.length<=100只包含小写字母与数字到以字母开头。1<=K<=10^9题目保证小于或等于解码字符串的长度。解码后的字符串保证少于2^63个字母。,1,2
723,60,3,47,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给定数组。表示第个人的体重，，每艘船可以承载的最大重量为。每艘船最多可同时载两人，但条件是这些人的重量之和最多为。返回。,1<=people.length<=5*101<=people[i]<=limit<=3*10,1,4
724,205,3,102,题库,0,0,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,"给你一个无向图（），图中有个节点，编号从到。你决定将图中的每条边为一条节点链，每条边之间的新节点数各不相同。图用由边组成的二维数组表示，其中表示原始图中节点和之间存在一条边，是将边后的新节点总数。注意，表示边不可细分。要边，需要将其替换为条新边，和个新节点。新节点为,,...,，新边为,,,...,,。现在得到一个，请你计算从节点出发，可以到达多少个节点？如果节点间距离是或更少，则视为。给你原始图和，返回。","0<=edges.length<=min(n*(n-1)/2,10edges[i].length==30<=u<v<n图中不存在平行边0<=cnt<=100<=maxMoves<=101<=n<=3000",1,3
725,110,3,55,题库,2,0,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在的网格中，我们放置了一些与x，y，z三轴对齐的立方体。每个值表示个正方体叠放在单元格上。现在，我们查看这些立方体在、和平面上的。就像影子，将形体映射到一个平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。返回。,n==grid.length==grid[i].length1<=n<=500<=grid[i][j]<=50,1,4
726,89,2,67,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,是一串由空格分隔的单词。每个仅由小写字母组成。如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却，那么这个单词就是。给你两个和，返回所有的列表。返回列表中单词可以按组织。,"1<=s1.length,s2.length<=200和由小写英文字母和空格组成和都不含前导或尾随空格和中的所有单词间均由单个空格分隔",1,2
727,153,2,45,题库,3,0,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在的网格上，你从单元格面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。最终，我们到过网格的所有个空间。按照访问顺序返回表示网格位置的坐标列表。,"1<=rows,cols<=1000<=rStart<rows0<=cStart<cols",1,3
728,107,3,88,题库,0,2,1,1,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一组人（编号为），我们想把每个人分进大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。给定整数和数组，其中，表示不允许将编号为和的人归入同一组。当可以用这种方法将所有人分进两组时，返回；否则返回。,1<=n<=20000<=dislikes.length<=10dislikes[i].length==21<=dislikes[i][j]<=n<bdislikes中每一组都,1,4
729,168,3,17,题库,0,2,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你枚相同的鸡蛋，并可以使用一栋从第层到第层共有层楼的建筑。已知存在楼层，满足，任何从的楼层落下的鸡蛋都会碎，从楼层或比它低的楼层落下的鸡蛋都不会破。每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层扔下（满足）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中这枚鸡蛋。请你计算并返回要确定的是多少？,1<=k<=1001<=n<=10,1,3
730,207,4,111,题库,2,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组和，是爱丽丝拥有的第盒糖果中的糖果数量，是鲍勃拥有的第盒糖果中的糖果数量。两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。返回一个整数数组，其中是爱丽丝必须交换的糖果盒中的糖果的数目，是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中。题目测试用例保证存在与输入对应的答案。,"1<=aliceSizes.length,bobSizes.length<=101<=aliceSizes[i],bobSizes[j]<=10爱丽丝和鲍勃的糖果总数量不同。题目数据保证对于给定的输入至少存在一个有效答案。",1,4
731,68,2,183,题库,1,1,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数数组，和，其中是一个具有值的二叉树的前序遍历，是同一棵树的后序遍历，重构并返回二叉树。如果存在多个答案，您可以返回其中一个。,1<=preorder.length<=301<=preorder[i]<=preorder.lengthpreorder中所有值都postorder.length==preorder.length1<=postorder[i]<=postorder.lengthpostorder中所有值都保证preorder和postorder是同一棵二叉树的前序遍历和后序遍历,1,5
732,110,1,56,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有一个单词列表和一个模式，你想知道中的哪些单词与模式匹配。如果存在字母的排列，使得将模式中的每个字母替换为之后，我们就得到了所需的单词，那么单词与模式是匹配的。返回中与给定模式匹配的单词列表。你可以按任何顺序返回答案。,1<=words.length<=501<=pattern.length=words[i].length<=20,1,3
733,116,2,32,题库,2,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,一个序列的定义为该序列中最大元素和最小元素的差值。给你一个整数数组，返回的所有非空的。由于答案可能非常大，请返回对后的结果。定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，就是数组的一个子序列。,1<=nums.length<=101<=nums[i]<=10,1,3
734,112,3,56,题库,2,0,0,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的网格，上面放置着一些的正方体。每个值表示个正方体叠放在对应单元格上。放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。请你返回最终这些形体的总表面积。每个形体的底面也需要计入表面积中。,n==grid.lengthn==grid[i].length1<=n<=500<=grid[i][j]<=50,1,4
735,119,2,271,题库,2,0,1,0,0,0,0,1,0,1,0,0,0,0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串数组。一步操作中，你可以交换字符串的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。对两个字符串和而言，如果经过任意次数的操作，，那么这两个字符串是的。现在规定，的就是的一个同时满足下述条件的非空子集：返回中的数量。,"例如，words[i]=""zzxy""和words[j]=""xyzz""是一对特殊等价字符串，因为可以按""zzxy""->""xzzy""->""xyzz""的操作路径使words[i]==words[j]该组中的每一对字符串都是特殊等价该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就与该组内任何字符串特殊等价）1<=words.length<=10001<=words[i].length<=20所有words[i]都只由小写字母组成。所有words[i]都具有相同的长度。",1,3
736,104,2,8,题库,0,3,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你找出所有可能含个节点的，并以列表形式返回。答案中每棵树的每个节点都必须符合。答案的每个元素都是一棵真二叉树的根节点。你可以按返回最终的真二叉树列表是一类二叉树，树中每个节点恰好有或个子节点。,1<=n<=20,1,5
737,39,1,140,题库,0,0,3,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出最高的元素。实现类:,FreqStack()构造一个空的堆栈。voidpush(intval)将一个整数val压入栈顶。intpop()如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。0<=val<=10push和pop的操作数不大于2*10输入保证在调用pop之前堆栈中至少有一个元素。,1,4
738,79,3,34,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果数组是单调递增或单调递减的，那么它是。如果对于所有，，那么数组是单调递增的。如果对于所有，，那么数组是单调递减的。当给定的数组是单调数组时返回，否则返回。,1<=nums.length<=10-10<=nums[i]<=10,1,1
739,69,2,35,题库,0,1,4,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一棵二叉搜索树的，请你将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。,"树中节点数的取值范围是[1,100]0<=Node.val<=1000",1,5
740,78,3,41,题库,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们有一个非负整数数组。对于每个（连续的）子数组（），我们对中的每个元素进行按位或操作，获得结果。返回可能结果的数量。多次出现的结果在最终答案中仅计算一次。,1<=nums.length<=5*100<=nums[i]<=10​​​​​​​,1,3
741,43,2,29,题库,2,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串和一个整数。你可以从的前个字母中选择一个，并把它加到字符串的末尾。返回。,1<=k<=S.length<=1000只由小写字母组成。,1,3
742,94,1,278,题库,1,0,0,0,1,0,2,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们可以使用游程编码(即)来编码一个整数序列。在偶数长度()的游程编码数组中，对于所有偶数，告诉我们非负整数在序列中重复的次数。给定一个游程长度的编码数组，设计一个迭代器来遍历它。实现类:,"例如，序列arr=[8,8,8,5,5]可以被编码为encoding=[3,8,2,5]encoding=[3,8,0,9,2,5]和encoding=[2,8,1,8,2,5]也是arr有效的RLERLEIterator(int[]encoded)用编码后的数组初始化对象。intnext(intn)以这种方式耗尽后个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回2<=encoding.length<=1000encoding.length为偶0<=encoding[i]<=101<=n<=10每个测试用例调用next不高于1000次",1,4
743,106,1,145,题库,0,0,2,0,0,0,2,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个算法收集某些股票的每日报价，并返回该股票当日价格的。当日股票价格的被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。例如，如果未来7天股票的价格是，那么股票跨度将是。实现类：,"例如，如果未来7天股票的价格是[100,80,60,70,60,75,85]，那么股票跨度将是[1,1,1,2,1,4,6]StockSpanner()初始化类对象。intnext(intprice)给出今天的股价price，返回该股票当日价格的1<=price<=10最多调用next方法",1,4
744,49,3,92,题库,2,2,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,"给定一个按排列的数字数组。你可以用任意次数来写的数字。例如，如果，我们可以写数字，如,,和。返回。",1<=digits.length<=9digits[i].length==1digits[i]是从'1'到'9'的数digits中的所有值都digits按非递减顺序排列1<=n<=10,1,5
745,56,2,119,题库,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个长度为的字符串，其中是:是对有个在范围内的整数的一个排列，使得对所有的：返回。因为答案可能很大，所以请。,“D”意味着减少，或者“I”意味着增加如果s[i]=='D'，那么perm[i]>perm[i+1]，以及；如果s[i]=='I'，那么perm[i]<perm[i+1]n==s.length1<=n<=200s[i]不是'I'就是'D',1,3
746,115,4,202,题库,1,0,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组表示，其中是第棵树上的水果。你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：给你一个整数数组，返回你可以收集的水果的数目。,你只有篮子，并且每个篮子只能装单一类型的水果。每个篮子能够装的水果总量没有限制。你可以选择任意一棵树开始采摘，你必须从树（包括开始采摘的树）上恰好摘一个水果。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。1<=fruits.length<=100<=fruits[i]<fruits.length,1,3
747,50,2,36,题库,2,0,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，将中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。返回满足此条件的作为答案。,1<=nums.length<=50000<=nums[i]<=5000,1,3
748,83,1,0,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。现在，给定两个正整数和（以字符串形式表示），返回包含在范围中的超级回文数的数目。,,1,2
749,44,2,34,题库,1,1,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，找到的总和，其中的范围为的每个（连续）子数组。由于答案可能很大，因此。,1<=arr.length<=3*101<=arr[i]<=3*10,1,4
750,79,3,40,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，和一个整数。在一个操作中，您可以选择的任何索引。将改为，其中是一个范围为的整数。对于每个索引，最多应用此操作。的是中最大和最小元素的差值。。,1<=nums.length<=100<=nums[i]<=100<=k<=10,1,2
751,241,2,300,题库,2,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的整数矩阵，方格按从到编号，编号遵循，（即，从开始）每一行交替方向。玩家从棋盘上的方格（总是在最后一行、第一列）开始出发。每一回合，玩家需要从当前方格开始出发，按下述要求前进：行列的棋盘，按前述方法编号，棋盘格中可能存在“蛇”或“梯子”；如果，那个蛇或梯子的目的地将会是。编号为和的方格上没有蛇或梯子。注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也继续移动。返回达到编号为的方格所需的最少移动次数，如果不可能，则返回。,"选定目标方格next，目标方格的编号符合范围[curr+1,min(curr+6,n该选择模拟了掷六面体骰子的情景，无论棋盘大小如何，玩家最多只能有6个目的地。传送玩家：如果目标方格next处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格next。当玩家到达编号的方格时，游戏结束。举个例子，假设棋盘是[[-1,4],[-1,3]]，第一次移动，玩家的目标方格是。那么这个玩家将会顺着梯子到达方格，但顺着方格上的梯子前往方格n==board.length==board[i].length2<=n<=20grid[i][j]的值是或在范围[1,n编号为和的方格上没有蛇或梯子",1,3
752,65,3,40,题库,2,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，和一个整数。对于每个下标（），将变成或。的是中最大元素和最小元素的差值。在更改每个下标对应的值之后，返回的最小。,1<=nums.length<=100<=nums[i]<=100<=k<=10,1,4
753,113,1,241,题库,1,1,1,0,0,0,1,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数数组和。在选举中，第张票是在时刻为时投给候选人的。对于发生在时刻的每个查询，需要找出在时刻在选举中领先的候选人的编号。在时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。实现类：,"TopVotedCandidate(int[]persons,int[]times)使用persons和times数组初始化对象。intq(intt)根据前面描述的规则，返回在时刻在选举中领先的候选人的编号。1<=persons.length<=5000times.length==persons.length0<=persons[i]<persons.length0<=times[i]<=10times是一个严格递增的有序数组times[0]<=t<=10每个测试用例最多调用次",1,4
754,20,2,40,题库,5,2,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你将该数组升序排列。,1<=nums.length<=5*10-5*10<=nums[i]<=5*10,1,8
755,215,2,216,题库,0,2,2,0,0,2,0,0,0,1,0,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,两位玩家分别扮演猫和老鼠，在一张图上进行游戏，两人轮流行动。图的形式是：是一个列表，由满足是图中的一条边的所有节点组成。老鼠从节点开始，第一个出发；猫从节点开始，第二个出发。在节点处有一个洞。在每个玩家的行动中，他们沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点，那么它必须移动到中的任一节点。此外，猫无法移动到洞中（节点）。然后，游戏在出现以下三种情形之一时结束：给你一张图，并假设两位玩家都都以最佳状态参与游戏：,如果猫和老鼠出现在同一个节点，猫获胜。如果老鼠到达洞中，老鼠获胜。如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。如果老鼠获胜，则返回如果猫获胜，则返回如果平局，则返回3<=graph.length<=501<=graph[i].length<graph.length0<=graph[i][j]<graph.lengthgraph[i][j]!=igraph[i]互不相同猫和老鼠在游戏中总是可以移动,1,6
756,66,2,54,题库,1,0,1,0,1,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字，使我们可以将整副牌按下述规则分成1组或更多组：仅当你可选的时返回。
",每组都有张牌。组内所有的牌上都写着相同的整数。1<=deck.length<=100<=deck[i]<10,1,5
757,41,2,121,题库,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个数组，将其划分为两个连续子数组和，使得：。用例可以保证存在这样的划分方法。,left中的每个元素都小于或等于right中的每个元素。left和right都是非空的。left的长度要尽可能小。2<=nums.length<=100<=nums[i]<=10可以保证至少有一种方法能够按题目所描述的那样对nums进行划分。,1,1
758,94,5,156,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串数组和。现在，如果中的每个字母都出现在中，，那么称字符串是字符串的。如果对中的每一个单词，都是的子集，那么我们称中的单词是。以数组形式返回中所有的通用单词。你可以按返回答案。,"例如，""wrr""是""warrior""的子集，但不是""world""的子集。1<=words1.length,words2.length<=101<=words1[i].length,words2[i].length<=10words1[i]和words2[i]仅由小写英文字母组成words1中的所有字符串互不相同",1,3
759,26,3,84,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，根据下述规则反转字符串：返回反转后的,"所有非英文字母保留在原有位置。所有英文字母（小写或大写）位置反转。1<=s.length<=100仅由ASCII值在范围[33,122]的字符组成不含'\""'或'\\'",1,2
760,87,3,51,题库,1,2,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个长度为的，返回。意味着数组的末端将会与开头相连呈环状。形式上，的下一个元素是，的前一个元素是。最多只能包含固定缓冲区中的每个元素一次。形式上，对于子数组，不存在其中。,n==nums.length1<=n<=3*10-3*10<=nums[i]<=3*10​​​​​​​,1,5
761,90,1,255,题库,0,1,2,0,0,0,1,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。实现类:,"CBTInserter(TreeNoderoot)使用头节点为root的给定树初始化该数据结构；CBTInserter.insert(intv)向树中插入一个值为Node.val==val的新节点TreeNode。使树保持完全二叉树的状态，并返回插入节点TreeNode的父节点的值CBTInserter.get_root()将返回树的头节点。树中节点数量范围为[1,1000]0<=Node.val<=5000root是完全二叉树0<=val<=5000每个测试用例最多调用insert和get_root操作",1,4
762,98,3,48,题库,0,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你的音乐播放器里有首不同的歌，在旅途中，你计划听首歌（不一定不同，即，允许歌曲重复）。你将会按如下规则创建播放列表：给你、和，返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回对的结果。,每首歌至少播放一次一首歌只有在其他首歌播放完之后才能再次播放。0<=k<n<=goal<=100,1,3
763,62,2,130,题库,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,只有满足下面几点之一，括号字符串才是有效的：给定一个括号字符串，在每一次操作中，你都可以在字符串的任何位置插入一个括号返回。,"它是一个空字符串，或者它可以被写成与连接）,其中和都是有效字符串，或者它可以被写作(A)，其中是有效字符串。例如，如果s=""()))""，你可以插入一个开始括号为""(()))""或结束括号为""())))""1<=s.length<=1000只包含'('和')'字符。",1,3
764,73,2,60,题库,2,0,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非负整数数组，中一半整数是，一半整数是。对数组进行排序，以便当为奇数时，也是；当为偶数时，也是。你可以返回。可以不使用额外空间解决问题吗？,2<=nums.length<=2*10nums.length是偶数nums中一半是偶数0<=nums[i]<=1000,1,3
765,48,2,47,题库,2,0,1,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，以及一个整数作为目标值，返回满足且的元组的数量。由于结果会非常大，请返回的模。,3<=arr.length<=30000<=arr[i]<=1000<=target<=300,1,5
766,256,3,149,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给出了一个由个节点组成的网络，用个邻接矩阵图表示。在节点网络中，当时，表示节点能够直接连接到另一个节点。一些节点最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。假设是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。如果从中能够最小化，返回该节点。如果有多个节点满足条件，就返回的节点。请注意，如果某个节点已从受感染节点的列表中删除，它以后仍有可能因恶意软件传播而受到感染。,n==graph.lengthn==graph[i].length2<=n<=300graph[i][j]==0或graph[i][j]==graph[j][i]graph[i][i]==11<=initial.length<=n0<=initial[i]<=n-1initial中所有整数均不重复,1,5
767,97,2,52,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你的朋友正在使用键盘输入他的名字。偶尔，在键入字符时，按键可能会被，而字符可能被输入1次或多次。你将会检查键盘输入的字符。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回。,"1<=name.length,typed.length<=1000name和typed的字符都是小写字母",1,2
768,92,3,27,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果一个二进制字符串，是以一些（可能没有）后面跟着一些（也可能没有）的形式组成的，那么该字符串是的。给你一个二进制字符串，你可以将任何翻转为或者将翻转为。返回使单调递增的最小翻转次数。,1<=s.length<=10s[i]为'0'或'1',1,2
769,132,3,152,题库,1,0,0,0,0,1,0,0,1,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个由和组成的数组，将数组分成，使得所有这些部分表示相同的二进制值。如果可以做到，请返回，其中，这样一来：如果无法做到，就返回。注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，表示十进制中的，而不会是。此外，前导零也是的，所以和表示相同的值。,"arr[0],arr[1],...,arr[i]为第一部分；arr[i+1],arr[i+2],...,arr[j-1]为第二部分；arr[j],arr[j+1],...,arr[arr.length-1]为第三部分。这三个部分所表示的二进制值相等。3<=arr.length<=3*10arr[i]是或",1,2
770,215,3,143,题库,2,2,0,1,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个由个节点组成的网络，用个邻接矩阵表示。在节点网络中，只有当时，节点能够直接连接到另一个节点。一些节点最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。假设是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。我们可以从中，请返回移除后能够使最小化的节点。如果有多个节点满足条件，返回索引。,n==graph.lengthn==graph[i].length2<=n<=300graph[i][j]是或graph[i][j]==graph[j][i]graph[i][i]==11<=initial.length<n0<=initial[i]<=n-1initial中每个整数都,1,5
771,207,2,270,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,"每个都由一个和一个组成，以符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个或。如果在电子邮件地址的部分中的某些字符之间添加句点（），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则。如果在中添加加号（），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则。可以同时使用这两个规则。给你一个字符串数组，我们会向每个发送一封电子邮件。返回实际收到邮件的不同地址数目。
","例如，在alice@leetcode.com中，alice是本地名，而leetcode.com是例如，""alice.z@leetcode.com”和“alicez@leetcode.com”会转发到同一电子邮件地址。例如m.y+name@email.com将转发到my@email.com1<=emails.length<=1001<=emails[i].length<=100emails[i]由小写英文字母、'+''.'和'@'组成每个emails[i]都包含有且仅有一个'@'字符所有本地名和域名都不为空本地名不会以'+'字符作为开头",1,3
772,44,2,51,题库,1,0,1,0,2,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二元数组，和一个整数，请你统计并返回有多少个和为的子数组。是数组的一段连续部分。,1<=nums.length<=3*10nums[i]不是就是0<=goal<=nums.length,1,4
773,120,2,66,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的整数数组，请你找出并返回通过的的。可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置的下一个元素应当是、或者。,n==matrix.length==matrix[i].length1<=n<=100-100<=matrix[i][j]<=100,1,3
774,59,2,87,题库,1,1,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果长度为的数组满足下述条件，则认为该数组是一个：给你整数，返回长度为的任一。本题保证对于给定的至少存在一个有效答案。,"nums是由范围[1,n]的整数组成的一个排列。对于每个0<=i<j<n，均不存在下标i<k<j）使得2*nums[k]==nums[i]+nums[j]1<=n<=1000",1,3
775,43,1,161,题库,0,0,1,0,0,0,2,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,写一个类来计算特定时间范围内最近的请求。请你实现类：每次对的调用都使用比之前更大的值。,"RecentCounter()初始化计数器，请求数为0。intping(intt)在时间添加一个新请求，其中表示以毫秒为单位的某个时间，并返回过去3000毫秒内发生的所有请求数（包括新请求）。确切地说，返回在[t-3000,t]内发生的请求数。1<=t<=10保证每次对ping调用所使用的值都严格递增至多调用ping方法",1,3
776,96,3,61,题库,2,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的二元矩阵，其中表示陆地，表示水域。是由四面相连的形成的一个最大组，即不会与非组内的任何其他相连。中。你可以将任意数量的变为，以使两座岛连接起来，变成。返回必须翻转的的最小数目。,n==grid.length==grid[i].length2<=n<=100grid[i][j]为或grid中恰有两个岛,1,4
777,199,3,10,题库,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,象棋骑士有一个，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个的形状)。象棋骑士可能的移动方式如下图所示:我们有一个象棋骑士和一个电话垫，如下所示，骑士(即蓝色单元格)。给定一个整数n，返回我们可以拨多少个长度为n的不同电话号码。你可以将骑士放置在上，然后你应该执行n-1次移动来获得长度为n的号码。所有的跳跃应该是的骑士跳跃。因为答案可能很大，.,1<=n<=5000,1,1
778,351,2,0,题库,1,1,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"你想要用组成一个目标字符串。开始的时候，序列由个记号组成。而你有一个小写字母印章。在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行个回合。举个例子，如果初始序列为""?????""，而你的印章是，那么在第一回合，你可以得到""abc??""、""?abc?""、""??abc""。（请注意，印章必须完全包含在序列的边界内才能盖下去。）如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。例如，如果序列是""ababc""，印章是，那么我们就可以返回与操作""?????""->""abc??""->""ababc""相对应的答案；另外，如果可以印出序列，那么需要保证可以在个回合内完成。任何超过此数字的答案将不被接受。",,1,4
779,74,2,215,题库,3,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个日志数组。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的。有两种不同类型的日志：请按下述规则将日志重新排序：返回日志的最终顺序。,字母日志：除标识符之外，所有字均由小写字母组成数字日志：除标识符之外，所有字均由数字组成所有字母日志都排在数字日志之前。字母日志在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。数字日志应该保留原来的相对顺序。1<=logs.length<=1003<=logs[i].length<=100logs[i]中，字与字之间都用空格分隔题目数据保证logs[i]都有一个标识符，并且在标识符之后至少存在一个字,1,3
780,31,2,61,题库,0,1,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,EASY,给定二叉搜索树的根结点，返回值位于范围之间的所有结点的值的和。,"树中节点数目在范围[1,2*101<=Node.val<=101<=low<=high<=10所有Node.val互不相同",1,4
781,59,2,0,题库,2,0,1,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定在xy平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于x轴和y轴。如果没有任何矩形，就返回0。,,1,5
782,79,3,52,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串，计算的的个数。因为结果可能很大，所以返回答案需要对。字符串的是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。,"例如，""ace""是的一个子序列，但""aec""不是。1<=s.length<=2000仅由小写英文字母组成",1,2
783,57,3,134,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数数组，如果它是有效的山脉数组就返回，否则返回。让我们回顾一下，如果满足下述条件，那么它是一个山脉数组：,arr.length>=30<i<arr.length-1条件下，存在arr[0]<arr[1]<...arr[i-1]<arr[i]arr[i]>arr[i+1]>...>arr[arr.length-1]1<=arr.length<=100<=arr[i]<=10,1,1
784,72,3,89,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,EASY,由范围内所有整数组成的个整数的排列序列可以表示为长度为的字符串，其中:给定一个字符串，重构排列并返回它。如果有多个有效排列perm，则返回其中。,"如果perm[i]<perm[i+1]，那么s[i]=='I'如果perm[i]>perm[i+1]，那么s[i]=='D'1<=s.length<=10只包含字符""I""或""D""",1,4
785,84,2,74,题库,2,1,0,0,2,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串数组，找到以中每个字符串作为子字符串的最短字符串。如果有多个有效最短字符串满足题目条件，返回其中即可。我们可以假设中没有字符串是中另一个字符串的子字符串。,1<=words.length<=121<=words[i].length<=20words[i]由小写英文字母组成words中的所有字符串互不相同,1,5
786,134,3,62,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你由个小写字母字符串组成的数组，其中每个字符串长度相等。这些字符串可以每个一行，排成一个网格。例如，可以排列为：你需要找出并删除列。在上面的例子（下标从0开始）中，列0（,,）和列2（,,）都是按升序排列的，而列1（,,）不是，所以要删除列1。返回你需要删除的列数。",n==strs.length1<=n<=1001<=strs[i].length<=1000strs[i]由小写英文字母组成,1,2
787,61,2,32,题库,2,1,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。每次move操作将会选择任意一个满足的下标，并将递增。返回使中的每个值都变成唯一的所需要的最少操作次数。,1<=nums.length<=100<=nums[i]<=10,1,4
788,62,2,101,题库,2,0,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定和两个序列，每个序列中的，只有当它们可能是在最初空栈上进行的推入push和弹出pop操作序列的结果时，返回；否则，返回。,1<=pushed.length<=10000<=pushed[i]<=1000pushed的所有元素互不相同popped.length==pushed.lengthpopped是pushed的一个排列,1,3
789,96,3,48,题库,0,1,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。如果一块石头的上有其他石头存在，那么就可以移除这块石头。给你一个长度为的数组，其中表示第块石头的位置，返回的最大数量。,"1<=stones.length<=10000<=x,y<=10不会有两块石头放在同一个坐标点上",1,3
790,94,3,121,题库,2,1,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你的初始为，初始为，只有一包令牌。其中是第个令牌的值（下标从0开始）。令牌可能的两种使用方法如下：每个令牌只能使用一次，使用，使用所有令牌。在使用任意数量的令牌后，返回我们可以得到的最大。,"如果你至少有token[i]点，可以将令牌置为正面朝上，失去token[i]点，并得到如果我们至少有，可以将令牌置为反面朝上，获得token[i]点，并失去0<=tokens.length<=10000<=tokens[i],power<10",1,4
791,135,4,25,题库,2,0,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个由4位数字组成的数组，返回可以设置的符合24小时制的最大时间。24小时格式为，其中在到之间，在到之间。最小的24小时制时间是，而最大的是。从00:00（午夜）开始算起，过得越久，时间越大。以长度为5的字符串，按格式返回答案。如果不能确定有效时间，则返回空字符串。,arr.length==40<=arr[i]<=9,1,2
792,122,1,0,题库,3,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。现在，重复执行以下步骤，直到显示所有卡牌为止：返回能以显示卡牌的牌组顺序。答案中的第一张牌被认为处于牌堆顶部。,,1,4
793,105,3,44,题库,0,1,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们可以为二叉树定义一个，如下所示：选择任意节点，然后交换它的左子树和右子树。只要经过一定次数的翻转操作后，能使等于，我们就称二叉树于二叉树。这些树由根节点和给出。如果两个二叉树是否是的函数，则返回，否则返回。,"每棵树节点数在[0,100]范围内每棵树中的每个值都是唯一的、在[0,99]范围内的整数",1,3
794,29,3,144,题库,1,0,0,1,0,2,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个由不同正整数的组成的非空数组，考虑下面的图：返回。,nums.length个节点，按从nums[0]到nums[nums.length-1]标记；只有当nums[i]和nums[j]共用一个大于1的公因数时，nums[i]和nums[j]之间才有一条边。1<=nums.length<=2*101<=nums[i]<=10nums中所有值都,1,4
795,98,3,87,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,某种外星语也使用英文小写字母，但可能顺序不同。字母表的顺序（）是一些小写字母的排列。给定一组用外星语书写的单词，以及其字母表的顺序，只有当给定的单词在这种外星语中按字典序排列时，返回；否则，返回。,1<=words.length<=1001<=words[i].length<=20order.length==26words[i]和order中的所有字符都是英文小写字母。,1,3
796,47,3,47,题库,2,1,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个长度为偶数的整数数组，只有对进行重组后可以满足“对于每个，都有”时，返回；否则，返回。,0<=arr.length<=3*10arr.length是偶数-10<=arr[i]<=10,1,4
797,134,3,61,题库,2,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定由个字符串组成的数组，其中每个字符串长度相等。选取一个删除索引序列，对于中的每个字符串，删除对应每个索引处的字符。比如，有，删除索引序列，删除后为。假设，我们选择了一组删除索引，那么在执行删除操作之后，最终得到的数组的元素是按（）排列的，然后请你返回的最小可能值。,n==strs.length1<=n<=1001<=strs[i].length<=100strs[i]由小写英文字母组成,1,3
798,121,3,0,题库,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。你有一堆可以焊接在一起的钢筋。举个例子，如果钢筋的长度为、和，则可以将它们焊接在一起形成长度为的支架。返回。如果没法安装广告牌，请返回。,,1,2
799,162,2,78,题库,1,0,1,0,1,1,0,0,1,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,监狱中间牢房排成一排，每间牢房可能被占用或空置。每天，无论牢房是被占用或空置，都会根据以下规则进行变更：：由于监狱中的牢房排成一行，所以行中的第一个和最后一个牢房不存在两个相邻的房间。给你一个整数数组，用于表示牢房的初始状态：如果第间牢房被占用，则，否则。另给你一个整数。请你返回天后监狱的状况（即，按上文描述进行次变更）。,如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。否则，它就会被空置。cells.length==8cells[i]为或1<=n<=10,1,4
800,85,2,34,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的，确定它是否是一个。在一个中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含到节点之间的最后一级。,"树的结点数在范围[1,100]内。1<=Node.val<=1000",1,3
801,80,3,59,题库,0,2,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在由方格组成的网格中，每个方块由、或空格构成。这些字符会将方块划分为一些共边的区域。给定网格表示为一个字符串数组，返回。请注意，反斜杠字符是转义的，因此用表示。,n==grid.length==grid[i].length1<=n<=30grid[i][j]是'/''\'、或'',1,4
802,138,3,61,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定由个小写字母字符串组成的数组，其中每个字符串长度相等。选取一个删除索引序列，对于中的每个字符串，删除对应每个索引处的字符。比如，有，删除索引序列，删除后为。假设，我们选择了一组删除索引，那么在执行删除操作之后，最终得到的数组的行中的都是按排列的（即和，依此类推）。请返回。,n==strs.length1<=n<=1001<=strs[i].length<=100strs[i]由小写英文字母组成,1,3
803,34,3,111,题库,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，该数组具有以下属性：找出并返回重复了次的那个元素。,nums.length==2*nnums包含n+1个不同的元素nums中恰有一个元素重复2<=n<=5000nums.length==2*n0<=nums[i]<=10nums由n+1不同的元素组成，且其中一个元素恰好重复,1,2
804,47,2,0,题库,1,0,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，是元组，其中且。这样的坡的宽度为。找出中的坡的最大宽度，如果不存在，返回0。,,1,3
805,58,4,0,题库,1,0,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定在xy平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边x轴和y轴。如果没有任何矩形，就返回0。,,1,3
806,143,3,139,题库,0,2,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个正整数，我们将会写出一个形如的表达式，其中每个运算符，，…可以是加、减、乘、除（，，，或是）之一。例如，对于，我们可以写出表达式，该式的值为3。在写这样的表达式时，我们需要遵守下面的惯例：我们希望编写一个能使表达式等于给定的目标值且运算符最少的表达式。返回所用运算符的最少数量。,除运算符（）返回有理数。任何地方都没有括号。我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。不允许使用一元否定运算符（）。例如，“x-x”是一个有效的表达式，因为它只使用减法，但是“-x+x”不是，因为它使用了否定运算符。2<=x<=1001<=target<=2*10,1,3
807,52,2,0,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果二叉树每个节点都具有相同的值，那么该二叉树就是二叉树。只有给定的树是单值二叉树时，才返回；否则返回。,,1,4
808,117,2,650,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在给定单词列表的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。对于给定的查询单词，拼写检查器将会处理两类拼写错误：此外，拼写检查器还按照以下优先级规则操作：给出一些查询，返回一个单词列表，其中是由查询得到的正确单词。,"大小写：如果查询匹配单词列表中的某个单词（不区分大小写例如：wordlist=[""yellow""]query=""YellOw""correct=""yellow""例如：wordlist=[""Yellow""]query=""yellow""correct=""Yellow""例如：wordlist=[""yellow""]query=""yellow""correct=""yellow""元音错误：如果在将查询单词中的元音('a','e','i','o','u')分别替换为任何元音后，能与单词列表中的单词匹配（不区分大小写例如：wordlist=[""YellOw""]query=""yollow""correct=""YellOw""例如：wordlist=[""YellOw""]query=""yeellow""correct=""""（无匹配项）例如：wordlist=[""YellOw""]query=""yllw""correct=""""（无匹配项）当查询完全匹配单词列表中的某个单词（区分大小写）时，应返回相同的单词。当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。如果该查询在单词列表中没有匹配项，则应返回空字符串。1<=wordlist.length,queries.length<=50001<=wordlist[i].length,queries[i].length<=7wordlist[i]和queries[i]只包含英文字母",1,3
809,89,4,14,题库,0,2,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,返回所有长度为且满足其每两个连续位上的数字之间的差的绝对值为的。请注意，数字本身之外，答案中的每个数字都有前导零。例如，有一个前导零，所以是无效的；但是有效的。你可以按返回答案。,2<=n<=90<=k<=9,1,2
810,59,2,0,题库,0,2,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视计算监控树的所有节点所需的最小摄像头数量。
",,1,4
811,115,2,124,题库,2,1,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请使用完成对数组的排序。一次煎饼翻转的执行过程如下：例如，，选择进行一次煎饼翻转，反转子数组，得到。以数组形式返回能使有序的煎饼翻转操作所对应的值序列。任何将数组排序且翻转次数在范围内的有效答案都将被判断为正确。,选择一个整数1<=k<=arr.length反转子数组arr[0...k-1]下标从0开始1<=arr.length<=1001<=arr[i]<=arr.lengtharr中的所有整数互不相同（即，arr是从到arr.length整数的一个排列）,1,4
812,67,2,23,题库,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定三个整数、和，返回。如果某一整数可以表示为，其中整数且，那么我们认为该整数是一个。你可以按返回答案。在你的回答中，每个值出现一次。,"1<=x,y<=1000<=bound<=10",1,2
813,171,3,82,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，树中有个节点，每个节点都有一个不同于其他节点且处于到之间的值。另给你一个由个值组成的行程序列，表示的二叉树结果。通过交换节点的左右子树，可以该二叉树中的任意节点。例，翻转节点1的效果如下：请翻转的树中节点，使二叉树的与预期的遍历行程。如果可以，则返回所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表。,"树中的节点数目为n==voyage.length1<=n<=1001<=Node.val,voyage[i]<=n树中的所有值互不相同voyage中的所有值互不相同",1,3
814,121,3,325,题库,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,给定两个字符串和，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回。字符串中可以使用括号来表示有理数的重复部分。最多可以用三个部分来表示：、和。数字可以用以下三种方法之一来表示：十进制展开的重复部分通常在一对圆括号内表示。例如：,"<IntegerPart>例：和123<IntegerPart><.><NonRepeatingPart>例：0.5,,2.12和123.0001<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>例：0.1(6)，1.(9)123.00(1212)1/6=0.16666666...=0.1(6)=0.1666(6)=0.166(66)每个部分仅由数字组成。整数部分<IntegerPart>不会以零开头。（零本身除外）1<=<IntegerPart>.length<=40<=<NonRepeatingPart>.length<=41<=<RepeatingPart>.length<=4",1,2
815,80,2,33,题库,2,2,1,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给定一个数组，其中表示平面上的一个点，并且是一个整数，返回离原点最近的个点。这里，平面上两点之间的距离是（）。你可以按返回答案。除了点坐标的顺序之外，答案是的。,"1<=k<=points.length<=10-10<x,y<10",1,7
816,45,2,44,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组和一个整数，返回其中元素之和可被整除的（连续、非空）的数目。是数组的部分。,1<=nums.length<=3*10-10<=nums[i]<=102<=k<=10,1,3
817,171,3,189,题库,1,1,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个整数数组，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第1、3、5...次跳跃称为奇数跳跃，而第2、4、6...次跳跃称为偶数跳跃。你可以按以下方式从索引向后跳转到索引（其中）：如果从某一索引开始跳跃一定次数（可能是0次或多次），就可以到达数组的末尾（索引），那么该索引就会被认为是好的起始索引。返回好的起始索引的数量。,在进行奇数跳跃时（如，第1，3，5...次跳跃），你将会跳到索引，使得A[i]<=A[j]A[j]是可能的最小值。如果存在多个这样的索引，你只能跳到满足要求的索引上。在进行偶数跳跃时（如，第2，4，6...次跳跃），你将会跳到索引，使得A[i]>=A[j]A[j]是可能的最大值。如果存在多个这样的索引，你只能跳到满足要求的索引上。（对于某些索引，可能无法进行合乎要求的跳跃。）,1,5
818,43,2,32,题库,2,1,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定由一些正数（代表长度）组成的数组，返回。如果不能形成任何面积不为零的三角形，返回。,3<=nums.length<=101<=nums[i]<=10,1,4
819,29,2,65,题库,2,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个按排序的整数数组，返回组成的新数组，要求也按排序。,1<=nums.length<=-10<=nums[i]<=10nums已按非递减顺序排序设计时间复杂度为O(n)的算法解决本问题,1,3
820,73,3,110,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，返回的。如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是。更正式地来说，当的子数组满足仅满足下列条件时，我们称其为：,i<=k<j为奇数时，A[k]>A[k+1]为偶数时，A[k]<A[k+1]i<=k<j为偶数时，A[k]>A[k+1]，且为奇数时，A[k]<A[k+1]1<=arr.length<=4*100<=arr[i]<=10,1,3
821,135,2,46,题库,0,1,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个有个结点的二叉树的根结点，其中树中每个结点都对应有枚硬币。整棵树上一共有枚硬币。在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。返回使每个结点上一枚硬币所需的移动次数。,树中节点的数目为1<=n<=1000<=Node.val<=n所有Node.val的值之和是,1,3
822,56,3,92,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在二维网格上，有4种类型的方格：返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。,表示起始方格。且只有一个起始方格。表示结束方格，且只有一个结束方格。表示我们可以走过的空方格。表示我们无法跨越的障碍。1<=grid.length*grid[0].length<=20,1,4
823,60,1,355,题库,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。实现类：,"TimeMap()初始化数据结构对象voidset(Stringkey,Stringvalue,inttimestamp)存储键key、值value，以及给定的时间戳timestampStringget(Stringkey,inttimestamp)返回先前调用set(key,value,timestamp_prev)所存储的值，其中timestamp_prev<=timestamp如果有多个这样的值，则返回对应最大的timestamp_prev的那个值。如果没有值，则返回空字符串（1<=key.length,value.length<=100key和value由小写英文字母和数字组成1<=timestamp<=10set操作中的时间戳timestamp都是严格递增的最多调用set和get操作2*10",1,4
824,38,2,118,题库,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，返回其中的数目。是由下标组成的三元组，并满足下述全部条件：,0<=i<nums.length0<=j<nums.length0<=k<nums.lengthnums[i]&nums[j]&nums[k]==0，其中表示按位与运算符。1<=nums.length<=10000<=nums[i]<2,1,3
825,145,2,150,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为的数组给出。每一项是一个从到的整数。火车票有：通行证允许数天无限制的旅行。例如，如果我们在第天获得一张的通行证，那么我们可以连着旅行7天：第天、第天、第天、第天、第天、第天和第天。返回。,一张为期一天的通行证售价为costs[0]美元；一张为期七天的通行证售价为costs[1]美元；一张为期三十天的通行证售价为costs[2]美元。1<=days.length<=3651<=days[i]<=365days按顺序严格递增costs.length==31<=costs[i]<=1000,1,2
826,19,2,82,题库,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数和，返回字符串，要求满足：,"的长度为a+b，且正好包含个'a'字母与个'b'字母；子串'aaa'没有出现在中；子串'bbb'没有出现在中。0<=a,b<=100对于给定的和，保证存在满足要求的",1,2
827,82,1,0,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给出一个整数数组和一个查询数组。对于第次查询，有，我们会把加到上。然后，第次查询的答案是中偶数值的和。返回所有查询的答案。你的答案应当以数组给出，为第次查询的答案。,,1,2
828,90,4,136,题库,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个由一些组成的列表，和，其中而。每个区间列表都是成对的，并且。返回这。形式上，（其中）表示实数的集合，而。两个闭区间的是一组实数，要么为空集，要么为闭区间。例如，和的交集为。,"0<=firstList.length,secondList.length<=1000firstList.length+secondList.length>=10<=start<end<=10end<starti+10<=start<end<=10end<startj+1",1,2
829,150,3,36,题库,0,2,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你二叉树的根结点，请你设计算法计算二叉树的序列。对位于的每个结点而言，其左右子结点分别位于和。树的根结点位于。二叉树的从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。返回二叉树的序列。,"树中结点数目总数在范围[1,1000]0<=Node.val<=1000",1,5
830,75,3,69,题库,1,1,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一颗根结点为的二叉树，树中的每一个结点都有一个范围内的值，分别代表字母到。返回。注字符串中任何较短的前缀在都是的：节点的叶节点是没有子节点的节点。,"例如，在字典序上""ab""比""aba""要小。叶结点是指没有子结点的结点。给定树的结点数在[1,8500]范围内0<=Node.val<=25",1,4
831,36,3,82,题库,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,整数的是按照从左到右的顺序表示其数字的数组。给定，整数的，和整数，返回。,"例如，对于num=1321，数组形式是[1,3,2,1]1<=num.length<=100<=num[i]<=9num不包含任何前导零，除了零本身1<=k<=10",1,2
832,117,5,0,题库,2,0,1,1,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程的长度为，并采用两种不同的形式之一：或。在这里，a和b是小写字母（不一定不同），表示单字母变量名。只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回，否则返回。,,1,4
833,49,3,69,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在显示着数字的坏计算器上，我们可以执行以下两种操作：给定两个整数和。返回显示数字所需的最小操作数。,"双倍（Double）：将显示屏上的数字乘2；递减（Decrement）：将显示屏上的数字减1<=startValue,target<=10",1,2
834,69,2,71,题库,1,0,1,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个正整数数组和一个整数，返回中「的数目。如果的某个子数组中不同整数的个数恰好为，则称的这个连续、不一定不同的子数组为。是数组的部分。,"例如，[1,2,3,1,2]中有个不同的整数：，以及1<=nums.length<=2*101<=nums[i],k<=nums.length",1,4
835,118,3,39,题库,0,2,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在二叉树中，根节点位于深度处，每个深度为的节点的子节点位于深度处。如果二叉树的两个节点深度相同，但，则它们是一对。我们给出了具有唯一值的二叉树的根节点，以及树中两个不同节点的值和。只有与值和对应的节点是堂兄弟节点时，才返回。否则，返回。,二叉树的节点数介于到100之间。每个节点的值都是唯一的、范围为到100的整数。,1,4
836,46,3,76,题库,2,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,在给定的网格中，每个单元格可以有以下三个值之一：每分钟，腐烂的橘子的新鲜橘子都会腐烂。返回。,"代表空单元格；代表新鲜橘子；代表腐烂的橘子。m==grid.lengthn==grid[i].length1<=m,n<=10grid[i][j]仅为或",1,3
837,89,3,35,题库,1,0,1,0,3,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,HARD,给定一个二进制数组和一个整数。就是从中选择一个长度为的，同时把子数组中的每一个都改成，把子数组中的每一个都改成。返回数组中不存在所需的最小次数。如果不可能，则返回。是数组的部分。,1<=nums.length<=101<=k<=nums.length,1,5
838,91,2,0,题库,1,2,0,0,2,1,0,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个非负整数数组，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为数组。返回A的正方形排列的数目。两个排列和不同的充要条件是存在某个索引，使得A1[i]!=A2[i]。,,1,6
839,109,3,85,题库,1,0,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,小镇里有个人，按从到的顺序编号。传言称，这些人中有一个暗地里是小镇法官。如果小镇法官真的存在，那么：给你一个数组，其中表示编号为的人信任编号为的人。如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回。,"1<=n<=10000<=trust.length<=10trust[i].length==2trust中的所有trust[i]=[a,b互不相同!=b1<=a,b<=n",1,3
840,129,3,207,题库,0,0,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。给你最大树的根节点和一个整数。就像那样，给定的树是利用例程从列表（）递归地构建的：请注意，题目没有直接给出，只是给出一个根节点。假设是的副本，并在末尾附加值。题目数据保证中的值互不相同。返回。,"如果为空，返回null否则，令a[i]作为的最大元素。创建一个值为a[i]的根节点rootroot的左子树将被构建为Construct([a[0],a[1],...,a[i-1]])root的右子树将被构建为Construct([a[i+1],a[i+2],...,a[a.length-1]])返回root树中节点数目在范围[1,100]1<=Node.val<=100树中的所有值互不相同1<=val<=100",1,2
841,197,3,94,题库,3,0,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,在一个8x8的棋盘上，有一个白色的车（），用字符表示。棋盘上还可能存在空方块，白色的象（）以及黑色的卒（），分别用字符，和表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。,棋手选择主动停下来。棋子因到达棋盘的边缘而停下。棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。,1,3
842,80,3,49,题库,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有堆石头排成一排，第堆中有块石头。每次需要将堆石头合并为一堆，而这次移动的成本为这堆中石头的总数。返回把所有石头合并成一堆的最低成本。如果无法合并成一堆，返回。,n==stones.length1<=n<=301<=stones[i]<=1002<=k<=30,1,3
843,235,3,116,题库,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在大小为的网格上，每个单元格都有一盏灯，最初灯都处于状态。给你一个由灯的位置组成的二维数组，其中表示位于的灯。即便同一盏灯可能在中多次列出，不会影响这盏灯处于状态。当一盏灯处于打开状态，它将会照亮以及同一、同一和两条上的。另给你一个二维数组，其中。对于第个查询，如果单元格是被照亮的，则查询结果为，否则为。在第次查询之后[按照查询的顺序]，位于单元格上及相邻8个方向上（与单元格共享角或边）的任何灯。返回一个整数数组作为答案，应等于第次查询的结果，表示照亮，表示未照亮。,"1<=n<=100<=lamps.length<=200000<=queries.length<=20000lamps[i].length==20<=row,col<nqueries[j].length==20<=row,col<n",1,2
844,55,2,60,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你一个字符串数组，请你找出所有在的每个字符串中都出现的共用字符（），并以数组形式返回。你可以按返回答案。
",1<=words.length<=1001<=words[i].length<=100words[i]由小写英文字母组成,1,3
845,67,3,109,题库,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,"给你一个字符串，请你判断它是否。
字符串需要满足：假设开始有一个空字符串，你可以执行下述操作将：如果字符串有效，则返回；否则，返回。","将字符串""abc""插入到中的任意位置。形式上，变为left+""abc""+tright，其中t==tleft+tright。注意，left和right可能为1<=s.length<=2*10由字母'a''b'和'c'组成",1,2
846,29,2,46,题库,1,1,0,0,2,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二进制数组和一个整数，如果可以翻转最多个，则返回。,1<=nums.length<=10nums[i]不是就是0<=k<=nums.length,1,4
847,63,3,70,题库,2,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组和一个整数，按以下方法修改该数组：重复这个过程恰好次。可以多次选择同一个下标。以这种方式修改数组后，返回数组。,选择某个下标并将nums[i]替换为-nums[i]1<=nums.length<=10-100<=nums[i]<=1001<=k<=10,1,3
848,233,2,0,题库,1,0,1,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,通常，正整数的阶乘是所有小于或等于的正整数的乘积。例如，。相反，我们设计了一个笨阶乘：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。例如，。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。另外，我们使用的除法是地板除法（），所以等于。这保证结果是一个整数。实现上面定义的笨函数：给定一个整数，它返回的笨阶乘。,,1,3
849,129,2,71,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一排多米诺骨牌中，和分别代表第个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从1到6的数字同列平铺形成的——该平铺的每一半上都有一个数字。）我们可以旋转第张多米诺，使得和的值交换。返回能使中所有值或者中所有值都相同的最小旋转次数。如果无法做到，返回.,"2<=tops.length<=2*10bottoms.length==tops.length1<=tops[i],bottoms[i]<=6",1,2
850,112,2,58,题库,1,0,5,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个整数数组，它表示BST(即)的，构造树并返回其根。对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。是一棵二叉树，其中每个节点，的任何后代的值,的任何后代的值。二叉树的首先显示节点的值，然后遍历，最后遍历。",1<=preorder.length<=1001<=preorder[i]<=10^8preorder中的值互不相同,1,6
851,130,3,0,题库,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,每个非负整数都有其二进制表示。例如，可以被表示为二进制，可以用二进制表示，依此类推。注意，除外，任何二进制表示中都不含前导零。二进制的反码表示是将每个改为且每个变为。例如，二进制数的二进制反码为。给你一个十进制数，请你返回其二进制表示的反码所对应的十进制整数。,,1,1
852,64,2,35,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在歌曲列表中，第首歌曲的持续时间为秒。返回其总持续时间（以秒为单位）可被整除的歌曲对的数量。形式上，我们希望下标数字和满足且有。,1<=time.length<=6*101<=time[i]<=500,1,3
853,116,3,47,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,传送带上的包裹必须在天内从一个港口运送到另一个港口。传送带上的第个包裹的重量为。每一天，我们都会按给出重量（）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。返回能在天内将传送带上的所有包裹送达的船的最低运载能力。,1<=days<=weights.length<=5*101<=weights[i]<=500,1,2
854,26,3,8,题库,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定正整数，返回在范围内具有重复数字的正整数的个数。,1<=n<=10,1,2
855,61,3,34,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，只有可以将其划分为三个和相等的部分时才返回，否则返回。形式上，如果可以找出索引且满足就可以将数组三等分。,3<=arr.length<=5*10-10<=arr[i]<=10,1,2
856,90,2,40,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，其中表示第个观光景点的评分，并且两个景点和之间的为。一对景点（）组成的观光组合的得分为，也就是景点的评分之和它们两者之间的距离。返回一对观光景点能取得的最高分。,2<=values.length<=5*101<=values[i]<=1000,1,2
857,67,3,8,题库,0,0,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定正整数，你需要找出可以被整除的、仅包含数字的最正整数的长度。返回的长度。如果不存在这样的，就返回-1。可能不符合64位带符号整数。,1<=k<=10,1,2
858,44,2,39,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二进制字符串和一个正整数，如果对于范围内的每个整数，。是字符串中连续的字符序列。,1<=s.length<=1000s[i]不是'0'就是'1'1<=n<=10,1,1
859,51,3,8,题库,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，以二进制字符串的形式返回该整数的表示。除非字符串就是，否则返回的字符串中不能含有前导零。,0<=n<=10,1,1
860,71,2,56,题库,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个二进制数组()。我们将定义为其二进制表示形式为子数组(从最高有效位到最低有效位)。返回布尔值列表，只有当可以被整除时，答案为，否则为。,"例如，如果nums=[1,0,1]，那么=1=2,和=51<=nums.length<=10nums[i]仅为或",1,1
861,115,2,30,题库,1,0,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个长度为的链表对于列表中的每个节点，查找下一个的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值它的值。返回一个整数数组，其中是第个节点()的下一个更大的节点的值。如果第个节点没有下一个更大的节点，设置。,链表中节点数为1<=n<=101<=Node.val<=10,1,4
862,100,2,56,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的二进制矩阵，其中表示一个海洋单元格、表示一个陆地单元格。一次是指从一个陆地单元格走到另一个相邻（）的陆地单元格或跨过的边界。返回网格中在任意次数的移动中离开网格边界的陆地单元格的数量。,"m==grid.lengthn==grid[i].length1<=m,n<=500grid[i][j]的值为或",1,5
863,151,3,74,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有效括号字符串为空、或，其中和都是有效的括号字符串，代表字符串的连接。如果有效字符串非空，且不存在将其拆分为的方法，我们称其为，其中和都是非空有效括号字符串。给出一个非空有效字符串，考虑将其进行原语化分解，使得：，其中是有效括号字符串原语。对进行原语化分解，删除分解中每个原语字符串的最外层括号，返回。,"例如，""()""""(())()""和""(()(()))""都是有效的括号字符串。1<=s.length<=10s[i]为'('或')'是一个有效括号字符串",1,2
864,104,2,69,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给出一棵二叉树，其上每个结点的值都是或。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。返回这些数字之和。题目数据保证答案是一个整数。,"例如，如果路径为0->1->1->0->1，那么它表示二进制数01101，也就是树中的节点数在[1,1000]范围内Node.val仅为或",1,3
865,109,4,87,题库,2,0,0,1,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串数组，和一个表示模式的字符串，请你返回一个布尔数组。只有在待查项与模式串匹配时，才为，否则为。如果可以将插入模式串得到待查询项，那么待查询项与给定模式串匹配。可以在任何位置插入每个字符，也可以不插入字符。,"1<=pattern.length,queries.length<=1001<=queries[i].length<=100queries[i]和pattern由英文字母组成",1,4
866,168,3,86,题库,1,2,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你将会获得一系列视频片段，这些片段来自于一项持续时长为秒的体育赛事。这些片段可能有所重叠，也可能长度不一。使用数组描述所有的视频片段，其中表示：某个视频片段开始于并于结束。甚至可以对这些片段自由地再剪辑：我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（）。返回所需片段的最小数目，如果无法完成该任务，则返回。,"例如，片段[0,7]可以剪切成[0,1]+[1,3]+[3,7]三部分。1<=clips.length<=1000<=start<=end<=1001<=time<=100",1,3
867,79,2,40,题库,0,1,0,0,0,2,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字。在每个玩家的回合，玩家需要执行以下操作：如果玩家无法执行这些操作，就会输掉游戏。,选出任一，满足0<x<n且n%x==0n-x替换黑板上的数字1<=n<=1000,1,4
868,77,2,30,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定二叉树的根节点，找出存在于节点和之间的最大值，其中，且是的祖先。（如果A的任何子节点之一为B，或者A的任何子节点是B的祖先，那么我们认为A是B的祖先）,树中的节点数在到5000之间。0<=Node.val<=10,1,3
869,59,3,35,题库,1,2,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，返回中最长等差子序列的。回想一下，的子序列是一个列表，且。并且如果()的值都相同，那么序列是等差的。,2<=nums.length<=10000<=nums[i]<=500,1,4
870,107,3,34,题库,1,1,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,我们从二叉树的根节点开始进行深度优先搜索。在遍历中的每个节点处，我们输出条短划线（其中是该节点的深度），然后输出该节点的值。（如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出，还原树并返回其根节点。,原始树中的节点数介于和1000之间。每个节点的值介于和10^9之间。,1,4
871,68,3,72,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,公司计划面试人。给你一个数组，其中。第人飞往市的费用为，飞往市的费用为。返回将每个人都飞到、中某座城市的最低费用，要求每个城市都有人抵达,"2*n==costs.length2<=costs.length<=100costs.length为偶数1<=aCost,bCost<=1000",1,3
872,86,3,47,题库,3,0,0,0,0,2,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定四个整数,,和。有一个的矩阵，你在单元格上的坐标是。返回矩阵中的所有单元格的坐标，并按与的从最小到最大的顺序排。你可以按满足此条件的顺序返回答案。单元格和之间的距离为。","1<=rows,cols<=1000<=rCenter<rows0<=cCenter<cols",1,5
873,88,3,107,题库,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和两个整数和，请你找出并返回两个非重叠中元素的最大和长度分别为和。长度为的子数组可以出现在长为的子数组之前或之后，但二者必须是不重叠的。子数组是数组的一个部分。,"1<=firstLen,secondLen<=10002<=firstLen+secondLen<=1000firstLen+secondLen<=nums.length<=10000<=nums[i]<=1000",1,3
874,98,1,223,题库,2,0,0,1,0,0,2,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组中的一个字符串。例如，且字符流中逐个依次加入4个字符、、和，你所设计的算法应当可以检测到的后缀与中的字符串匹配。按下述要求实现类：,StreamChecker(String[]words)：构造函数，用字符串数组words初始化数据结构。booleanquery(charletter)：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配words中的某一字符串，返回true；否则，返回false1<=words.length<=20001<=words[i].length<=200words[i]由小写英文字母组成letter是一个小写英文字母最多调用查询4*10,1,5
875,199,2,0,题库,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,三枚石子放置在数轴上，位置分别为，，。每一回合，你可以从两端之一拿起一枚石子（位置最大或最小），并将其放入两端之间的任一空闲位置。形式上，假设这三枚石子当前分别位于位置且。那么就可以从位置或者是位置拿起一枚石子，并将该石子移动到某一整数位置处，其中且。当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。要使游戏结束，你可以执行的最小和最大移动次数分别是多少？以长度为2的数组形式返回答案：,,1,2
876,152,3,134,题库,2,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的整数矩阵，表示一个网格。另给你三个整数、和。网格中的每个值表示该位置处的网格块的颜色。如果两个方块在任意4个方向上相邻，则称它们。如果两个方块具有相同的颜色且相邻，它们则属于同一个。是指连通分量中满足下述条件之一的所有网格块：请你使用指定颜色为所有包含网格块的进行着色。并返回最终的网格。,"在上、下、左、右任意一个方向上与不属于同一连通分量的网格块相邻在网格的边界上（第一行/列或最后一行/列）m==grid.lengthn==grid[i].length1<=m,n<=501<=grid[i][j],color<=10000<=row<m0<=col<n",1,4
877,111,3,100,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在两条独立的水平线上按给定的顺序写下和中的整数。现在，可以绘制一些连接两个数字和的直线，这些直线需要同时满足满足：请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。,"nums1[i]==nums2[j]且绘制的直线不与任何其他连线（非水平线）相交。1<=nums1.length,nums2.length<=5001<=nums1[i],nums2[j]<=2000",1,2
878,160,2,135,题库,1,2,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,在一个10x10的网格中，每个网格上方格的坐标为。现在从源方格开始出发，意图赶往目标方格。数组是封锁的方格列表，其中每个表示坐标为的方格是禁止通行的。每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格在给出的封锁列表上。同时，不允许走出网格。只有在可以通过一系列的移动从源方格到达目标方格时才返回。否则，返回。,"0<=blocked.length<=200blocked[i].length==20<=x,y<10source.length==target.length==20<=s,s,t,t<10source!=target题目数据保证source和target不在封锁列表内",1,4
879,37,2,46,题库,1,0,0,0,0,2,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个数组，其中表示平面上的一个点，则返回。定义为一组三个点，这些点且。,"points.length==3points[i].length==20<=x,y<=100",1,3
880,35,2,96,题库,0,1,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,(BST)节点节点节点提醒一下，满足下列约束条件：该题目与538:相同,"节点的左子树仅包含键小于节点键的节点。节点的右子树仅包含键大于节点键的节点。左右子树也必须是二叉搜索树。树中的节点数在[1,100]范围内。0<=Node.val<=100树中的所有值均不重复",1,4
881,108,3,41,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"你有一个凸的边形，其每个顶点都有一个整数值。给定一个整数数组，其中是第个顶点的值（即）。假设将多边形为个三角形。对于每个三角形，该三角形的值是顶点标记的，三角剖分的分数是进行三角剖分后所有个三角形的值之和。返回。
",n==values.length3<=n<=501<=values[i]<=100,1,2
882,226,3,56,题库,2,0,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个长度的数轴上，第颗石子的位置为。如果一颗石子的位置最小/最大，那么该石子被称作。每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。值得注意的是，如果石子像这样，你将移动位于位置5的端点石子，因为无论将它移动到任何位置（例如0或3），该石子都仍然会是端点石子。当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。要使游戏结束，你可以执行的最小和最大移动次数分别是多少？以长度为2的数组形式返回答案：。,3<=stones.length<=10^41<=stones[i]<=10^9stones[i]的值各不相同。,1,4
883,91,3,128,题库,2,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在无限的平面上，机器人最初位于处，面朝北方。注意:机器人可以接受下列三条指令之一：机器人按顺序执行指令，并一直重复它们。只有在平面中存在环使得机器人永远无法离开时，返回。否则，返回。,"北方向是y轴的正方向。南方向是y轴的负方向。东方向是x轴的正方向。西方向是x轴的负方向。""G""：直走1个单位""L""：左转90度""R""：右转90度1<=instructions.length<=100instructions[i]仅包含'G','L','R'",1,3
884,109,3,74,题库,0,2,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个花园，按从到标记。另有数组，其中描述了花园到花园的双向路径。在每个花园中，你打算种下四种花之一。另外，所有花园有条路径可以进入或离开.你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。,"1<=n<=100<=paths.length<=2*10paths[i].length==21<=x,y<=n!=y每个花园有条路径可以进入或离开",1,3
885,109,3,47,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你将该数组分隔为长度为k的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个32位整数。,1<=arr.length<=5000<=arr[i]<=101<=k<=arr.length,1,2
886,78,2,26,题库,1,1,0,1,3,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，考虑其所有：即的（连续）子串，在中出现2次或更多次。这些出现之间可能存在重叠。返回可能具有最长长度的重复子串。如果不含重复子串，那么答案为。,2<=s.length<=3*10由小写英文字母组成,1,6
887,36,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表：表：写一条SQL查询语句，从表中查询购买了表中所有产品的客户的id。,,1,1
888,105,1,95,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有一堆石头，每块石头的重量都是正整数。每一回合，从中选出两块石头，然后将它们一起粉碎。假设石头的重量分别为和，且。那么粉碎的可能结果如下：最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回。,如果x==y，那么两块石头都会被完全粉碎；如果x!=y，那么重量为的石头将会完全粉碎，而重量为的石头新重量为y-x1<=stones.length<=301<=stones[i]<=1000,1,2
889,87,1,0,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给出由小写字母组成的字符串，会选择两个相邻且相同的字母，并删除它们。在S上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。,,1,2
890,118,3,94,题库,2,1,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给出一个单词数组，其中每个单词都由小写英文字母组成。如果我们可以，在的任何地方添加字母使其变成，那么我们认为是的。是单词组成的序列，，其中是的前身，是的前身，依此类推。一个单词通常是的。从给定单词列表中选择单词组成词链，返回词链的。
","例如，""abc""是""abac""的，而""cba""不是""bcad""的1<=words.length<=10001<=words[i].length<=16words[i]仅由小写英文字母组成。",1,5
891,97,2,94,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,有一堆石头，用整数数组表示。其中表示第块石头的重量。每一回合，从中选出，然后将它们一起粉碎。假设石头的重量分别为和，且。那么粉碎的可能结果如下：最后，石头。返回此石头。如果没有石头剩下，就返回。,如果x==y，那么两块石头都会被完全粉碎；如果x!=y，那么重量为的石头将会完全粉碎，而重量为的石头新重量为y-x1<=stones.length<=301<=stones[i]<=100,1,2
892,21,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：查询合作过至少三次的演员和导演的id对,,1,1
893,115,3,40,题库,3,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照的高度顺序排成一行。排序后的高度情况用整数数组表示，其中是预计排在这一行中第位的学生的高度（）。给你一个整数数组，表示的高度情况。是这一行中第位学生的高度（）。返回满足的。,1<=heights.length<=1001<=heights[i]<=100,1,3
894,202,2,89,题库,1,0,0,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"有一个书店老板，他的书店开了分钟。每分钟都有一些顾客进入这家商店。给定一个长度为的整数数组，其中是在第分钟开始时进入商店的顾客数量，所有这些顾客在第分钟结束后离开。在某些时候，书店老板会生气。如果书店老板在第分钟生气，那么，否则。当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续分钟不生气，但却只能使用一次。请你返回。
",n==customers.length==grumpy.length1<=minutes<=n<=2*100<=customers[i]<=1000grumpy[i]==0or1,1,2
895,74,3,30,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组（可能存在重复的元素），请你返回可在（交换两数字和的位置）后得到的、按字典序排列小于的最大排列。如果无法这么操作，就请返回原数组。,1<=arr.length<=101<=arr[i]<=10,1,2
896,78,2,46,题库,2,1,2,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个仓库里，有一排条形码，其中第个条形码为。请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。你可以返回任何满足该要求的答案，此题保证存在答案。,1<=barcodes.length<=100001<=barcodes[i]<=10000,1,6
897,131,3,210,题库,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,"给出长度相同的两个字符串和，还有一个字符串。其中和是一组等价字符。等价字符遵循任何等价关系的一般规则：例如，和的等价信息和之前的例子一样，那么,或，这三个字符串都是等价的，而是的按字典序最小的等价字符串利用和的等价信息，找出并返回的按字典序排列最小的等价字符串。","举个例子，如果s1=""abc""且s2=""cde""，那么就有'a'=='c','b'=='d','c'=='e'自反性'a'=='a'对称性'a'=='b'则必定有'b'=='a'传递性'a'=='b'且'b'=='c'就表明'a'=='c'1<=s1.length,s2.length,baseStr<=1000s1.length==s2.length字符串,andbaseStr仅由从'a'到'z'的小写英文字母组成。",1,2
898,64,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,销售表：产品表：写一条SQL查询语句获取表中所有产品对应的以及该产品的所有和。查询结果中的顺序无特定要求。查询结果格式示例如下：,,1,1
899,58,1,0,题库,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,销售表：产品表：编写一个SQL查询，选出每个销售产品销售的、、和。结果表中的条目可以按排列。查询结果格式如下例所示：,,1,1
900,46,3,50,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,对于字符串和，只有在（自身连接1次或多次）时，我们才认定“能除尽”。给定两个字符串和。返回。,"1<=str1.length,str2.length<=1000str1和str2由大写英文字母组成",1,2
901,53,3,62,题库,2,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定矩阵。你可以从中选出任意数量的列并翻转其上的单元格。（即翻转后，单元格的值从变成，或者从变为。）返回。,"m==matrix.lengthn==matrix[i].length1<=m,n<=300matrix[i][j]==0或",1,3
902,123,3,65,题库,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给出基数为的两个数和，返回两数相加的结果。数字以给出：数组由若干0和1组成，按最高有效位到最低有效位的顺序排列。例如，表示数字。中的数字也同样不含前导零：即或。返回相同表示形式的和相加的结果。两数的表示形式为：不含前导零、由若干0和1组成的数组。,"1<=arr1.length,arr2.length<=1000arr1[i]和arr2[i]都是或arr1和arr2都没有前导0",1,2
903,78,3,86,题库,2,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给出矩阵和目标值，返回元素总和等于目标值的非空子矩阵的数量。子矩阵是满足且的所有单元的集合。如果和两个子矩阵中部分坐标不同（如：），那么这两个子矩阵也不同。,1<=matrix.length<=1001<=matrix[0].length<=100-1000<=matrix[i]<=1000-10^8<=target<=10^8,1,4
904,45,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,项目表：员工表：请写一个SQL语句，查询每一个项目中员工的工作年限，。查询结果的格式如下：,,1,1
905,73,2,112,题库,1,0,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给出第一个词和第二个词，考虑在某些文本中可能以形式出现的情况，其中紧随出现，紧随出现。对于每种这样的情况，将第三个词""""添加到答案中，并返回答案。","1<=text.length<=1000text由小写英文字母和空格组成text中的所有单词之间都由单个空格字符分隔1<=first.length,second.length<=10first和second由小写英文字母组成",1,1
906,59,3,32,题库,1,1,1,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有一套活字字模，其中每个字模上都刻有一个字母。返回你可以印出的非空字母序列的数目。本题中，每个活字字模只能使用一次。,1<=tiles.length<=7tiles由大写英文字母组成,1,4
907,98,3,48,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根节点和一个整数，请你同时删除树中所有，并返回最终二叉树的根节点。假如通过节点的每种可能的“根-叶”路径上值的总和全都小于给定的，则该节点被称之为，需要被删除。，就是没有子节点的节点。,"树中节点数目在范围[1,5000]-10<=Node.val<=10-10<=limit<=10",1,3
908,41,2,26,题库,1,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,返回字典序最小的子序列，该子序列包含的所有不同字符，且只包含一次。该题与316相同,1<=s.length<=1000由小写英文字母组成,1,4
909,63,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,Table:Table:编写一个SQL查询，报告才售出的产品。即在至（含）之间出售的商品。以返回结果表。查询结果格式如下所示。,,1,1
910,93,2,29,题库,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个长度固定的整数数组，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。注意：请不要在超过该数组长度的位置写入元素。请对输入的数组进行上述修改，不要从函数返回任何东西。,1<=arr.length<=100<=arr[i]<=9,1,2
911,78,3,129,题库,2,1,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们有一个项的集合。给出两个整数数组和，第个元素的值和标签分别是和。还会给出两个整数和。从个元素中选择一个子集:一个子集的是该子集的值之和。返回子集的最大。,"子集的大小小于或等于numWanted中有相同标签的useLimit项。n==values.length==labels.length1<=n<=2*100<=values[i],labels[i]<=2*101<=numWanted,useLimit<=n",1,5
912,99,3,116,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的二进制矩阵中，返回矩阵中最短的长度。如果不存在这样的路径，返回。二进制矩阵中的畅通路径是一条从单元格（即，）到右下角单元格（即，）的路径，该路径同时满足下述要求：是该路径途经的单元格总数。,路径途经的所有单元格的值都是路径中所有相邻的单元格应当在8个方向之一上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。n==grid.lengthn==grid[i].length1<=n<=100grid[i][j]为或,1,3
913,88,2,52,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个字符串和，返回同时以和作为的最短字符串。如果答案不止一个，则可以返回满足条件的答案。如果从字符串中删除一些字符（也可能不删除），可以得到字符串，那么就是t的一个子序列。,"1<=str1.length,str2.length<=1000str1和str2都由小写英文字母组成。",1,2
914,85,2,232,题库,1,0,0,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,我们对到之间的整数进行采样，并将结果存储在数组中：就是整数在样本中出现的次数。计算以下统计数据:以浮点数数组的形式返回样本的统计信息。与真实答案误差在内的答案都可以通过。,minimum：样本中的最小元素。maximum：样品中的最大元素。mean：样本的平均值，计算为所有元素的总和除以元素总数。median如果样本的元素个数是奇数，那么一旦样本排序后，中位数median就是中间的元素。如果样本中有偶数个元素，那么中位数median就是样本排序后中间两个元素的平均值。mode：样本中出现次数最多的数字。保众数是的。count.length==2560<=count[i]<=101<=sum(count)<=10count的众数是,1,3
915,113,2,91,题库,3,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"车上最初有个空座位。车向一个方向行驶（也就是说，）给定整数和一个数组,表示第次旅行有乘客，接他们和放他们的位置分别是和。这些位置是从汽车的初始位置向东的公里数。当且仅当你可以在所有给定的行程中接送所有乘客时，返回，否则请返回。",1<=trips.length<=1000trips[i].length==31<=numPassengers<=1000<=from<to<=10001<=capacity<=10,1,5
916,183,2,204,题库,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,（这是一个）给你一个，请你返回能够使得的下标值。如果不存在这样的下标，就请返回。何为山脉数组？如果数组是一个山脉数组的话，那它满足如下条件：，，在条件下，存在使得：你将，必须通过接口来获取数据：对发起超过次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。为了帮助大家更好地理解交互式问题，我们准备了一个样例“”：，请注意这。,A[0]<A[1]<...A[i-1]<A[i]A[i]>A[i+1]>...>A[A.length-1]MountainArray.get(k)-会返回数组中索引为的元素（下标从0开始）MountainArray.length()-会返回该数组的长度3<=mountain_arr.length()<=100000<=target<=10^90<=mountain_arr.get(index)<=10^9,1,3
917,144,2,561,题库,1,2,1,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,如果你熟悉Shell编程，那么一定了解过花括号展开，它可以用来生成任意字符串。花括号展开的表达式可以看作一个由、和组成的字符串，定义下面几条语法规则：给出表示基于给定语法规则的表达式，返回它所表示的所有字符串组成的有序列表。假如你希望以「集合」的概念了解此题，也可以通过点击“”获取详情。,"如果只给出单一的元素，那么表达式表示的字符串就只有""x""R(x)={x}例如，表达式""a""表示字符串""a""而表达式""w""就表示字符串""w""当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。R({e_1,e_2,...})=R(e_1)∪R(e_2)∪...例如，表达式""{a,b,c}""表示字符串""a"",""b"",""c""而表达式""{{a,b},{b,c}}""也可以表示字符串""a"",""b"",""c""要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。R(e_1+e_2)={a+bfor(a,b)inR(e_1)×R(e_2)}例如，表达式""{a,b}{c,d}""表示字符串""ac"",""ad"",""bc"",""bd""例如，表达式""a{b,c,d}""表示字符串""ab"",""ac"",""ad""​​​​​​例如，表达式""a{b,c}{d,e}f{g,h}""可以表示字符串""abdfg"",""abdfh"",""abefg"",""abefh"",""acdfg"",""acdfh"",""acefg"",""acefh""1<=expression.length<=60expression[i]由'{''}'','或小写英文字母组成给出的表达式expression用以表示一组基于题目描述中语法构造的字符串",1,4
918,272,2,35,题库,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,排排坐，分糖果。我们买了一些糖果，打算把它们分给排好队的个小朋友。给第一个小朋友1颗糖果，第二个小朋友2颗，依此类推，直到给最后一个小朋友颗糖果。然后，我们再回到队伍的起点，给第一个小朋友颗糖果，第二个小朋友颗，依此类推，直到给最后一个小朋友颗糖果。重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。返回一个长度为、元素之和为的数组，以表示糖果的最终分发情况（即表示第个小朋友分到的糖果数）。,1<=candies<=10^91<=num_people<=1000,1,2
919,168,2,14,题库,0,0,2,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点依次按“之”字形进行标记。如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。给你树上某一个节点的标号，请你返回从根节点到该标号为节点的路径，该路径是由途经的节点标号所组成的。,1<=label<=10^6,1,3
920,188,2,137,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个数组，其中表示第本书的厚度和高度。你也会得到一个整数。将这些书摆放到总宽度为的书架上。先选几本书放在书架上（它们的厚度之和小于等于书架的宽度），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。需要注意的是，在上述过程的每个步骤中，。每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。以这种方式布置书架，返回书架整体可能的最小高度。,例如，如果这里有5本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。1<=books.length<=10001<=thickness<=shelfWidth<=10001<=height<=1000,1,2
921,83,3,308,题库,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,是计算结果不是就是的表达式。有效的表达式需遵循以下约定：给你一个以字符串形式表述的，返回该式的运算结果。题目测试用例所给出的表达式均为有效的布尔表达式，遵循上述约定。,"'t'，运算结果为true'f'，运算结果为false'!(subExpr)'，运算过程为对内部表达式subExpr进行逻辑非（NOT）运算'&(subExpr,subExpr,...,subExpr，运算过程为对2个或以上内部表达式subExpr,subExpr,...,subExpr进行逻辑与（AND）运算'|(subExpr,subExpr,...,subExpr，运算过程为对2个或以上内部表达式subExpr,subExpr,...,subExpr进行逻辑或（OR）运算1<=expression.length<=2*10expression[i]为'('')''&''|''!''t''f'和','之一",1,3
922,46,2,22,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个有效的地址，返回这个IP地址的无效化版本。所谓无效化IP地址，其实就是用代替了每个。,给出的address是一个有效的IPv4地址,1,1
923,84,2,84,题库,1,0,0,0,1,0,0,0,1,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,这里有个航班，它们分别从到进行编号。有一份航班预订表，表中第条预订记录意味着在从到（和）的上预订了个座位。请你返回一个长度为的数组，里面的元素是每个航班预定的座位总数。,1<=n<=2*101<=bookings.length<=2*10bookings[i].length==31<=first<=last<=n1<=seats<=10,1,2
924,94,2,88,题库,1,1,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给出二叉树的根节点，树上每个节点都有一个不同的值。如果节点值在中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。,树中的节点数最大为1000每个节点都有一个介于到1000之间的值，且各不相同。to_delete.length<=1000to_delete包含一些从到1000、各不相同的值。,1,5
925,210,2,167,题库,1,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「」部分。定义：即有效括号字符串嵌套的层数，表示有效括号字符串的嵌套深度。详情参见题末「」部分。有效括号字符串类型与对应的嵌套深度计算方法如下图所示：给你一个「有效括号字符串」，请你将其分成两个不相交的有效括号字符串，和，并使这两个字符串的深度最小。划分方案用一个长度为的答案数组表示，编码规则如下：如果存在多个满足要求的答案，只需返回其中任意即可。,"不相交：每个seq[i]只能分给和二者中的一个，不能既属于也属于或中的元素在原字符串中可以不连续。A.length+B.length=seq.length深度最小：max(depth(A),depth(B))的可能取值最小。answer[i]=0seq[i]分给answer[i]=1seq[i]分给1<seq.size<=10000",1,2
926,60,2,126,题库,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个类：三个不同的线程A、B、C将会共用一个实例。请设计修改程序，以确保方法在方法之后被执行，方法在方法之后被执行。,"线程A将会调用first()方法线程B将会调用second()方法线程C将会调用third()方法尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。你看到的输入格式主要是为了确保测试的全面性。nums是[1,2,3]的一组排列",1,1
927,38,2,40,题库,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个类：两个不同的线程将会共用一个实例：请设计修改程序，以确保被输出次。,线程A将会调用foo()方法，而线程B将会调用bar()方法1<=n<=1000,1,1
928,93,2,244,题库,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现有函数可以用一个整数参数调用，并输出该整数到控制台。给你类的一个实例，该类中有三个函数：、和。的相同实例将会传递给三个不同线程：修改给出的类，以输出序列，其中序列的长度必须为。实现类：,例如，调用printNumber(7)将会输出到控制台。线程A：调用zero()，只输出线程B：调用even()，只输出偶数线程C：调用odd()，只输出奇数ZeroEvenOdd(intn)用数字初始化对象，表示需要输出的数。voidzero(printNumber)调用printNumber以输出一个0。voideven(printNumber)调用printNumber以输出偶数。voidodd(printNumber)调用printNumber以输出奇数。1<=n<=1000,1,1
929,186,2,164,题库,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现在有两种线程，氧和氢，你的目标是组织这两种线程来产生水分子。存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。氢和氧线程会被分别给予和方法来允许它们突破屏障。这些线程应该三三成组突破屏障并能立即组合产生一个水分子。你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。换句话说:书写满足这些限制条件的氢、氧线程同步代码。,如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。3*n==water.length1<=n<=20water[i]=='O'or'H'输入字符串water中的'H'总数将会是2*n输入字符串water中的'O'总数将会是,1,1
930,79,2,100,题库,3,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个数组，和，中的元素各不相同，中的每个元素都出现在中。对中的元素进行排序，使中项的相对顺序和中的相对顺序相同。未在中出现过的元素需要按照升序放在的末尾。,"1<=arr1.length,arr2.length<=10000<=arr1[i],arr2[i]<=1000arr2中的元素arr2[i]各不相同arr2中的每个元素arr2[i]都出现在arr1",1,4
931,33,3,155,题库,0,2,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个有根节点的二叉树，返回它。回想一下：本题与力扣865重复：,"叶节点是二叉树中没有子节点的节点树的根节点的深度，如果某一节点的深度为，那它的子节点的深度就是d+1如果我们假定是一组节点的最近公共祖先中的每个节点都在以为根节点的子树中，且的深度达到此条件下可能的最大值。树中的节点数将在[1,1000]的范围内。0<=Node.val<=1000每个节点的值都是独一无二的。",1,5
932,123,2,34,题库,1,0,3,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一份工作时间表，上面记录着某一位员工每天的工作小时数。我们认为当员工一天中的工作小时数大于小时的时候，那么这一天就是「」。所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格「不劳累的天数」。请你返回「表现良好时间段」的最大长度。,1<=hours.length<=100<=hours[i]<=16,1,5
933,190,2,311,题库,1,1,0,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,作为项目经理，你规划了一份需求的技能清单，并打算从备选人员名单中选出些人组成一个「必要团队」（编号为的备选人员含有一份该备选人员掌握的技能列表）。所谓「必要团队」，就是在这个团队中，对于所需求的技能列表中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：请你返回规模最小的必要团队，团队成员用人员编号表示。你可以按返回答案，题目数据保证答案存在。,"例如，团队team=[0,1,3]表示掌握技能分别为people[0]people[1]，和people[3]的备选人员。1<=req_skills.length<=161<=req_skills[i].length<=16req_skills[i]由小写英文字母组成req_skills中的所有字符串互不相同1<=people.length<=600<=people[i].length<=161<=people[i][j].length<=16people[i][j]由小写英文字母组成people[i]中的所有字符串互不相同people[i]中的每个技能是req_skills中的技能题目数据保证「必要团队」一定存在",1,4
934,102,1,45,题库,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由一些多米诺骨牌组成的列表。如果其中某一张多米诺骨牌可以通过旋转度或度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。形式上，和等价的前提是且，或是且。在的前提下，找出满足和等价的骨牌对的数量。,1<=dominoes.length<=400001<=dominoes[i][j]<=9,1,3
935,117,2,178,题库,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数，即有向图中的节点数，其中节点标记为到。图中的每条边为红色或者蓝色，并且可能存在自环或平行边。给定两个数组和，其中：返回长度为的数组，其中是从节点到节点的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么。,"redEdges[i]=[a,b表示图中存在一条从节点到节点的红色有向边，blueEdges[j]=[u,v表示图中存在一条从节点到节点的蓝色有向边。1<=n<=1000<=redEdges.length,blueEdges.length<=400redEdges[i].length==blueEdges[j].length==20<=a,b,u,v<n",1,2
936,91,2,121,题库,1,2,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，考虑所有满足以下条件的二叉树：在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个32位整数。如果一个节点有0个子节点，那么该节点为叶节点。,每个节点都有个或是个子节点。数组arr中的值与树的中序遍历中每个叶节点的值一一对应。每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。2<=arr.length<=401<=arr[i]<=15答案保证是一个32位带符号整数，即小于,1,5
937,34,2,62,题库,1,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个长度相等的整数数组，返回下面表达式的最大值：其中下标，满足。,"2<=arr1.length==arr2.length<=40000-10^6<=arr1[i],arr2[i]<=10^6",1,2
938,61,2,36,题库,0,2,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"泰波那契序列T定义如下：T=0,T=1,T=1,且在n>=0的条件下T=T+T+T给你整数，请返回第n个泰波那契数T的值。",0<=n<=37答案保证是一个32位整数，即answer<=2^31-1,1,3
939,113,2,171,题库,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们从一块字母板上的位置出发，该坐标对应的字符为。在本题里，字母板为，如下所示。我们可以按下面的指令规则行动：（注意，字母板上只存在有字母的位置。）返回指令序列，用最小的行动次数让答案和目标相同。你可以返回任何达成目标的路径。,"如果方格存在，'U'意味着将我们的位置上移一行；如果方格存在，'D'意味着将我们的位置下移一行；如果方格存在，'L'意味着将我们的位置左移一列；如果方格存在，'R'意味着将我们的位置右移一列；'!'会把在我们当前位置(r,c)的字符board[r][c]添加到答案中。1<=target.length<=100target仅含有小写英文字母。",1,2
940,58,2,53,题库,2,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由若干和组成的二维网格，请你找出边界全部由组成的最大子网格，并返回该子网格中的元素数量。如果不存在，则返回。,1<=grid.length<=1001<=grid[0].length<=100grid[i][j]为或,1,3
941,158,2,35,题库,1,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,爱丽丝和鲍勃继续他们的石子游戏。许多堆石子，每堆都有正整数颗石子。游戏以谁手中的石子最多来决出胜负。爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，。在每个玩家的回合中，该玩家可以拿走剩下的堆的所有石子，其中。然后，令。游戏一直持续到所有石子都被拿走。假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。,1<=piles.length<=1001<=piles[i]<=10,1,4
942,78,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,活动记录表：请写SQL查询出截至（包含2019-07-27），近天的每日活跃用户数（当天只要有一条活动记录，即为活跃用户）。以返回结果表。查询结果示例如下。,,1,1
943,123,3,97,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和，返回这两个字符串的最长的长度。如果不存在，返回。一个字符串的是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。两个字符串的是这两个字符串所共同拥有的子序列。,"例如，""ace""是""abcde""的子序列，但""aec""不是""abcde""的子序列。1<=text1.length,text2.length<=1000text1和text2仅由小写英文字符组成。",1,2
944,61,2,137,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，每次会从中选择一个元素并。如果符合下列情况之一，则数组就是：返回将数组转换为锯齿数组所需的最小操作次数。,每个偶数索引对应的元素都大于相邻的元素，即A[0]>A[1]<A[2]>A[3]<A[4]>...或者，每个奇数索引对应的元素都大于相邻的元素，即A[0]<A[1]>A[2]<A[3]>A[4]<...1<=nums.length<=10001<=nums[i]<=1000,1,2
945,335,2,100,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点，树上总共有个节点，且为奇数，其中每个节点上的值从到各不相同。最开始时：「一号」玩家给值为的节点染上红色，而「二号」玩家给值为的节点染上蓝色。之后两位玩家轮流进行操作，「一号」玩家先手。每一回合，玩家选择一个被他染过色的节点，将所选节点一个的邻节点（即左右子节点、或父节点）进行染色（「一号」玩家染红色，「二号」玩家染蓝色）。如果（且仅在此种情况下）当前玩家无法找到这样的节点来染色时，其回合就会被跳过。若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利✌️。现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个值可以确保你赢得这场游戏，则返回；若无法获胜，就请返回。,"「一号」玩家从[1,n]中取一个值1<=x<=n「二号」玩家也从[1,n]中取一个值1<=y<=n）且y!=x树中节点数目为1<=x<=n<=100是奇数1<=Node.val<=n树中所有值互不相同",1,3
946,30,1,303,题库,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,实现支持下列接口的「快照数组」-SnapshotArray：,"SnapshotArray(intlength)-初始化一个与指定长度相等的类数组的数据结构。初始时，每个元素都等于voidset(index,val)-会将指定索引index处的元素设置为valintsnap()-获取该数组的快照，并返回快照的编号snap_id（快照号是调用snap()的总次数减去intget(index,snap_id)-根据指定的snap_id选择快照，并返回该快照指定索引index的值。1<=length<=50000题目最多进行50000setsnap，和get的调用。0<=index<length0<=snap_id<我们调用snap()的总次数0<=val<=10^9",1,4
947,36,3,139,题库,1,2,0,0,3,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,你会得到一个字符串。你应该把它分成个子字符串，要求满足:返回可能最大值。,subtext非空字符串所有子字符串的连接等于text(即subtext+subtext+...+subtext==text对于所有的有效值(即1<=i<=k)，subtext==subtextk-i+1均成立1<=text.length<=1000text仅由小写英文字符组成,1,6
948,39,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：请查询出所有浏览过自己文章的作者结果按照升序排列。查询结果的格式如下所示：,,1,1
949,31,2,82,题库,1,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，按格式表示一个日期。返回该日期是当年的第几天。,date.length==10date[4]==date[7]=='-'，其他的date[i]都是数字date表示的范围从1900年1月1日至2019年12月31日,1,2
950,85,3,25,题库,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"这里有个一样的骰子，每个骰子上都有个面，分别标号为到。给定三个整数,和，返回可能的方式(从总共种方式中)滚动骰子的数量，使正面朝上的数字之和等于。答案可能很大，你需要对。","1<=n,k<=301<=target<=1000",1,1
951,90,5,36,题库,1,0,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。给你一个字符串，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。,1<=text.length<=20000text仅由小写英文字母组成。,1,3
952,48,1,268,题库,1,1,0,2,0,0,1,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,设计一个数据结构，有效地找到给定子数组的。子数组的是在子数组中出现次数或次数以上的元素。实现类:,"MajorityChecker(int[]arr)会用给定的数组arr对MajorityChecker初始化。intquery(intleft,intright,intthreshold)返回子数组中的元素arr[left...right]至少出现threshold次数，如果不存在这样的元素则返回1<=arr.length<=2*101<=arr[i]<=2*100<=left<=right<arr.lengththreshold<=right-left+12*threshold>right-left+1调用query的次数最多为",1,5
953,69,1,0,题库,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Table:Table:Table:请写出一条SQL语句以查询每个用户的注册日期和在年作为买家的订单总数。以返回结果表。查询结果格式如下。,,1,1
954,131,2,0,题库,2,0,1,0,0,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一份『词汇表』（字符串数组）和一张『字母表』（字符串）。假如你可以用中的『字母』（字符）拼写出中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。注意：每次拼写（指拼写词汇表中的一个单词）时，中的每个字母都只能用一次。返回词汇表中你掌握的所有单词的。,,1,3
955,77,2,32,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二叉树的根节点。设根节点位于二叉树的第层，而根节点的子节点位于第层，依此类推。请返回层内元素之和的那几层（可能只有一层）的层号，并返回其中的那个。,"树中的节点数在[1,10范围内-10<=Node.val<=10",1,4
956,156,2,54,题库,2,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你现在手里有一份大小为的网格，上面的每个单元格都用和标记好了。其中代表海洋，代表陆地。请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回。我们这里说的距离是「曼哈顿距离」（ManhattanDistance）：和这两个单元格之间的距离是。,n==grid.lengthn==grid[i].length1<=n<=100grid[i][j]不是就是,1,4
957,36,2,27,题库,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，找出它的所有子串并按字典序排列，返回排在最后的那个子串。,1<=s.length<=4*10仅含有小写英文字符。,1,2
958,59,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,产品数据表:写一段SQL来查找在时全部产品的价格，假设所有产品在修改前的价格都是以返回结果表。查询结果格式如下例所示。,,1,1
959,99,3,235,题库,3,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果出现下述两种情况，交易：给定字符串数组交易清单。每个交易字符串由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。返回，返回可能无效的交易列表。你可以按返回答案。,"交易金额超过$1000或者，它和另一个城市中的另一笔交易相隔不超过分钟（包含60分钟整）transactions.length<=1000每笔交易transactions[i]按""{name},{time},{amount},{city}""的格式进行记录每个交易名称{name}和城市{city}都由小写英文字母组成，长度在到之间每个交易时间{time}由一些数字组成，表示一个到1000之间的整数每笔交易金额{amount}由一些数字组成，表示一个到2000之间的整数",1,4
960,123,2,118,题库,3,1,1,0,0,0,0,0,0,0,1,1,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,定义一个函数，统计中，其中是一个非空字符串。例如，若，那么，因为字典序最小字母是，它出现了2次。现在，给你两个字符串数组待查表和词汇表。对于每次查询，需统计中满足<的，表示词汇表中的每个词。请你返回一个整数数组作为答案，其中每个是第次查询的结果。,"1<=queries.length<=20001<=words.length<=20001<=queries[i].length,words[i].length<=10queries[i][j]words[i][j]都由小写英文字母组成",1,5
961,118,3,55,题库,0,0,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表的头节点，请你编写代码，反复删去链表中由值为的连续节点组成的序列，直到不存在这样的序列为止。删除完毕后，请你返回最终结果链表的头节点。你可以返回任何满足题目要求的答案。（注意，下面示例中的所有序列，都是对对象序列化的表示。）,给你的链表中可能有到1000个节点。对于链表中的每个节点，节点的值：-1000<=node.val<=1000,1,2
962,55,1,282,题库,0,0,3,0,0,0,1,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,我们把无限数量∞的栈排成一行，按从左到右的次序从0开始编号。每个栈的的最大容量都相同。实现一个叫「餐盘」的类：,DinnerPlates(intcapacity)-给出栈的最大容量capacityvoidpush(intval)-将给出的正整数val推入从左往右第一个没有满的栈。intpop()-返回从右往左第一个非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回intpopAtStack(intindex)-返回编号index的栈顶部的值，并将其从栈中删除；如果编号index的栈是空的，请返回1<=capacity<=200001<=val<=200000<=index<=100000最多会对pushpop，和popAtStack进行200000次调用。,1,4
963,69,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,配送表:如果顾客期望的配送日期和下单日期相同，则该订单称为「即时订单」，否则称为「计划订单」。查询即时订单所占的百分比，查询结果如下所示。,,1,1
964,124,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,配送表:如果顾客期望的配送日期和下单日期相同，则该订单称为「即时订单」，否则称为「计划订单」。「首次订单」是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。写一条SQL查询语句获取即时订单在所有用户的首次订单中的比例。查询结果如下所示：,,1,1
965,132,2,9,题库,0,0,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,请你帮忙给从到的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从1开始）上；你需要返回可能的方案总数。让我们一起来回顾一下「质数」：质数一定是大于1的，并且不能用两个小于它的正整数的乘积来表示。由于答案可能会很大，所以请你返回答案之后的结果即可。,1<=n<=100,1,1
966,205,1,107,题库,2,0,1,0,2,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你对的子串进行检测。每次检测，待检子串都可以表示为。我们可以子串，并从中选择项替换成任何小写英文字母。如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为，否则结果为。返回答案数组，其中是第个待检子串的检测结果。注意：在替换时，子串中的每个字母都必须作为项进行计数，也就是说，如果且，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串，可以认为每次检测都是独立的）,"1<=s.length,queries.length<=10^50<=queries[i][0]<=queries[i][1]<s.length0<=queries[i][2]<=s.length中只有小写英文字母",1,5
967,120,1,195,题库,2,0,1,1,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。字谜的迷面按字符串形式给出，如果一个单词符合下面两个条件，那么它就可以算作谜底：返回一个答案数组，数组中的每个元素是在给出的单词列表中可以作为字谜迷面所对应的谜底的单词数目。,单词word中包含谜面puzzle的第一个字母。单词word中的每一个字母都可以在谜面puzzle中找到。1<=words.length<=10^54<=words[i].length<=501<=puzzles.length<=10^4puzzles[i].length==7words[i][j]puzzles[i][j]都是小写英文字母。每个puzzles[i]所包含的字符都不重复。,1,5
968,47,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：重新格式化表格，使得都有一个部门id列和一个收入列。以返回结果表。结果格式如以下示例所示。,,1,1
969,104,3,70,题库,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,环形公交路线上有个站，按次序从到进行编号。我们已知每一对相邻公交站之间的距离，表示编号为的车站和编号为的车站之间的距离。环线上的公交车都可以按顺时针和逆时针的方向行驶。返回乘客从出发点到目的地之间的最短距离。,"1<=n<=10^4distance.length==n0<=start,destination<n0<=distance[i]<=10^4",1,1
970,69,3,27,题库,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。输入为三个整数：、和，分别表示日、月、年。您返回的结果必须是这几个值中的一个。,给出的日期一定是在1971到2100年之间的有效日期。,1,1
971,157,3,32,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，返回它的某个子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。注意，删除一个元素后，子数组。,1<=arr.length<=10-10<=arr[i]<=10,1,2
972,90,3,56,题库,2,2,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个整数数组和，返回使严格递增所需要的最小「操作」数（可能为0）。每一步「操作」中，你可以分别从和中各选出一个索引，分别为和，和，然后进行赋值运算。如果无法让严格递增，请返回。,"1<=arr1.length,arr2.length<=20000<=arr1[i],arr2[i]<=10^9",1,4
973,64,3,35,题库,1,0,1,0,1,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，你需要使用中的字母来拼凑尽可能多的单词。字符串中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词。,1<=text.length<=10^4text全部由小写英文字母组成,1,3
974,76,4,48,题库,1,0,1,0,0,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给出一个字符串（仅含有小写英文字母和括号）。请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。注意，您的结果中包含任何括号。,1<=s.length<=2000中只有小写英文字母和括号题目测试用例确保所有括号都是成对出现的,1,2
975,97,3,40,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组和一个整数，通过重复次来修改数组。例如，如果，，那么修改后的数组将是。返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是，在这种情况下它的总和也是。由于，需要返回的的。,1<=arr.length<=101<=k<=10-10<=arr[i]<=10,1,2
976,162,2,57,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,力扣数据中心有台服务器，分别按从到的方式进行了编号。它们之间以的形式相互连接组成了一个内部集群，连接是无向的。用表示集群网络，表示服务器和之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。请你以任意顺序返回该集群内的所有。,"2<=n<=10n-1<=connections.length<=100<=a,b<=n-1!=b不存在重复的连接",1,3
977,70,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Table:编写一个sql查询来查找每个月和每个国家/地区的事务数及其总金额、已批准的事务数及其总金额。以返回结果表。查询结果格式如下所示。,,1,1
978,80,1,125,题库,0,0,0,0,0,0,1,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,编写一个可以从1到n输出代表这个数字的字符串的程序，但是：例如，当，输出：。假设有这么一个类：请你实现一个有四个线程的多线程版，同一个实例会被如下四个线程使用：,"如果这个数字可以被3整除，输出""fizz""。如果这个数字可以被5整除，输出""buzz""。如果这个数字可以同时被3和5整除，输出""fizzbuzz""。本题已经提供了打印字符串的相关方法，如printFizz()等，具体方法名请参考答题模板中的注释部分。",1,1
979,54,3,76,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你个整数数组，其中每个元素都。请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。每对元素对]如下：,"a,b均为数组arr中的元素a<bb-a等于arr中任意两个元素的最小绝对差2<=arr.length<=10^5-10^6<=arr[i]<=10^6",1,2
980,37,4,50,题库,0,1,0,0,0,2,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你四个整数：、、、，请你设计一个算法来找出第个丑数。丑数是可以被整除的。,"1<=n,a,b,c<=10^91<=a*b*c<=10^18本题结果在[1,2*10^9]的范围内",1,3
981,92,3,83,题库,1,2,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，以及该字符串中的一些「索引对」数组，其中表示字符串中的两个索引（编号从0开始）。你可以在中任意一对索引处的字符。返回在经过若干次交换后，可以变成的按字典序最小的字符串。,"1<=s.length<=10^50<=pairs.length<=10^50<=pairs[i][0],pairs[i][1]<s.length中只含有小写英文字母",1,5
982,175,2,261,题库,0,2,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,有个项目，每个项目或者不属于任何小组，或者属于个小组之一。表示第个项目所属的小组，如果第个项目不属于任何小组，则等于。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个。,同一小组的项目，排序后在列表中彼此相邻。项目之间存在一定的依赖关系，我们用一个列表beforeItems来表示，其中beforeItems[i]表示在进行第个项目前（位于第个项目左侧）应该完成的所有项目。1<=m<=n<=3*10group.length==beforeItems.length==n-1<=group[i]<=m-10<=beforeItems[i].length<=n-10<=beforeItems[i][j]<=n-1i!=beforeItems[i][j]beforeItems[i]不含重复元素,1,4
983,110,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表:有一队乘客在等着上巴士。然而，巴士有的重量限制，所以其中一部分乘客可能无法上巴士。写一条SQL查询语句找出上巴士且不超过重量限制的乘客，并报告。题目测试用例确保顺位第一的人可以上巴士且不会超重。查询结果格式如下所示。,,1,1
984,242,1,178,题库,0,0,1,0,0,0,1,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"不使用任何库函数，设计一个。是在时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。例如，一个跳表包含，然后增加、到跳表中，以下图的方式操作：
跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过。跳表的每一个操作的平均时间复杂度是，空间复杂度是。了解更多:在本题中，你的设计应该要包含这些函数：注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。","boolsearch(inttarget):返回target是否存在于跳表中。voidadd(intnum):插入一个元素到跳表。boolerase(intnum):在跳表中删除一个值，如果num不存在，直接返回false.如果存在多个num，删除其中任意一个即可。0<=num,target<=2*10searchadd,erase操作次数不大于5*10",1,2
985,54,3,38,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个整数数组，请你帮忙统计数组中每个数的出现次数。如果每个数的出现次数都是独一无二的，就返回；否则返回。,1<=arr.length<=1000-1000<=arr[i]<=1000,1,2
986,185,3,53,题库,1,1,0,0,2,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个长度相同的字符串，和。将中的第个字符变到中的第个字符需要的开销（开销可能为0），也就是两个字符的ASCII码值的差的绝对值。用于变更字符串的最大预算是。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。如果你可以将的子字符串转化为它在中对应的子字符串，则返回可以转化的最大长度。如果中没有子字符串可以转化成中对应的子字符串，则返回。,"1<=s.length,t.length<=10^50<=maxCost<=10^6和都只含小写英文字母。",1,4
987,119,3,38,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，「倍重复项删除操作」将会从中选择个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。你需要对重复进行无限次这样的删除操作，直到无法继续为止。在执行完所有删除操作后，返回最终得到的字符串。本题答案保证唯一。,1<=s.length<=10^52<=k<=10^4中只含有小写英文字母。,1,2
988,148,2,238,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,你还记得那条风靡全球的贪吃蛇吗？我们在一个的网格上构建了新的迷宫地图，蛇的长度为2，也就是说它会占去两个单元格。蛇会从左上角（和）开始移动。我们用表示空单元格，用1表示障碍物。蛇需要移动到迷宫的右下角（和）。每次移动，蛇可以这样走：返回蛇抵达目的地所需的最少移动次数。如果无法到达目的地，请返回。,"如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转90度。蛇从（(r,c)(r,c+1)）移动到（(r,c)(r+1,c)如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转90度。蛇从（(r,c)(r+1,c)）移动到（(r,c)(r,c+1)2<=n<=1000<=grid[i][j]<=1蛇保证从空单元格开始出发。",1,3
989,123,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,查询表：将查询结果的质量定义为：各查询结果的评分与其位置之间比率的平均值。将劣质查询百分比为：评分小于3的查询结果占全部查询结果的百分比。编写一组SQL来查找每次查询的()、()和()。()和()都应四舍五入到小数点后两位。查询结果格式如下所示：,,1,1
990,73,3,115,题库,1,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有个筹码。第个筹码的位置是。我们需要把所有筹码移到同一个位置。在一步中，我们可以将第个筹码的位置从改变为:返回将所有筹码移动到同一位置上所需要的。,position[i]+2或position[i]-2，此时cost=0position[i]+1或position[i]-1，此时cost=11<=position.length<=1001<=position[i]<=10^9,1,3
991,92,3,43,题库,1,1,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你找出并返回中最长等差子序列的长度，该子序列中相邻元素之间的差等于。是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从派生出来的序列。,"1<=arr.length<=10-10<=arr[i],difference<=10",1,3
992,108,2,174,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为的网格进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是。为了使收益最大化，矿工需要按以下规则来开采黄金：,"每当矿工进入一个单元，就会收集该单元格中的所有黄金。矿工每次可以从当前位置向上下左右四个方向走。每个单元格只能被开采（进入）一次。不得开采（进入）黄金数目为的单元格。矿工可以从网格中任意一个有黄金的单元格出发或者是停止。1<=grid.length,grid[i].length<=150<=grid[i][j]<=100最多25个单元格中有黄金。",1,3
993,60,3,142,题库,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，请你帮忙统计一下我们可以按下述规则形成多少个长度为的字符串：由于答案可能会很大，所以请你返回模之后的结果。,字符串中的每个字符都应当是小写元音字母（'a''e''i''o''u'每个元音'a'后面都只能跟着'e'每个元音'e'后面只能跟着'a'或者是'i'每个元音'i'后面再跟着另一个'i'每个元音'o'后面只能跟着'i'或者是'u'每个元音'u'后面只能跟着'a'1<=n<=2*10^4,1,1
994,61,3,49,题库,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,中，和字符的数量是相同的。给你一个平衡字符串，请你将它分割成尽可能多的子字符串，并满足：返回可以通过分割得到的平衡字符串的,每个子字符串都是平衡字符串。2<=s.length<=1000s[i]='L'或'R'是一个字符串,1,3
995,90,3,107,题库,3,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个的棋盘上，放置着若干「黑皇后」和一个「白国王」。给定一个由整数坐标组成的数组，表示黑皇后的位置；以及一对坐标，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。,"1<=queens.length<=63queens[i].length==20<=queens[i][j]<8king.length==20<=king[0],king[1]<8一个棋盘格上最多只能放置一枚棋子。",1,3
996,163,3,44,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一个骰子模拟器会每次投掷的时候生成一个1到6的随机数。不过我们在使用它时有个约束，就是使得投掷骰子时，掷出数字的次数不能超过（从1开始编号）。现在，给你一个整数数组和一个整数，请你来计算掷次骰子可得到的不同点数序列的数量。假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回之后的结果。,1<=n<=5000rollMax.length==61<=rollMax[i]<=15,1,2
997,86,2,61,题库,1,0,1,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个正整数数组，请你帮忙从该数组中找出能满足下面要求的前缀，并返回该前缀的长度：如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是0次）。,从前缀中恰好删除一个元素后，剩下每个数字的出现次数都相同。2<=nums.length<=101<=nums[i]<=10,1,2
998,383,1,147,题库,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,5个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5个哲学家，5根叉子）所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。哲学家从到按编号。请实现函数：给你5个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。,philosopher哲学家的编号。pickLeftFork和pickRightFork表示拿起左边或右边的叉子。eat表示吃面。putLeftFork和putRightFork表示放下左边或右边的叉子。由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。1<=n<=60,1,1
999,90,2,54,题库,0,1,0,0,0,2,1,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有位乘客即将登机，飞机正好有个座位。第一位乘客的票丢了，他随便选了一个座位坐下。剩下的乘客将会：如果他们自己的座位还空着，就坐到自己的座位上，第位乘客坐在自己的座位上的概率是多少？,如果他们自己的座位还空着，就坐到自己的座位上，当他们自己的座位被占用时，随机选择其他座位1<=n<=10^5,1,4
1000,50,2,117,题库,1,0,0,0,0,2,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个数组，其中，表示横坐标为、纵坐标为的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。,"2<=coordinates.length<=1000coordinates[i].length==2-10^4<=coordinates[i][0],coordinates[i][1]<=10^4coordinates中不含重复的点",1,3
1001,113,3,152,题库,2,0,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你是一位系统管理员，手里有一份文件夹列表，你的任务是要删除该列表中的所有，并以返回剩下的文件夹。如果文件夹位于另一个文件夹下，那么就是的。文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：后跟一个或者多个小写英文字母。,"例如，""/leetcode""和""/leetcode/problems""都是有效的路径，而空字符串和""/""不是。1<=folder.length<=4*102<=folder[i].length<=100folder[i]只包含小写字母和'/'folder[i]总是以字符'/'起始folder每个元素都是",1,3
1002,165,4,49,题库,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个只含有四种字符，且长度为的字符串。假如在该字符串中，这四个字符都恰好出现次，那么它就是一个「平衡字符串」。给你一个这样的字符串，请通过「替换一个子串」的方式，使原字符串变成一个「平衡字符串」。你可以用和「待替换子串」长度相同的其他字符串来完成替换。请返回待替换子串的最小可能长度。如果原字符串自身就是一个平衡字符串，则返回。,1<=s.length<=10^5s.length是的倍数中只含有'Q''W''E''R'四种字符,1,2
1003,152,3,108,题库,2,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你打算利用空闲时间来做兼职工作赚些零花钱。这里有份兼职工作，每份工作预计从开始到结束，报酬为。给你一份兼职工作表，包含开始时间，结束时间和预计报酬三个数组，请你计算并返回可以获得的最大报酬。注意，时间上出现重叠的2份工作不能同时进行。如果你选择的工作在时间结束，那么你可以立刻进行在时间开始的下一份工作。,1<=startTime.length==endTime.length==profit.length<=5*10^41<=startTime[i]<endTime[i]<=10^91<=profit[i]<=10^4,1,4
1004,109,2,302,题库,0,1,0,0,1,1,1,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个函数和一个目标结果，函数公式未知，请你计算方程所有可能的正整数和。满足条件的结果数对可以按任意顺序返回。尽管函数的具体式子未知，但它是单调递增函数，也就是说：函数接口定义如下：你的解决方案将按如下规则进行评判：,"f(x,y)<f(x+1,y)f(x,y)<f(x,y+1)判题程序有一个由CustomFunction的种实现组成的列表，以及一种为特定的生成所有有效数对的答案的方法。判题程序接受两个输入：function_id（决定使用哪种实现测试你的代码）以及目标结果判题程序将会调用你实现的findSolution并将你的结果与答案进行比较。如果你的结果与答案相符，那么解决方案将被视作正确答案，即Accepted1<=function_id<=91<=z<=100题目保证f(x,y)==z的解处于1<=x,y<=1000的范围内。1<=x,y<=1000的前提下，题目保证f(x,y)是一个32位有符号整数。",1,4
1005,26,2,83,题库,0,1,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和。你的任务是返回任意的排列，并且满足：,p[0]=startp[i]和p[i+1]的二进制表示形式只有一位不同p[0]和p[2^n-1]的二进制表示形式也只有一位不同1<=n<=160<=start<2^n,1,3
1006,88,3,53,题库,2,1,0,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串数组，字符串是将的含有的字符串所得的字符串。请返回所有可行解中最长长度。是一种可以从另一个数组派生而来的数组，通过删除某些元素或不删除元素而不改变其余元素的顺序。,1<=arr.length<=161<=arr[i].length<=26arr[i]中只含有小写英文字母,1,4
1007,121,3,16,题库,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。房子的客厅大小为x，为保持极简的风格，需要使用尽可能少的瓷砖来铺盖地面。假设正方形瓷砖的规格不限，边长都是整数。请你帮设计师计算一下，最少需要用到多少块方形瓷砖？,1<=n<=131<=m<=13,1,1
1008,176,3,63,题库,1,1,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有两个长度相同的字符串和，且它们其中字符和，你需要通过「交换字符」的方式使这两个字符串相同。每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换和，但不能交换和。最后，请你返回使和相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回。,"1<=s1.length,s2.length<=1000s1.length==s2.lengths1,s2只包含'x'或'y'",1,3
1009,59,3,54,题库,1,0,1,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。如果某个连续子数组中恰好有个奇数数字，我们就认为这个子数组是「」。请返回这个数组中的数目。,1<=nums.length<=500001<=nums[i]<=10^51<=k<=nums.length,1,4
1010,95,3,106,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由、和小写字母组成的字符串。你需要从字符串中删除最少数目的或者（可以删除任意位置的括号)，使得剩下的「括号字符串」有效。请返回任意一个合法字符串。有效「括号字符串」应当符合以下要求：,空字符串或只包含小写字母的字符串可以被写作连接）的字符串，其中和都是有效「括号字符串」可以被写作(A)的字符串，其中是一个有效的「括号字符串」1<=s.length<=10s[i]可能是'('')'或英文小写字母,1,2
1011,75,3,36,题库,1,0,0,0,0,2,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个正整数数组，你需要从中任选一些子集，然后将子集中每一个数乘以一个，并求出他们的和。假如该和结果为，那么原数组就是一个「」，则返回；否则请返回。,1<=nums.length<=10^51<=nums[i]<=10^9,1,3
1012,62,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"Table:Table:编写SQL查询以查找每种产品的平均售价。
应该四舍五入到小数点后两位。
查询结果格式如下例所示：",,1,1
1013,148,2,44,题库,2,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的矩阵，最开始的时候，每个单元格中的值都是。另有一个二维索引数组，指向矩阵中的某个位置，其中和分别表示指定的行和列（）。对所指向的每个位置，应同时执行下述增量操作：给你、和。请你在执行完所有指定的增量操作后，返回矩阵中的数目。你可以设计一个时间复杂度为且仅用额外空间的算法来解决此问题吗？,"1<=m,n<=501<=indices.length<=1000<=r<m0<=c<n",1,3
1014,94,3,158,题库,2,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个行列的二进制数组：你需要利用，和来重构这个矩阵，并以二维整数数组的形式返回它。如果有多个不同的答案，那么任意一个都可以通过本题。如果不存在符合要求的答案，就请返回一个空的二维数组。,"矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是就是行的元素之和为upper行的元素之和为lower列（从开始编号）的元素之和为colsum[i]colsum是一个长度为的整数数组。1<=colsum.length<=10^50<=upper,lower<=colsum.length0<=colsum[i]<=2",1,3
1015,63,3,50,题库,2,2,0,1,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,二维矩阵由（土地）和（水）组成。岛是由最大的4个方向连通的组成的群，封闭岛是一个由1包围（左、上、右、下）的岛。请返回的数目。,"1<=grid.length,grid[0].length<=1000<=grid[i][j]<=1",1,5
1016,116,3,348,题库,2,2,0,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你将会得到一份单词表，一个字母表（可能会有重复字母），以及每个字母对应的得分情况表。请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由里的字母拼写出的属于单词子集中，分数最高的单词集合的得分。单词拼写游戏的规则概述如下：,"玩家需要用字母表letters里的字母来拼写单词表words中的单词。可以只使用字母表letters中的部分字母，但是每个字母最多被使用一次。单词表words中每个单词只能计分（使用）一次。根据字母得分情况表score，字母'a''b''c',...,'z'对应的得分分别为score[0]score[1],...,score[25]本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。1<=words.length<=141<=words[i].length<=151<=letters.length<=100letters[i].length==1score.length==260<=score[i]<=10words[i]和letters[i]只包含小写的英文字母。",1,6
1017,58,3,179,题库,3,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个行列的二维网格和一个整数。你需要将迁移次。每次「迁移」操作将会引发下述活动：请你返回次迁移操作后最终得到的。,位于grid[i][j]的元素将会移动到grid[i][j+1]位于grid[i][n-1]的元素将会移动到grid[i+1][0]位于grid[m-1][n-1]的元素将会移动到grid[0][0]m==grid.lengthn==grid[i].length1<=m<=501<=n<=50-1000<=grid[i][j]<=10000<=k<=100,1,3
1018,52,3,178,题库,0,2,3,0,0,0,1,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给出一个满足下述规则的二叉树：现在这个二叉树受到「污染」，所有的都变成了。请你先还原二叉树，然后实现类：,"FindElements(TreeNode*root)用受污染的二叉树初始化对象，你需要先把它还原。boolfind(inttarget)判断目标值target是否存在于还原后的二叉树中并返回结果。TreeNode.val==-1二叉树的高度不超过节点的总数在[1,10^4]之间调用find()的总次数在[1,10^4]之间0<=target<=10^6",1,6
1019,28,3,38,题库,2,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你找出并返回能被三整除的元素最大和。,1<=nums.length<=4*10^41<=nums[i]<=10^4,1,4
1020,125,3,271,题库,2,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。游戏地图用大小为的网格表示，其中每个元素可以是墙、地板或者是箱子。现在你将作为玩家参与游戏，按规则将箱子移动到目标位置：返回将箱子推到目标位置的最小次数，如果无法做到，请返回。,"玩家用字符'S'表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。地板用字符'.'表示，意味着可以自由行走。墙用字符'#'表示，意味着障碍物，不能通行。箱子仅有一个，用字符'B'表示。相应地，网格上有一个目标位置'T'玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。玩家无法越过箱子。m==grid.lengthn==grid[i].length1<=m,n<=20grid仅包含字符'.''#','S','T',以及'B'grid中'S''B'和'T'各只能出现一个。",1,4
1021,58,2,216,题库,1,0,0,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,平面上有个点，点的位置用整数坐标表示。请你计算访问所有这些点需要的（以秒为单位）。你需要按照下面的规则在平面上移动：,"沿水平方向移动一个单位长度，或者沿竖直方向移动一个单位长度，或者跨过对角线移动sqrt(2)个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。必须按照数组中出现的顺序来访问这些点。在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。points.length==n1<=n<=100points[i].length==2-1000<=points[i][0],points[i][1]<=1000",1,3
1022,113,3,65,题库,2,2,0,1,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,这里有一幅服务器分布图，服务器的位置标识在的整数矩阵网格中，1表示单元格上有服务器，0表示没有。如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。,m==grid.lengthn==grid[i].length1<=m<=2501<=n<=250grid[i][j]==0or1,1,6
1023,136,4,130,题库,2,0,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个产品数组和一个字符串，数组中每个产品都是一个字符串。请你设计一个推荐系统，在依次输入单词的每一个字母后，推荐数组中前缀与相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。请你以二维列表的形式，返回在输入每个字母后相应的推荐产品的列表。,1<=products.length<=10001<=Σproducts[i].length<=2*10^4products[i]中所有的字符都是小写英文字母。1<=searchWord.length<=1000searchWord中所有字符都是小写英文字母。,1,3
1024,129,3,26,题库,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一个长度为的数组，开始有一个指针在索引处。每一步操作中，你可以将指针向左或向右移动1步，或者停在原地（指针不能被移动到数组范围外）。给你两个整数和，请你计算并返回：在恰好执行次操作以后，指针仍然指向索引处的方案数。由于答案可能会很大，请返回方案数后的结果。,1<=steps<=5001<=arrLen<=10,1,1
1025,190,4,243,题库,3,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"和在一个x的网格上玩井字棋。井字棋游戏的规则如下：给你一个数组，其中每个元素是大小为的另一个数组（元素分别对应网格的行和列），它按照和的行动顺序（先后）记录了两人各自的棋子位置。如果游戏存在获胜者（或），就返回该游戏的获胜者；如果游戏以平局结束，则返回""Draw""；如果仍会有行动（游戏未结束），则返回""Pending""。你可以假设都（遵循井字棋规则），网格最初是空的，将先行动。","玩家轮流将棋子放在空方格("""")上。第一个玩家A总是用""X""作为棋子，而第二个玩家B总是用""O""作为棋子。""X""和""O""只能放在空方格中，而不能放在已经被占用的方格上。只要有3个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。如果所有方块都放满棋子（不为空），游戏也会结束。游戏结束后，棋子无法再进行任何移动。1<=moves.length<=9moves[i].length==20<=moves[i][j]<=2moves里没有重复的元素。moves遵循井字棋的规则。",1,4
1026,159,5,70,题库,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。给你两个整数和，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：请你以（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片和奶酪片的数量都是。如果无法使剩下的番茄片和奶酪片的数量为，就请返回。,巨无霸汉堡：4片番茄和1片奶酪小皇堡：2片番茄和1片奶酪0<=tomatoSlices<=10^70<=cheeseSlices<=10^7,1,1
1027,41,2,54,题库,2,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的矩阵，矩阵中的元素不是就是，请你统计并返回其中完全由组成的子矩阵的个数。,1<=arr.length<=3001<=arr[0].length<=3000<=arr[i][j]<=1,1,3
1028,60,3,89,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个由小写字母组成的字符串，和一个整数。请你按下面的要求分割字符串：请返回以这种方式分割字符串所需修改的最少字符数。,首先，你可以将中的部分字符修改为其他的小写英文字母。接着，你需要把分割成个非空且不相交的子串，并且每个子串都是回文串。1<=k<=s.length<=100中只含有小写英文字母。,1,2
1029,50,1,0,题库,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,学生表:科目表:考试表:查询出每个学生参加每一门科目测试的次数，结果按和排序。查询结构格式如下所示。,,1,1
1030,39,2,10,题库,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。,1<=n<=10^5,1,1
1031,143,2,48,题库,1,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个人被分成数量未知的组。每个人都被标记为一个从到的。给定一个整数数组，其中是第个人所在的组的大小。例如，如果，则第个人必须位于大小为的组中。返回一个组列表，使每个人都在一个大小为的组中。每个人应该出现在中，并且每个人必须在一个组中。如果有多个答案，返回其中一个。可以给定输入有效的解。,groupSizes.length==n1<=n<=5001<=groupSizes[i]<=n,1,2
1032,117,3,66,题库,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个正整数，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。请你找出能够使上述结果小于等于阈值的除数中的那个。每个数除以除数后都向上取整，比方说7/3=3，10/2=5。题目保证一定有解。,1<=nums.length<=5*10^41<=nums[i]<=10^6nums.length<=threshold<=10^6,1,2
1033,140,3,57,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的二进制矩阵。每一步，你可以选择一个单元格并将它反转（反转表示变，变）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。相邻的两个单元格共享同一条边。请你返回将矩阵转化为全零矩阵的，如果无法转化为全零矩阵，请返回。的每一个格子要么是要么是。是所有格子都为的矩阵。,m==mat.lengthn==mat[0].length1<=m<=31<=n<=3mat[i][j]是0或1。,1,4
1034,18,1,338,题库,1,1,0,0,0,0,2,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你设计一个迭代器类，包括以下内容：,"CombinationIterator(stringcharacters,intcombinationLength)一个构造函数，输入参数包括：用一个有序且字符唯一的字符串characters（该字符串只包含小写英文字母）和一个数字combinationLength函数next()，按字典序返回长度为combinationLength的下一个字母组合。函数hasNext()，只有存在长度为combinationLength的下一个字母组合时，才返回true1<=combinationLength<=characters.length<=15characters中每个字符都每组测试数据最多对next和hasNext调用题目保证每次调用函数next时都存在下一个字母组合。",1,4
1035,58,1,34,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个非递减的整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的25%。请你找到并返回这个整数,1<=arr.length<=10^40<=arr[i]<=10^5,1,1
1036,79,1,100,题库,2,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。只有当且时，我们才认为区间被区间覆盖。在完成所有删除操作后，请你返回列表中剩余区间的数目。​​​​​​,1<=intervals.length<=10000<=intervals[i][0]<intervals[i][1]<=10^5对于所有的i!=jintervals[i]!=intervals[j],1,2
1037,66,2,58,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数矩阵，请你返回数字和的最小值。定义为：从数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。,n==grid.length==grid[i].length1<=n<=200-99<=grid[i][j]<=99,1,3
1038,64,5,26,题库,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个单链表的引用结点。链表中每个结点的值不是0就是1。已知此链表是一个整数数字的二进制表示形式。请你返回该链表所表示数字的。,链表不为空。链表的结点总数不超过每个结点的值不是就是,1,2
1039,59,2,19,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,我们定义「顺次数」为：每一位上的数字都比前一位上的数字大的整数。请你返回由范围内所有顺次数组成的列表（从小到大排序）。,10<=low<=high<=10^9,1,1
1040,64,2,72,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个大小为的矩阵和一个整数阈值。请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回。
","m==mat.lengthn==mat[i].length1<=m,n<=3000<=mat[i][j]<=100<=threshold<=10",1,4
1041,111,2,90,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的网格，其中每个单元格不是（空）就是（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。如果您可以消除个障碍物，请找出从左上角到右下角的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回。,"grid.length==mgrid[0].length==n1<=m,n<=401<=k<=m*ngrid[i][j]是grid[0][0]==grid[m-1][n-1]==0",1,3
1042,25,2,35,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请你返回其中位数为的数字的个数。,1<=nums.length<=5001<=nums[i]<=10^5,1,1
1043,72,4,35,题库,2,1,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个整数数组和一个正整数，请你判断是否可以把这个数组划分成一些由个连续数字组成的集合。
如果可以，请返回；否则，返回。此题目与846重复：",1<=k<=nums.length<=101<=nums[i]<=10,1,4
1044,34,4,137,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你返回满足以下条件且出现次数最大的子串的出现次数：,"子串中不同字母的数目必须小于等于maxLetters子串的长度必须大于等于minSize且小于等于maxSize1<=s.length<=10^51<=maxLetters<=261<=minSize<=maxSize<=min(26,s.length)只包含小写英文字母。",1,3
1045,104,5,561,题库,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你个盒子，每个盒子的格式为，其中：给你一个数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。请你按照上述规则，返回可以获得糖果的。,状态字status[i]：整数，如果box[i]是开的，那么是，否则是糖果数candies[i]:整数，表示box[i]中糖果的数目。钥匙keys[i]：数组，表示你打开box[i]后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。内含的盒子containedBoxes[i]：整数，表示放在box[i]里的盒子所对应的下标。1<=status.length<=1000status.length==candies.length==keys.length==containedBoxes.length==nstatus[i]要么是要么是1<=candies[i]<=10000<=keys[i].length<=status.length0<=keys[i][j]<status.lengthkeys[i]中的值都是互不相同的。0<=containedBoxes[i].length<=status.length0<=containedBoxes[i][j]<status.lengthcontainedBoxes[i]中的值都是互不相同的。每个盒子最多被一个盒子包含。0<=initialBoxes.length<=status.length0<=initialBoxes[i]<status.length,1,3
1046,59,2,30,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用替换。完成所有替换操作后，请你返回这个数组。,1<=arr.length<=101<=arr[i]<=10,1,1
1047,109,3,41,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个目标值，请你返回一个整数，使得将数组中所有大于的值变成后，数组的和最接近（最接近表示两者之差的绝对值最小）。如果有多种使得和最接近的方案，请你返回这些整数中的最小值。请注意，答案不一定是中的数字。,"1<=arr.length<=10^41<=arr[i],target<=10^5",1,3
1048,198,3,37,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个正方形字符数组，你从数组最右下方的字符出发。你的目标是到达数组最左上角的字符，数组剩余的部分为数字字符或者障碍。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。一条路径的「得分」定义为：路径上所有数字的和。请你返回一个列表，包含两个整数：第一个整数是「得分」的最大值，第二个整数是得到最大得分的方案数，请把结果对。如果没有任何路径可以到达终点，请返回。,2<=board.length==board[i].length<=100,1,3
1049,17,2,33,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，请你返回。,"树中节点数目在范围[1,10之间。1<=Node.val<=100",1,4
1050,34,3,10,题库,1,0,0,0,0,1,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，请你返回一个由个的整数组成的数组，并且这个数相加和为。,1<=n<=1000,1,2
1051,37,2,36,题库,1,1,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你和这两棵二叉搜索树。请你返回一个列表，其中包含中的所有整数并按排序。.,"每棵树的节点数在[0,5000]范围内-10<=Node.val<=10",1,5
1052,92,3,60,题库,1,2,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,这里有一个非负整数数组，你最开始位于该数组的起始下标处。当你位于下标处时，你可以跳到或者。请你判断自己是否能够跳到对应元素值为0的下标处。注意，不管是什么情况下，你都无法跳到数组之外。,1<=arr.length<=5*10^40<=arr[i]<arr.length0<=start<arr.length,1,3
1053,52,4,195,题库,2,1,0,0,0,1,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个方程，左边用表示，右边用表示。你需要根据以下规则检查方程是否可解：如果方程可解，返回，否则返回。,"每个字符都会被解码成一位数字（0-9）。每对不同的字符必须映射到不同的数字。每个words[i]和result都会被解码成一个没有前导零的数字。左侧数字之和（words）等于右侧数字（result）。2<=words.length<=51<=words[i].length,results.length<=7words[i],result只含有大写英文字母表达式中使用的不同字符数最大为10",1,4
1054,68,2,111,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个字符串，它由数字（-）和组成。我们希望按下述规则将映射为一些小写英文字符：返回映射之后形成的新字符串。题目数据保证映射始终唯一。,字符（'a'-'i'）分别用（'1'-'9'）表示。字符（'j'-'z'）分别用（'10#'-'26#'）表示。1<=s.length<=1000s[i]只包含数字（'0''9'）和'#'字符。是映射始终存在的有效字符串。,1,1
1055,72,2,123,题库,1,0,0,0,2,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个正整数数组，现给你一个对应的查询数组，其中。对于每个查询，请你计算从到的值（即）作为本次查询的结果。并返回一个包含给定查询所有结果的数组。,1<=arr.length<=3*10^41<=arr[i]<=10^91<=queries.length<=3*10^4queries[i].length==20<=queries[i][0]<=queries[i][1]<arr.length,1,3
1056,198,2,197,题库,2,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个人，每个人都有一个到的唯一。给你数组和，其中和分别表示的人观看过的视频列表和他的好友列表。Level的视频包含所有你好友观看过的视频，level的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level为的视频包含所有从你出发，最短距离为的好友观看过的视频。给定你的和一个值，请你找出所有指定的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按字母顺序从小到大排列。,n==watchedVideos.length==friends.length2<=n<=1001<=watchedVideos[i].length<=1001<=watchedVideos[i][j].length<=80<=friends[i].length<n0<=friends[i][j]<n0<=id<n1<=level<n如果friends[i]包含，那么friends[j]包含,1,5
1057,64,3,28,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，每一次操作你都可以在字符串的任意位置插入任意字符。请你返回让成为回文串的。「回文串」是正读和反读都相同的字符串。,1<=s.length<=500中所有字符都是小写字母。,1,2
1058,91,2,50,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个以行程长度编码压缩的整数列表。考虑每对相邻的两个元素（其中），每一对都表示解压后子列表中有个值为的元素，你需要从左到右连接所有子列表以生成解压后的列表。请你返回解压后的列表。,2<=nums.length<=100nums.length%2==01<=nums[i]<=100,1,1
1059,41,2,92,题库,2,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的矩阵和一个整数，请你返回一个矩阵，其中每个是所有满足下述条件的元素的和：,"i-k<=r<=i+k,j-k<=c<=j+k(r,c)在矩阵内。m==mat.lengthn==mat[i].length1<=m,n,k<=1001<=mat[i][j]<=100",1,3
1060,50,1,69,题库,0,2,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：如果不存在祖父节点值为偶数的节点，那么返回。,该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）树中节点的数目在到10^4之间。每个节点的值在到100之间。,1,4
1061,44,2,74,题库,1,0,0,1,2,0,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，请你返回满足下述条件的非空子字符串的数目：例如，就是和它自身连接形成的。,可以写成某个字符串与其自身相连接的形式（即，可以写为a+a，其中是某个字符串）。1<=text.length<=2000text只包含小写英文字母。,1,4
1062,79,5,22,题库,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,「无零整数」是十进制表示中的正整数。给你一个整数，请你返回一个，满足：题目数据保证至少有一个有效的解决方案。如果存在多个有效解决方案，你可以返回其中任意一个。,和都是无零整数A+B=n2<=n<=10^4,1,1
1063,90,3,30,题库,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你三个正整数、和。你可以对和的二进制表示进行位翻转操作，返回能够使按位或运算OR==成立的最小翻转次数。「位翻转操作」是指将一个数的二进制表示任何单个位上的1变成0或者0变成1。,1<=a<=10^91<=b<=10^91<=c<=10^9,1,1
1064,174,4,176,题库,0,2,1,1,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,用以太网线缆将台计算机连接成一个网络，计算机的编号从到。线缆用表示，其中连接了计算机和。网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。给你这个计算机网络的初始布线，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回-1。,"1<=n<=10^51<=connections.length<=min(n*(n-1)/2,10^5)connections[i].length==20<=connections[i][0],connections[i][1]<nconnections[i][0]!=connections[i][1]没有重复的连接。两台计算机不会通过多条线缆连接。",1,4
1065,150,2,88,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,二指输入法定制键盘在平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处。给你一个待输入字符串，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标和之间的是。，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。,"例如字母位于坐标(0,0)，字母位于坐标(0,1)，字母位于坐标(2,3)且字母位于坐标(4,1)2<=word.length<=300每个word[i]都是一个大写英文字母。",1,2
1066,90,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表:你是餐馆的老板，现在你想分析一下可能的营业额变化增长（每天至少有一位顾客）。计算以7天（某日期+该日期前的6天）为一个时间段的顾客消费平均值。要结果按。返回结果格式的例子如下。,,1,1
1067,58,3,29,题库,0,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个仅由数字6和9组成的正整数。你最多只能翻转一位数字，将6变成9，或者把9变成6。请返回你可以得到的最大数字。,1<=num<=10^4num每一位上的数字都是6或者9。,1,2
1068,107,3,44,题库,3,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个字符串。请你按照单词在中的出现顺序将它们全部竖直返回。
单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。
每个单词只能放在一列上，每一列中也只能有一个单词。",1<=s.length<=200仅含大写英文字母。题目数据保证两个单词之间只有一个空格。,1,3
1069,106,5,48,题库,0,1,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵以为根的二叉树和一个整数，请你删除所有值为的。注意，一旦删除值为的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是，那么这个节点也应该被删除。也就是说，你需要重复此过程直到不能继续删除。,"1<=target<=1000每一棵树最多有3000个节点。每一个节点值的范围是[1,1000]",1,3
1070,132,2,43,题库,1,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,在x轴上有一个一维的花园。花园长度为，从点开始，到点结束。花园里总共有个水龙头，分别位于。给你一个整数和一个长度为的整数数组，其中（下标从0开始）表示：如果打开点处的水龙头，可以灌溉的区域为。请你返回可以灌溉整个花园的。如果花园始终存在无法灌溉到的地方，请你返回。,1<=n<=10ranges.length==n+10<=ranges[i]<=100,1,3
1071,65,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表:表:写一个SQL语句，要求获取在2020年2月份下单的数量不少于100的产品的名字和数目。返回结果表单的。查询结果的格式如下。,,1,1
1072,172,2,46,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由小写英文字母组成的回文字符串，请你将其中字符用任意小写英文字母替换，使得结果字符串的，且回文串。请你返回结果字符串。如果无法做到，则返回一个。如果两个字符串长度相同，那么字符串字典序比字符串小可以这样定义：在和出现不同的第一个位置上，字符串中的字符严格小于中的对应字符。例如，字典序比小，因为不同的第一个位置是在第四个字符，显然比小。,1<=palindrome.length<=1000palindrome只包含小写英文字母。,1,2
1073,101,2,57,题库,3,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵有行列，从开始的将会经过、和。给你一个的整数矩阵，请你将同一条上的元素按升序排序后，返回排好序的矩阵。,"m==mat.lengthn==mat[i].length1<=m,n<=1001<=mat[i][j]<=100",1,3
1074,71,2,42,题库,1,1,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组。「数组值」定义为所有满足的的和。你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作。请你找到可行的最大。,1<=nums.length<=3*10^4-10^5<=nums[i]<=10^5,1,3
1075,55,3,90,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请你将数组中的每个元素替换为它们排序后的序号。序号代表了一个元素有多大。序号编号的规则如下：,序号从1开始编号。一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。每个数字的序号都应该尽可能地小。0<=arr.length<=10-10<=arr[i]<=10,1,3
1076,165,3,29,题库,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，它仅由字母和组成。每一次删除操作都可以从中删除一个回文。返回删除给定字符串中所有字符（字符串为空）的最小删除次数。「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。,1<=s.length<=1000仅包含字母'a'和'b',1,2
1077,186,3,154,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个餐馆信息数组，其中。你必须使用以下三个过滤器来过滤这些餐馆信息。其中素食者友好过滤器的值可以为或者，如果为就意味着你应该只包括为true的餐馆，为则意味着可以包括任何餐馆。此外，我们还有最大价格和最大距离两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。过滤后返回餐馆的，按照从高到低排序。如果相同，那么按从高到低排序。简单起见，和为时取值为，为时，取值为,"1<=restaurants.length<=10^4restaurants[i].length==51<=id,rating,price,distance<=10^51<=maxPrice,maxDistance<=10^5veganFriendly和veganFriendly的值为0或1。所有各不相同。",1,2
1078,129,2,114,题库,0,1,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个城市，按从到编号。给你一个边数组，其中代表和两个城市之间的双向加权边，距离阈值是一个整数。返回能通过某些路径到达其他城市数目最少、且路径距离为的城市。如果有多个这样的城市，则返回编号最大的城市。注意，连接城市和的路径的距离等于沿该路径的所有边的权重之和。,"2<=n<=1001<=edges.length<=n*(n-1)/2edges[i].length==30<=from<to<n1<=weight,distanceThreshold<=10^4所有(from,to都是不同的。",1,3
1079,166,5,61,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你需要制定一份天的工作计划表。工作之间存在依赖，要想执行第项工作，你必须完成全部项工作（）。你每天需要完成一项任务。工作计划的总难度是这天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。给你一个整数数组和一个整数，分别代表工作难度和需要计划的天数。第项工作的难度是。返回整个工作计划的。如果无法制定工作计划，则返回。,1<=jobDifficulty.length<=3000<=jobDifficulty[i]<=10001<=d<=10,1,2
1080,133,2,65,题库,3,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个大小为的矩阵，矩阵由若干军人和平民组成，分别用1和0表示。请你返回矩阵中战斗力最弱的行的索引，按从最弱到最强排序。如果第行的军人数量少于第行，或者两行军人数量相同但小于，那么我们认为第行的战斗力比第行弱。军人排在一行中的靠前位置，也就是说1总是出现在0之前。,"m==mat.lengthn==mat[i].length2<=n,m<=1001<=k<=mmatrix[i][j]不是0就是1",1,5
1081,64,2,43,题库,2,1,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。返回能删除数组中的一半整数的整数集合的最小大小。,1<=arr.length<=10arr.length为偶数1<=arr[i]<=10,1,5
1082,76,4,42,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树，它的根为。请你删除1条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。由于答案可能会很大，请你将结果对10^9+7取模后再返回。,"每棵树最多有50000个节点，且至少有个节点。每个节点的值在[1,10000]之间。",1,3
1083,119,5,96,题库,2,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数。每一步你可以从下标跳到：除此以外，你从下标跳到下标需要满足：且，其中下标是所有到之间的数字（更正式的，）。你可以选择数组的任意下标开始跳跃。请你返回你可以访问多少个下标。请注意，任何时刻你都不能跳到数组的外面。,i+x，其中i+x<arr.length且0<x<=di-x，其中i-x>=0且0<x<=d1<=arr.length<=10001<=arr[i]<=10^51<=d<=arr.length,1,3
1084,64,1,81,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表：表：表：请你编写一组SQL查询：，即按字母在字典中出现顺序对字符串排序，字典序较小则意味着排序靠前。查询结果格式如下例所示。,查找评论电影数量最多的用户名。如果出现平局，返回字典序较小的用户名。查找在February2020平均评分最高的电影名称。如果出现平局，返回字典序较小的电影名称。,1,1
1085,51,3,12,题库,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个非负整数，请你返回将它变成0所需要的步数。如果当前数字是偶数，你需要把它除以2；否则，减去1。,0<=num<=10^6,1,2
1086,37,2,62,题库,1,0,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和两个整数和。请你返回长度为且平均值大于等于的子数组数目。,1<=arr.length<=101<=arr[i]<=101<=k<=arr.length0<=threshold<=10,1,2
1087,44,5,52,题库,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个数和。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60单位制）。,1<=hour<=120<=minutes<=59与标准答案误差在10^-5以内的结果都被视为正确结果。,1,1
1088,88,3,91,题库,1,1,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，你一开始在数组的第一个元素处（下标为0）。每一步，你可以从下标跳到下标、或者：请你返回到达数组最后一个元素的下标处所需的。注意：任何时候你都不能跳到数组外面。,i+1需满足：i+1<arr.lengthi-1需满足：i-1>=0需满足：arr[i]==arr[j]且i!=j1<=arr.length<=5*10-10<=arr[i]<=10,1,3
1089,53,3,74,题库,2,1,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请你检查是否存在两个整数和，满足是的两倍（即，）。更正式地，检查是否存在两个下标和满足：,"i!=j0<=i,j<arr.lengtharr[i]==2*arr[j]2<=arr.length<=500-10^3<=arr[i]<=10^3",1,5
1090,74,5,46,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个长度相等的字符串和。每一个步骤中，你可以选择将中的替换为。返回使成为的字母异位词的最小步骤数。指字母相同，但排列不同（也可能相同）的字符串。,1<=s.length<=50000s.length==t.length和只包含小写英文字母,1,3
1091,158,1,470,题库,1,1,2,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,一家社交媒体公司正试图通过分析特定时间段内出现的推文数量来监控其网站上的活动。这些时间段可以根据特定的频率（、或）划分为更小的。例如，周期（以为单位）将被划分为以下频率的:注意，最后一个块可能比指定频率的块大小更短，并且总是以时间段的结束时间结束(在上面的示例中为)。设计和实现一个API来帮助公司进行分析。实现类:,"(60秒块)：[10,69][70,129][130,189]...[9970,10000](3600秒块)：[10,3609][3610,7209][7210,10000](86400秒块)：[10,10000]TweetCounts()初始化TweetCounts对象。存储记录时间的tweetName(以秒为单位)。List<integer>getTweetCountsPerFrequency(Stringfreq,StringtweetName,intstartTime,intendTime)返回一个整数列表，表示给定时间[startTime,endTime]（单位秒）和频率频率中，每个时间块中带有tweetName的tweetfreq是“minute”、“hour”或“day”中的一个，分别表示每分钟、每小时或每一天的频率。0<=time,startTime,endTime<=100<=endTime-startTime<=10recordTweet和getTweetCountsPerFrequency，最多有次操作。",1,5
1092,148,3,64,题库,2,1,0,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的矩阵表示教室中的座位分布。如果座位是坏的（不可用），就用表示；否则，用表示。学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。学生必须坐在状况良好的座位上。,seats只包含字符'.'和'#'m==seats.lengthn==seats[i].length1<=m<=81<=n<=8,1,5
1093,66,2,63,题库,2,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的矩阵，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。请你统计并返回中的数目。你可以设计一个时间复杂度为的解决方案吗？,"m==grid.lengthn==grid[i].length1<=m,n<=100-100<=grid[i][j]<=100",1,3
1094,71,1,113,题库,1,0,1,0,0,1,2,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你实现一个「数字乘积类」，要求支持下述两种方法：1.2.题目数据保证：任何时候，任一连续数字序列的乘积都在32-bit整数范围内，不会溢出。,将数字num添加到当前数字列表的最后面。返回当前数字列表中，最后个数字的乘积。你可以假设当前列表中始终包含个数字。add和getProduct两种操作加起来总共不会超过40000次。0<=num<=1001<=k<=40000,1,5
1095,74,2,62,题库,2,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，其中，表示会议开始于，结束于。你可以在满足中的任意一天参加会议。注意，一天只能参加一个会议。请你返回你可以参加的会议数目。​​​​​​,1<=events.length<=10events[i].length==21<=startDay<=endDay<=10,1,4
1096,73,3,118,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组。一开始，你有一个数组，它的所有元素均为1，你可以执行以下操作：如果能从开始构造出目标数组，请你返回True，否则返回False。,为你数组里所有元素的和选择满足0<=i<target.size的任意下标，并让数组里下标为处的值为你可以重复该过程任意次N==target.length1<=target.length<=5*10^41<=target[i]<=10^9,1,2
1097,83,5,33,题库,2,0,0,0,2,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组。请你将数组中的元素按照其二进制表示中数字的数目升序排序。如果存在多个数字二进制中的数目相同，则必须将它们按照数值大小升序排列。请你返回排序后的数组。,1<=arr.length<=5000<=arr[i]<=10^4,1,4
1098,160,1,490,题库,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,超市里正在举行打折活动，每隔个顾客会得到的折扣。超市里有一些商品，第种商品为且每件单品的价格为。结账系统会统计顾客的数目，每隔个顾客结账时，该顾客的账单都会打折，折扣为（也就是如果原本账单为，那么实际金额会变成），然后系统会重新开始计数。顾客会购买一些商品，是顾客购买的第种商品，是对应的购买该种商品的数目。请你实现类：,"Cashier(intn,intdiscount,int[]products,int[]prices)初始化实例对象，参数分别为打折频率，折扣大小discount，超市里的商品列表products和它们的价格pricesdoublegetBill(int[]product,int[]amount)返回账单的实际金额（如果有打折，请返回打折后的结果）。返回结果与标准答案误差在10^-5以内都视为正确结果。1<=n<=10^40<=discount<=1001<=products.length<=2001<=products[i]<=200products列表中有重复的元素。prices.length==products.length1<=prices[i]<=10001<=product.length<=products.lengthproduct[i]在products出现过。amount.length==product.length1<=amount[i]<=1000最多有1000次对getBill函数的调用。返回结果与标准答案误差在10^-5以内都视为正确结果。",1,3
1099,45,3,30,题库,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个字符串，它只包含三种字符a,b和c。请你返回a，b和c都出现过一次的子字符串数目。",3<=s.length<=5x10^4只包含字符a，b和c。,1,3
1100,81,3,9,题库,0,1,0,0,0,2,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你笔订单，每笔订单都需要快递服务。请你统计所有有效的收件/配送序列的数目，确保第个物品的配送服务总是在其收件服务之后。由于答案可能很大，请返回答案对取余的结果。,1<=n<=500,1,3
1101,44,2,25,题库,1,0,0,0,0,1,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一个程序来计算两个日期之间隔了多少天。日期以字符串形式给出，格式为，如示例所示。,给定的日期是1971年到2100年之间的有效日期。,1,2
1102,107,4,83,题库,0,2,3,1,0,0,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,二叉树上有个节点，按从到编号，其中节点的两个子节点分别是和。只有节点能够形成且形成有效的二叉树时，返回；否则返回。如果节点没有左子节点，那么就等于。右子节点也符合该规则。注意：节点没有值，本问题中仅仅使用节点编号。,"1<=n<=10^4leftChild.length==rightChild.length==n-1<=leftChild[i],rightChild[i]<=n-1",1,6
1103,43,3,45,题库,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你找出同时满足下面全部要求的两个整数：你可以按任意顺序返回这两个整数。,两数乘积等于num+1或num+2以绝对差进行度量，两数大小最接近1<=num<=10^9,1,1
1104,113,4,37,题库,1,2,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，你可以通过按连接其中某些数字来形成的倍数，请你返回所能得到的最大的3的倍数。由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。如果无法得到答案，请返回一个空字符串。返回的结果不应包含不必要的前导零。,1<=digits.length<=10^40<=digits[i]<=9,1,3
1105,72,3,34,题库,2,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组，对于其中每个元素，请你统计数组中比它小的所有数字的数目。换而言之，对于每个你必须计算出有效的的数量，其中满足。以数组形式返回答案。,2<=nums.length<=5000<=nums[i]<=100,1,4
1106,141,5,299,题库,3,0,1,0,1,0,0,1,0,0,0,1,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。排名规则如下：给你一个字符串数组代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。请你返回能表示按排名系统的所有团队排名的字符串。,"参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。1<=votes.length<=10001<=votes[i].length<=26votes[i].length==votes[j].lengthfor0<=i,j<votes.lengthvotes[i][j]是英文字母votes[i]中的所有字母都是唯一的votes[0]中出现的所有字母同样也出现在votes[j]中，其中1<=j<votes.length",1,5
1107,115,3,69,题库,0,2,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一棵以为根的二叉树和一个为第一个节点的链表。如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以为首的链表中每个节点的值，那么请你返回，否则返回。一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。,二叉树和链表中的每个节点的值都满足1<=node.val<=100链表包含的节点数目在到100之间。二叉树包含的节点数目在到2500之间。,1,5
1108,197,5,194,题库,2,1,3,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个mxn的网格图。中每个格子都有一个数字，对应着从该格子出发下一步走的方向。中的数字可能为以下几种情况：注意网格图中可能会有，因为它们可能指向以外的区域。一开始，你会从最左上角的格子出发。我们定义一条为从格子出发，每一步都顺着数字对应方向走，最终在最右下角的格子结束的路径。有效路径。你可以花费的代价修改一个格子中的数字，但每个格子中的数字。请你返回让网格图至少有一条有效路径的最小代价。,"，下一步往右走，也就是你会从grid[i][j]走到grid[i][j+1]，下一步往左走，也就是你会从grid[i][j]走到grid[i][j-1]，下一步往下走，也就是你会从grid[i][j]走到grid[i+1][j]，下一步往上走，也就是你会从grid[i][j]走到grid[i-1][j]m==grid.lengthn==grid[i].length1<=m,n<=100",1,6
1109,86,5,26,题库,1,0,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个字符串，请你根据下面的算法重新构造字符串：在任何一步中，如果最小或者最大字符不止一个，你可以选择其中任意一个，并将其添加到结果字符串。请你返回将中字符重新排序后的。,1<=s.length<=500只包含小写英文字母。,1,3
1110,73,3,29,题库,1,0,1,0,2,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即'a'，'e'，'i'，'o'，'u'，在子字符串中都恰好出现了偶数次。,1<=s.length<=5x10^5只包含小写英文字母。,1,4
1111,65,3,128,题库,0,2,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵以为根的二叉树，二叉树中的交错路径定义如下：交错路径的长度定义为：（单个节点的路径长度为0）。请你返回给定树中最长的长度。,"选择二叉树中节点和一个方向（左或者右）。如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。改变前进方向：左变右或者右变左。重复第二步和第三步，直到你在树中无法继续移动。每棵树最多有50000个节点。每个节点的值在[1,100]之间。",1,4
1112,37,5,101,题库,0,2,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一棵以为根的，请你返回二叉搜索子树的最大键值和。二叉搜索树的定义如下：,"任意节点的左子树中的键值都此节点的键值。任意节点的右子树中的键值都此节点的键值。任意节点的左子树和右子树都是二叉搜索树。每棵树有到40000个节点。每个节点的键值在[-4*10^4,4*10^4]之间。",1,5
1113,85,3,9,题库,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，请你返回一个含个字符的字符串，其中每种字符在该字符串中都恰好出现返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。,1<=n<=500,1,1
1114,143,2,50,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为、下标从开始的二进制字符串，所有位最开始都是。我们会按步翻转该二进制字符串的所有位（即，将变为）。给你一个下标从开始的整数数组，其中表示对应下标的位将会在第步翻转。二进制字符串需满足：在第步之后，在区间内的所有位都是1，而其他位都是0。返回二进制字符串在翻转过程中的次数。,"n==flips.length1<=n<=5*10flips是范围[1,n]中所有整数构成的一个排列",1,1
1115,240,2,153,题库,0,2,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,公司里有名员工，每个员工的ID都是独一无二的，编号从到。公司的总负责人通过进行标识。在数组中，每个员工都有一个直属负责人，其中是第名员工的直属负责人。对于总负责人，。题目保证从属关系可以用树结构显示。公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。第名员工需要分钟来通知它的所有直属下属（也就是说在分钟后，他的所有直属下属都可以开始传播这一消息）。返回通知所有员工这一紧急消息所需要的。,1<=n<=10^50<=headID<nmanager.length==n0<=manager[i]<nmanager[headID]==-1informTime.length==n0<=informTime[i]<=1000如果员工没有下属，informTime[i]==0题目所有员工都可以收到通知。,1,3
1116,107,2,197,题库,0,2,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一棵由个顶点组成的无向树，顶点编号从到。青蛙从开始起跳。规则如下：无向树的边用数组描述，其中意味着存在一条直接连通和两个顶点的边。返回青蛙在秒后位于目标顶点上的概率。与实际答案相差不超过的结果将被视为正确答案。,"在一秒内，青蛙从它所在的当前顶点跳到另一个未访问过的顶点（如果它们直接相连）。青蛙无法跳回已经访问过的顶点。如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。1<=n<=100edges.length==n-1edges[i].length==21<=a,b<=n1<=t<=501<=target<=n",1,4
1117,62,1,0,题库,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：表：展示每位用户的；如果某位员工没有唯一标识码，使用null填充即可。你可以以顺序返回结果表。返回结果的格式如下例所示。,,1,1
1118,156,3,64,题库,0,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两棵二叉树，原始树和克隆树，以及一个位于原始树中的目标节点。其中，克隆树是原始树的一个。请找出在树中，与的节点，并返回对该节点的引用（在C/C++等有指针的语言中返回节点指针，其他语言返回节点本身）。你对两棵二叉树，以及节点进行更改。返回对克隆树中已有的节点的引用。如果树中允许出现值相同的节点，将如何解答？,"树中节点的数量范围为[1,10同一棵树中，没有值相同的节点。target节点是树original中的一个节点，并且不会是null",1,4
1119,51,3,97,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的矩阵，矩阵中的数字。请你按顺序返回矩阵中的所有幸运数。是指矩阵中满足同时下列两个条件的元素：,"在同一行的所有元素中最小在同一列的所有元素中最大m==mat.lengthn==mat[i].length1<=n,m<=501<=matrix[i][j]<=10^5矩阵中的所有元素都是不同的",1,2
1120,29,1,253,题库,1,0,1,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你设计一个支持对其元素进行增量操作的栈。实现自定义栈类：,"CustomStack(intmaxSize)：用maxSize初始化对象，maxSize是栈中最多能容纳的元素数量。voidpush(intx)：如果栈还未增长到maxSize，就将添加到栈顶。intpop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回voidinc(intk,intval)：栈底的个元素的值都增加val。如果栈中元素总数小于，则栈中的所有元素都增加val1<=maxSize,x,k<=10000<=val<=100每种方法incrementpush以及pop分别最多调用1000",1,3
1121,103,2,31,题库,0,3,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉搜索树，请你返回一棵的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过，我们就称这棵二叉搜索树是。,"树节点的数目在[1,10范围内。1<=Node.val<=10",1,6
1122,114,3,91,题库,2,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,公司有编号为到的个工程师，给你两个数组和，其中和分别代表第位工程师的速度和效率。请你返回由最多个工程师组成的，由于答案可能很大，请你返回结果对取余后的结果。的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。,1<=n<=10^5speed.length==nefficiency.length==n1<=speed[i]<=10^51<=efficiency[i]<=10^81<=k<=n,1,4
1123,60,3,68,题库,2,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数数组，和一个整数，请你返回两个数组之间的。「」定义为符合此距离要求的元素数目：对于元素，不存在任何元素满足。,"1<=arr1.length,arr2.length<=500-10^3<=arr1[i],arr2[j]<=10^30<=d<=100",1,4
1124,167,3,152,题库,1,1,1,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"如上图所示，电影院的观影厅中有行座位，行编号从1到，且每一行内总共有10个座位，列编号从1到10。给你数组，包含所有已经被预约了的座位。比如说，，它表示第行第个座位被预约了。请你返回。4人家庭要占据的4个座位。隔着过道的座位（比方说[3,3]和[3,4]）不是连续的座位，但是如果你可以将4人家庭拆成过道两边各坐2人，这样子是允许的。","1<=n<=10^91<=reservedSeats.length<=min(10*n,10^4)reservedSeats[i].length==21<=reservedSeats[i][0]<=n1<=reservedSeats[i][1]<=10所有reservedSeats[i]都是互不相同的。",1,4
1125,196,2,56,题库,1,2,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们将整数的定义为按照下述规则将变成所需要的步数：比方说，x=3的权重为7。因为3需要7步变成1（3-->10-->5-->16-->8-->4-->2-->1）。给你三个整数，和。你的任务是将区间之间的整数按照它们的权重，如果大于等于2个整数有的权重，那么按照数字自身的数值。请你返回区间之间的整数按权重排序后的第个数。注意，题目保证对于任意整数，它变成所需要的步数是一个32位有符号整数。,如果是偶数，那么x=x/2如果是奇数，那么x=3*x+11<=lo<=hi<=10001<=k<=hi-lo+1,1,3
1126,87,2,134,题库,1,2,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个披萨，它由3n块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：每一块披萨的大小按顺时针方向由循环数组表示。请你返回你可以获得的披萨大小总和的最大值。,你挑选一块披萨。Alice将会挑选你所选择的披萨逆时针方向的下一块披萨。Bob将会挑选你所选择的披萨顺时针方向的下一块披萨。重复上述过程直到没有披萨剩下。1<=slices.length<=500slices.length%3==01<=slices[i]<=1000,1,4
1127,50,3,192,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数数组和。你需要按照以下规则创建目标数组：请你返回目标数组。题目保证数字插入位置总是存在。,"目标数组target最初为空。按从左到右的顺序依次读取nums[i]和index[i]，在target数组中的下标index[i]处插入值nums[i]重复上一步，直到在nums和index中都没有要读取的元素。1<=nums.length,index.length<=100nums.length==index.length0<=nums[i]<=1000<=index[i]<=i",1,2
1128,55,3,32,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回。,1<=nums.length<=101<=nums[i]<=10,1,2
1129,114,5,160,题库,2,2,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个x的网格。网格里的每个单元都代表一条街道。的街道可以是：你最开始从左上角的单元格开始出发，网格中的「有效路径」是指从左上方的单元格开始、一直到右下方的结束的路径。。你变更街道。如果网格中存在有效的路径，则返回，否则返回。,"表示连接左单元格和右单元格的街道。表示连接上单元格和下单元格的街道。表示连接左单元格和下单元格的街道。表示连接右单元格和下单元格的街道。表示连接左单元格和上单元格的街道。表示连接右单元格和上单元格的街道。m==grid.lengthn==grid[i].length1<=m,n<=3001<=grid[i][j]<=6",1,5
1130,69,2,24,题库,2,0,0,0,2,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,是在原字符串中既是前缀也是后缀（不包括原字符串自身）的字符串。给你一个字符串，请你返回它的。如果不存在满足题意的前缀，则返回一个空字符串。,1<=s.length<=10只含有小写英文字母,1,4
1131,79,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表：编写一个SQL查询来报告每支股票的资本损益。股票的资本损益是一次或多次买卖股票后的全部收益或损失。以任意顺序返回结果即可。SQL查询结果的格式如下例所示：,,1,1
1132,67,5,69,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。给你一个整数数组，请你从中找出并返回一个幸运数。,如果数组中存在多个幸运数，只需返回的那个。如果数组中不含幸运数，则返回-11<=arr.length<=5001<=arr[i]<=500,1,3
1133,82,3,186,题库,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,名士兵站成一排。每个士兵都有一个的评分。每个士兵可以组成一个作战单位，分组规则如下：请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。,从队伍中选出下标分别为的3名士兵，他们的评分分别为rating[i]rating[j]rating[k]作战单位需满足：rating[i]<rating[j]<rating[k]或者rating[i]>rating[j]>rating[k]，其中0<=in==rating.length3<=n<=10001<=rating[i]<=10^5rating中的元素都是唯一的,1,3
1134,102,2,599,题库,1,0,1,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,地铁系统跟踪不同车站之间的乘客出行时间，并使用这一数据来计算从一站到另一站的平均时间。实现类：你可以假设对和方法的所有调用都是符合逻辑的。如果一名乘客在时间进站、时间出站，那么。所有时间都按时间顺序发生。,"voidcheckIn(intid,stringstationName,intt)通行卡ID等于的乘客，在时间，从stationName站进入乘客一次只能从一个站进入voidcheckOut(intid,stringstationName,intt)通行卡ID等于的乘客，在时间，从stationName站离开doublegetAverageTime(stringstartStation,stringendStation)返回从startStation站到endStation站的平均时间平均时间会根据截至目前所有从startStation站到达endStation站的行程进行计算，也就是从startStation站进入并从endStation离开的行程startStation到endStation的行程时间与从endStation到startStation的行程时间可能不同在调用getAverageTime之前，至少有一名乘客从startStation站到达endStation1<=id,t<=101<=stationName.length,startStation.length,endStation.length<=10所有字符串由大小写英文字母与数字组成总共最多调用checkIncheckOut和getAverageTime方法2*10与标准答案误差在以内的结果都被视为正确结果",1,3
1135,94,3,73,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个长度为的字符串和，以及一个字符串。请你返回的数目。的定义为：它的长度为，字典序大于等于，字典序小于等于，且不包含为子字符串。由于答案可能很大，请你返回答案对10^9+7取余的结果。,s1.length==ns2.length==ns1<=s21<=n<=5001<=evil.length<=50所有字符串都只包含小写英文字母。,1,3
1136,93,4,10,题库,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数。请你先求出从到的每个整数10进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。,1<=n<=10^4,1,2
1137,58,5,41,题库,1,1,1,0,1,0,0,1,1,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串和一个整数。请你用字符串中构造个非空。如果你可以用中所有字符构造个回文字符串，那么请你返回，否则返回。,1<=s.length<=10^5中所有字符都是小写英文字母。1<=k<=10^5,1,4
1138,106,3,67,题库,0,0,0,0,0,2,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个以表示的圆和一个与坐标轴平行的矩形，其中是矩形左下角的坐标，而是右上角的坐标。如果圆和矩形有重叠的部分，请你返回，否则返回。换句话说，请你检测是否点，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。,"1<=radius<=2000-10<=xCenter,yCenter<=10-10<=x1<x2<=10-10<=y1<y2<=10",1,2
1139,145,3,59,题库,2,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个厨师收集了他道菜的满意程度，这个厨师做出每道菜的时间都是1单位时间。一道菜的「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是*。请你返回做完所有菜「喜爱时间」总和的最大值为多少。你可以按顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。,n==satisfaction.length1<=n<=500-1000<=satisfaction[i]<=1000,1,4
1140,191,3,34,题库,2,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组，请你从中抽取一个子序列，满足该子序列的元素之和大于未包含在该子序列中的各元素之和。如果存在多个解决方案，只需返回的子序列。如果仍然有多个解决方案，则返回的子序列。与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。，题目数据保证满足所有约束条件的解决方案是的。同时，返回的答案应当按排列。,1<=nums.length<=5001<=nums[i]<=100,1,3
1141,96,3,72,题库,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个以二进制形式表示的数字。请你返回按下述规则将其减少到1所需要的步骤数：如果当前数字为偶数，则将其除以2。如果当前数字为奇数，则将其加上1。题目保证你总是可以按上述规则将测试用例变为1。,如果当前数字为偶数，则将其除以2。如果当前数字为奇数，则将其加上1。1<=s.length<=500由字符'0'或'1'组成。s[0]=='1',1,2
1142,90,3,71,题库,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果字符串中不含有任何，或这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。给你三个整数，，，请你返回满足下列全部条件的字符串：如果不存在这样的字符串，请返回一个空字符串。,"是一个尽可能长的快乐字符串。中个字母'a'个字母'b'个字母'c'中只含有'a''b''c'三种字母。0<=a,b,c<=100a+b+c>0",1,3
1143,223,3,52,题库,1,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,Alice和Bob继续他们的石子游戏。几堆石子，每堆石子都对应一个得分，由数组给出。Alice和Bob轮流取石子，总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前。比赛一直持续到所有石头都被拿走。每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。假设Alice和Bob都采取。如果Alice赢了就返回Bob赢了就返回分数相同返回。,1<=stoneValue.length<=5*10-1000<=stoneValue[i]<=1000,1,4
1144,71,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"表：表：写一段SQL,报告每个用户的旅行距离。返回的结果表单，以，如果有两个或者更多的用户旅行了相同的距离,那么再以。查询结果格式如下例所示。",,1,1
1145,93,3,82,题库,3,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组，数组中的每个字符串都可以看作是一个单词。请你按顺序返回中是其他单词的子字符串的所有单词。如果你可以删除最左侧和/或最右侧的若干字符得到，那么字符串就是的一个子字符串。,1<=words.length<=1001<=words[i].length<=30words[i]仅包含小写英文字母。题目数据每个words[i]都是独一无二的。,1,3
1146,63,3,169,题库,2,0,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个待查数组，数组中的元素为到之间的正整数。请你根据以下规则处理所有待查项（从到）：请你以数组形式返回待查数组的查询结果。,"一开始，排列P=[1,2,3,...,m]对于当前的，请你找出待查项queries[i]在排列中的位置（下标从0开始），然后将其从原位置移动到排列的起始位置（即下标为0处）。注意，queries[i]在中的位置就是queries[i]的查询结果。1<=m<=10^31<=queries.length<=m1<=queries[i]<=m",1,3
1147,115,5,174,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,「HTML实体解析器」是一种特殊的解析器，它将HTML代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。HTML里这些特殊字符和它们对应的字符实体包括：给你输入字符串，请你实现一个HTML实体解析器，返回解析器解析后的结果。,双引号：字符实体为&quot;，对应的字符是单引号：字符实体为&apos;，对应的字符是与符号：字符实体为&amp;，对应对的字符是大于号：字符实体为&gt;，对应的字符是小于号：字符实体为&lt;，对应的字符是斜线号：字符实体为&frasl;，对应的字符是1<=text.length<=10^5字符串可能包含256个ASCII字符中的任意字符。,1,2
1148,108,5,41,题库,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,你有一个的网格图，你需要用三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。给你网格图的行数。请你返回给涂色的方案数。由于答案可能会非常大，请你返回答案对取余的结果。,n==grid.lengthgrid[i].length==31<=n<=5000,1,1
1149,108,3,37,题库,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组。你可以选定任意的startValue作为初始值。你需要从左到右遍历数组，并将startValue依次累加上数组中的值。请你在确保累加和始终大于等于1的前提下，选出一个最小的作为startValue。,1<=nums.length<=100-100<=nums[i]<=100,1,2
1150,73,3,31,题库,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你数字，请你返回和为的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。斐波那契数字定义为：数据保证对于给定的，一定能找到可行解。,=1=1=Fn-1+Fn-2，其中n>2。1<=k<=10^9,1,2
1151,112,5,83,题库,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个「开心字符串」定义为：比方说，字符串，和都是开心字符串，但是，和都不是开心字符串。给你两个整数和，你需要将长度为的所有开心字符串按字典序排序。请你返回排序后的第k个开心字符串，如果长度为的开心字符串少于个，那么请你返回。,"仅包含小写字母['a','b','c']对所有在到s.length-1之间的，满足s[i]!=s[i+1]（字符串的下标从1开始）。1<=n<=101<=k<=100",1,2
1152,156,5,40,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在之间，且数组中的数字都没有前导0。给你字符串和整数。可能会有多种不同的数组恢复结果。按照上述程序，请你返回所有可能输出字符串的数组方案数。由于数组方案数可能会很大，请你返回它对后的结果。,1<=s.length<=10^5只包含数字且不包含前导0。1<=k<=10^9,1,2
1153,117,5,32,题库,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个混合了数字和字母的字符串，其中的字母均为小写英文字母。请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。请你返回的字符串；如果无法按要求重新格式化，则返回一个。,1<=s.length<=500仅由小写英文字母和/或数字组成。,1,1
1154,210,3,147,题库,3,0,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，表示客户在餐厅中完成的订单，确切地说，，其中是客户的姓名，是客户所在餐桌的桌号，而是客户点的餐品名称。请你返回该餐厅的在这张表中，表中第一行为标题，其第一列为餐桌桌号“Table”，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。,"1<=orders.length<=5*10^4orders[i].length==31<=customerName.length,foodItem.length<=20customerName和foodItem由大小写英文字母及空格字符''组成。tableNumber是到500范围内的整数。",1,5
1155,163,3,52,题库,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,"给你一个字符串，它表示不同青蛙发出的蛙鸣声（字符串）的组合。由于同一时间可以有多只青蛙呱呱作响，所以中会混合多个请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。要想发出蛙鸣""croak""，青蛙必须输出这5个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串不是由若干有效的""croak""字符混合而成，请返回。",1<=croakOfFrogs.length<=10字符串中的字符只有'c''r''o''a'或者'k',1,2
1156,77,5,84,题库,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你三个整数、和。下图描述的算法用于找出正整数数组中最大的元素。请你生成一个具有下述属性的数组：返回上述条件下生成数组的，由于答案可能会很大，所以对取余。,arr中有个整数。1<=arr[i]<=m其中(0<=i<n)将上面提到的算法应用于arrsearch_cost的值等于1<=n<=501<=m<=1000<=k<=n,1,2
1157,90,3,33,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个由若干0和1组成的字符串，请你计算并返回将该字符串分割成两个子字符串（即子字符串和子字符串）所能获得的最大得分。「分割字符串的得分」为子字符串中的数量加上子字符串中的数量。,2<=s.length<=500字符串仅由字符'0'和'1'组成。,1,1
1158,112,5,71,题库,1,0,0,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,几张卡牌，每张卡牌都有一个对应的点数。点数由整数数组给出。每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿张卡牌。你的点数就是你拿到手中的所有卡牌的点数之和。给你一个整数数组和整数，请你返回可以获得的最大点数。,1<=cardPoints.length<=10^51<=cardPoints[i]<=10^41<=k<=cardPoints.length,1,3
1159,49,4,78,题库,2,0,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个列表，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回中对角线上的整数。,1<=nums.length<=10^51<=nums[i].length<=10^51<=nums[i][j]<=10^9nums中最多有10^5个数字。,1,3
1160,112,3,43,题库,1,1,3,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数，请你返回子序列元素和的最大值，子序列需要满足：子序列中每两个的整数和，它们在原数组中的下标和满足且。数组的子序列定义为：将数组中的若干个数字删除（可以删除0个数字），剩下的数字按照原本的顺序排布。,1<=k<=nums.length<=10^5-10^4<=nums[i]<=10^4,1,6
1161,90,3,59,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组和一个整数，其中代表第个孩子拥有的糖果数目。对每一个孩子，检查是否存在一种方案，将额外的个糖果分配给孩子们之后，此孩子有的糖果。注意，允许有多个孩子同时拥有的糖果数目。,2<=candies.length<=1001<=candies[i]<=1001<=extraCandies<=50,1,1
1162,45,5,90,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数。你可以对它进行如下步骤恰好：令两次对的操作得到的结果分别为和。请你返回和的。,选择一个数字x(0<=x<=9)选择另一个数字y(0<=y<=9)。数字可以等于num中所有出现的数位都用替换。得到的新的整数有前导0，得到的新整数也是0。1<=num<=10^8,1,2
1163,105,3,50,题库,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你两个字符串和，它们长度相等，请你检查是否存在一个的排列可以打破的一个排列，或者是否存在一个的排列可以打破的一个排列。字符串可以打破字符串（两者长度都为）需满足对于所有（在到之间）都有（字典序意义下的顺序）。,s1.length==ns2.length==n1<=n<=10^5所有字符串都只包含小写英文字母。,0,3
1164,110,4,83,题库,1,1,0,0,2,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,总共有个人和种不同的帽子，帽子编号从到。给你一个整数列表的列表，其中是第个人所有喜欢帽子的列表。请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。由于答案可能很大，请返回它对取余后的结果。,n==hats.length1<=n<=101<=hats[i].length<=401<=hats[i][j]<=40hats[i]包含一个数字互不相同的整数列表。,1,4
1165,108,3,104,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一份旅游线路图，该线路图中的旅行线路用数组表示，其中表示该线路将会从直接前往。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。,"1<=paths.length<=100paths[i].length==21<=cityA.length,cityB.length<=10cityA!=cityB所有字符串均由大小写英文字母和空格字符组成。",1,2
1166,41,4,48,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由若干和组成的数组以及整数。如果所有都至少相隔个元素，则返回；否则，返回。,1<=nums.length<=10^50<=k<=nums.lengthnums[i]的值为或,1,1
1167,79,3,50,题库,1,0,4,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，和一个表示限制的整数，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于如果不存在满足条件的子数组，则返回。,1<=nums.length<=10^51<=nums[i]<=10^90<=limit<=10^9,1,6
1168,71,4,89,题库,2,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的矩阵，以及一个整数，矩阵中的每一行都以非递减的顺序排列。你可以从每一行中选出1个元素形成一个数组。返回所有可能数组中的第k个数组和。,"m==mat.lengthn==mat.length[i]1<=m,n<=401<=k<=min(200,n^m)1<=mat[i][j]<=5000mat[i]是一个非递减数组",1,4
1169,107,3,125,题库,2,0,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个数组和一个整数。每次迭代，需要从中依次读取一个数字。请使用下述操作来构建目标数组：题目数据保证目标数组严格递增，并且只包含到之间的数字。请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。,"""Push""：从list中读取一个新元素，并将其推入数组中。""Pop""：删除数组中的最后一个元素。如果目标数组构建完成，就停止读取更多元素。1<=target.length<=1001<=n<=1001<=target[i]<=ntarget严格递增",1,3
1170,61,5,91,题库,1,0,1,0,2,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个整数数组。现需要从数组中取三个下标、和，其中。和定义如下：注意：表示操作。请返回能够令成立的三元组(,,)的数目。",a=arr[i]^arr[i+1]^...^arr[j-1]b=arr[j]^arr[j+1]^...^arr[k]1<=arr.length<=3001<=arr[i]<=10^8,1,5
1171,141,3,74,题库,0,2,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵有个节点的无向树，节点编号为到，它们中有一些节点有苹果。通过树上的一条边，需要花费1秒钟。你从出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点0。无向树的边由给出，其中，表示有一条边连接和。除此以外，还有一个布尔数组，其中代表节点有一个苹果，否则，节点没有苹果。,1<=n<=10^5edges.length==n-1edges[i].length==20<=a<b<=n-1hasApple.length==n,1,4
1172,240,3,80,题库,2,2,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个大小的矩形披萨和一个整数，矩形包含两种字符：（表示苹果）和（表示空白格子）。你需要切披萨次，得到块披萨并送给别人。切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。请你返回确保每一块披萨包含一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对10^9+7取余的结果。,"1<=rows,cols<=50rows==pizza.lengthcols==pizza[i].length1<=k<=10pizza只包含字符'A'和'.'",1,4
1173,45,2,26,题库,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，字符串的定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的。,1<=s.length<=500只包含小写英文字母。,1,1
1174,48,4,9,题库,1,0,0,0,0,2,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你返回所有0到1之间（不包括0和1）满足分母小于等于的分数。分数可以以顺序返回。,1<=n<=100,1,3
1175,65,3,41,题库,0,2,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵根为的二叉树，请你返回二叉树中好节点的数目。「好节点」X定义为：从根到该节点X所经过的节点中，没有任何节点的值大于X的值。,"二叉树中节点数目范围是[1,10^5]每个节点权值的范围是[-10^4,10^4]",1,4
1176,78,4,113,题库,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给你一个整数数组和一个整数。请你返回满足如下规则可以得到的整数：由于答案可能会很大，请你以字符串形式返回。如果按照上述要求无法得到任何整数，请你返回""0""。",给当前结果添加一个数位（i+1）的成本为cost[i]cost数组下标从0开始）。总成本必须恰好等于target添加的数位中没有数字0。cost.length==91<=cost[i]<=50001<=target<=5000,1,2
1177,100,5,107,题库,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数数组（开始时间）和（结束时间），并指定一个整数作为查询时间。已知，第名学生在时开始写作业并于时完成作业。请返回在查询时间时正在做作业的学生人数。形式上，返回能够使处于区间（含）的学生人数。,startTime.length==endTime.length1<=startTime.length<=1001<=startTime[i]<=endTime[i]<=10001<=queryTime<=1000,1,1
1178,101,3,80,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子:请你重新排列中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。请同样按上述格式返回新的句子。,句子的首字母大写text中的每个单词都用单个空格分隔。text以大写字母开头，然后包含若干小写字母以及单词间的单个空格。1<=text.length<=10^5,1,2
1179,67,3,233,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，其中是第名用户收藏的公司清单（）。请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标下标需要按升序排列,1<=favoriteCompanies.length<=1001<=favoriteCompanies[i].length<=5001<=favoriteCompanies[i][j].length<=20favoriteCompanies[i]中的所有字符串各不相同用户收藏的公司清单也各不相同，也就是说，即便我们按字母顺序排序每个清单，favoriteCompanies[i]!=favoriteCompanies[j]仍然成立。所有字符串仅包含小写英文字母。,1,3
1180,136,2,73,题库,1,0,0,0,0,2,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Alice向一面非常大的墙上掷出支飞镖。给你一个数组，其中表示Alice掷出的第支飞镖落在墙上的位置。Bob知道墙上所有支飞镖的位置。他想要往墙上放置一个半径为的圆形靶。使Alice掷出的飞镖尽可能多地落在靶上。给你整数，请返回能够落在半径为的圆形靶内或靶上的最大飞镖数。,"1<=darts.length<=100darts[i].length==2-10<=x,y<=10darts中的元素互不相同1<=r<=5000",1,3
1181,147,3,88,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串作为句子并指定检索词为，其中句子由若干用分隔的单词组成。请你检查检索词是否为句子中任意单词的前缀。如果是某一个单词的前缀，则返回句子中该单词所对应的下标（）。如果是多个单词的前缀，则返回匹配的第一个单词的下标（）。如果不是任何单词的前缀，则返回。字符串的是的任何前导连续子字符串。,1<=sentence.length<=1001<=searchWord.length<=10sentence由小写英文字母和空格组成。searchWord由小写英文字母组成。,1,2
1182,52,5,40,题库,1,0,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你字符串和整数。请返回字符串中长度为的单个子字符串中可能包含的最大元音字母数。英文中的为（,,,,）。",1<=s.length<=10^5由小写英文字母组成1<=k<=s.length,1,2
1183,88,3,32,题库,0,2,2,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树，每个节点的值为1到9。我们称二叉树中的一条路径是「」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。请你返回从根到叶子节点的所有路径中路径的数目。,"给定二叉树的节点数目在范围[1,101<=Node.val<=9",1,5
1184,100,3,62,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个数组和。请你返回和中两个长度相同的子序列的最大点积。数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，是的一个子序列而不是。,"1<=nums1.length,nums2.length<=500-1000<=nums1[i],nums2[i]<=100",1,2
1185,46,3,80,题库,2,0,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个长度相同的整数数组和。每一步中，你可以选择的任意并将它翻转。你可以执行此过程任意次。,target.length==arr.length1<=target.length<=10001<=target[i]<=10001<=arr[i]<=1000,1,3
1186,46,3,39,题库,1,0,1,0,3,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个二进制字符串和一个整数。如果所有长度为的二进制字符串都是的子串，请返回，否则请返回。,1<=s.length<=5*10s[i]不是'0'就是'1'1<=k<=20,1,5
1187,150,3,216,题库,0,2,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你总共需要上门课，课程编号依次为到。你会得到一个数组，其中表示如果你想选课程，你先选课程。先决条件也可以是的。如果课程是课程的先决条件，课程是课程的先决条件，那么课程就是课程的先决条件。你也得到一个数组，其中。对于第个查询，您应该回答课程是否是课程的先决条件。返回一个布尔数组，其中是第个查询的答案。,"有的课会有直接的先修课程，比如如果想上课程，你必须先上课程，那么会以[0,1]数对的形式给出先修课程数对。2<=numCourses<=1000<=prerequisites.length<=(numCourses*(numCourses-1)/2)prerequisites[i].length==20<=a,b<=n-1!=b每一对,b都先修课程图中没有环。1<=queries.length<=100<=u,v<=n-1!=v",1,4
1188,103,4,246,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的矩阵来表示一块樱桃地。中每个格子的数字表示你能获得的樱桃数目。你有两个机器人帮你收集樱桃，机器人1从左上角格子出发，机器人2从右上角格子出发。请你按照如下规则，返回两个机器人能收集的最多樱桃数目：,"从格子(i,j)出发，机器人可以移动到格子(i+1,j-1)(i+1,j)或者(i+1,j+1)当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。两个机器人在任意时刻都不能移动到grid外面。两个机器人最后都要到达grid最底下一行。rows==grid.lengthcols==grid[i].length2<=rows,cols<=700<=grid[i][j]<=100",1,3
1189,44,3,35,题库,2,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请你选择数组的两个不同下标和使取得最大值。请你计算并返回该式的最大值。,2<=nums.length<=5001<=nums[i]<=10^3,1,3
1190,88,3,249,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,矩形蛋糕的高度为且宽度为，给你两个整数数组和，其中：请你按数组和中提供的水平和竖直位置切割后，请你找出的那份蛋糕，并返回其。由于答案可能是一个很大的数字，因此需要将结果后返回。,"horizontalCuts[i]是从矩形蛋糕顶部到第个水平切口的距离verticalCuts[j]是从矩形蛋糕的左侧到第个竖直切口的距离2<=h,w<=101<=horizontalCuts.length<=min(h-1,101<=verticalCuts.length<=min(w-1,101<=horizontalCuts[i]<h1<=verticalCuts[i]<w题目数据保证horizontalCuts中的所有元素各不相同题目数据保证verticalCuts中的所有元素各不相同",1,3
1191,203,3,138,题库,0,2,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,座城市，从到编号，其间共有条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。路线用表示，其中表示从城市到的一条有向路线。今年，城市0将会举办一场大型比赛，很多游客都想前往城市0。请你帮助重新规划路线方向，使每个城市都可以访问城市0。返回需要变更方向的最小路线数。题目数据每个城市在重新规划路线方向后都能到达城市0。,"2<=n<=5*10^4connections.length==n-1connections[i].length==20<=connections[i][0],connections[i][1]<=n-1connections[i][0]!=connections[i][1]",1,3
1192,197,3,45,题库,1,2,0,0,0,3,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,桌面上有个颜色不完全相同的球，球上的颜色共有种。给你一个大小为的整数数组，其中是颜色为的球的数量。所有的球都已经，前个球放入第一个盒子，后个球放入另一个盒子（请认真阅读示例2的解释部分）。这两个盒子是不同的。例如，两个球颜色分别为和，盒子分别为和，那么和这两种分配方式是不同的（请认真阅读示例的解释部分）。请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在以内，则被视为正确答案,1<=balls.length<=81<=balls[i]<=6sum(balls)是偶数,1,6
1193,44,3,40,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组，数组中有个元素，按的格式排列。请你将数组按格式重新排列，返回重排后的数组。,1<=n<=500nums.length==2n1<=nums[i]<=10^3,1,1
1194,134,5,275,题库,2,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。设为数组的中位数，只要满足下述两个前提之一，就可以判定的值比的值更强：请返回由数组中最强的个值组成的列表。答案可以以返回。是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为，那么中位数就是该有序列表（下标从0开始）中位于的元素。,"|arr[i]-m|>|arr[j]-m||arr[i]-m|==|arr[j]-m|，且arr[i]>arr[j]例如arr=[6,-3,7,2,11]n=5：数组排序后得到arr=[-3,2,6,7,11]，数组的中间位置为m=((5-1)/2)=2，中位数arr[m]的值为例如arr=[-7,22,17, 3]n=4：数组排序后得到arr=[-7,3,17,22]，数组的中间位置为m=((4-1)/2)=1，中位数arr[m]的值为1<=arr.length<=10^5-10^5<=arr[i]<=10^51<=k<=arr.length",1,3
1195,59,1,388,题库,1,0,3,0,0,0,2,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有一个只支持单个标签页的，最开始你浏览的网页是，你可以访问其他的网站，也可以在浏览历史中后退步或前进步。请你实现类：,BrowserHistory(stringhomepage)，用homepage初始化浏览器类。voidvisit(stringurl)从当前页跳转访问url对应的页面。执行此操作会把浏览历史前进的记录全部删除。stringback(intsteps)在浏览历史中后退steps步。如果你只能在浏览历史中后退至多步且steps>x，那么你只后退步。请返回后退steps步以后的urlstringforward(intsteps)在浏览历史中前进steps步。如果你只能在浏览历史中前进至多步且steps>x，那么你只前进步。请返回前进steps步以后的url1<=homepage.length<=201<=url.length<=201<=steps<=100homepage和url都只包含'.'或者小写英文字母。最多调用5000次visitback和forward函数。,1,6
1196,183,4,169,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在一个小城市里，有个房子排成一排，你需要给每个房子涂上种颜色之一（颜色编号为到）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。我们将连续相同颜色尽可能多的房子称为一个街区。（比方说，它包含5个街区。）给你一个数组，一个的矩阵和一个整数，其中：请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成个街区。如果没有可用的涂色方案，请返回。,houses[i]：是第个房子的颜色，表示这个房子还没有被涂色。cost[i][j]：是将第个房子涂成颜色j+1的花费。m==houses.length==cost.lengthn==cost[i].length1<=m<=1001<=n<=201<=target<=m0<=houses[i]<=n1<=cost[i][j]<=10^4,1,2
1197,119,3,39,题库,1,0,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组，其中是商店里第件商品的价格。商店里正在进行促销活动，如果你要买第件商品，那么你可以得到与相等的折扣，其中是满足且的，如果没有满足条件的，你将没有任何折扣。请你返回一个数组，数组中第个元素是折扣后你购买商品最终需要支付的价格。,1<=prices.length<=5001<=prices[i]<=10^3,1,3
1198,49,2,260,题库,2,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你实现一个类，它的构造函数的参数是一个的矩形（这里用整数矩阵表示），并支持以下两种操作：1.2.,"newValue更新以(row1,col1)为左上角且以(row2,col2)为右下角的子矩形。返回矩形中坐标(row,col)的当前值。最多有500updateSubrectangle和getValue操作。1<=rows,cols<=100rows==rectangle.lengthcols==rectangle[i].length0<=row1<=row2<rows0<=col1<=col2<cols1<=newValue,rectangle[i][j]<=10^90<=row<rows0<=col<cols",1,3
1199,90,5,49,题库,1,2,1,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数值。请你在中找且它们的和都等于。可能会有多种方案，请你返回满足要求的两个子数组长度和的。请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回。,1<=arr.length<=10^51<=arr[i]<=10001<=target<=10^8,1,5
1200,87,4,67,题库,2,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,给你一个房屋数组和一个整数，其中是第栋房子在一条街上的位置，现需要在这条街上安排个邮筒。请你返回每栋房子与离它最近的邮筒之间的距离的总和。答案保证在32位有符号整数范围以内。,n==houses.length1<=n<=1001<=houses[i]<=10^41<=k<=n数组houses中的整数互不相同。,1,4
1201,30,3,40,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组。数组「动态和」的计算公式为：。请返回的动态和。,1<=nums.length<=1000-10^6<=nums[i]<=10^6,1,2
1202,48,2,50,题库,2,1,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。现需要从数组中恰好移除个元素，请找出移除后数组中不同整数的最少数目。,1<=arr.length<=10^51<=arr[i]<=10^90<=k<=arr.length,1,5
1203,96,5,65,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，以及两个整数和。现需要制作束花。制作花束时，需要使用花园中。花园中有朵花，第朵花会在时盛开，可以用于花中。请你返回从花园中摘束花需要等待的最少的天数。如果不能摘到束花则返回。,bloomDay.length==n1<=n<=10^51<=bloomDay[i]<=10^91<=m<=10^61<=k<=n,1,2
1204,87,1,189,题库,0,3,1,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一棵树，树上有个节点，按从到编号。树以父节点数组的形式给出，其中是节点的父节点。树的根节点是编号为的节点。树节点的第个祖先节点是从该节点到根节点路径上的第个节点。实现类：,"TreeAncestor（intn，int[]parent）对树和父数组中的节点数初始化对象。getKthAncestor(intnode,intk)返回节点node的第个祖先节点。如果不存在这样的祖先节点，返回1<=k<=n<=5*10parent[0]==-1表示编号为的节点是根节点。对于所有的0<i<n0<=parent[i]<n总成立0<=node<n至多查询5*10",1,5
1205,71,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"表：查询每个日期、销售的不同产品的数量及其名称。
每个日期的销售产品名称应按词典序排列。
返回按排序的结果表。
查询结果格式如下例所示。",,1,1
1206,46,4,38,题库,0,0,0,0,1,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数，和。数组定义为：（下标从0开始）且。请返回中所有元素按位异或（）后得到的结果。,1<=n<=10000<=start<=1000n==nums.length,1,2
1207,152,5,72,题库,2,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的字符串数组。你将会在文件系统中创建个文件夹：在第分钟，新建名为的文件夹。由于两个文件共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以的形式为新文件夹的文件名添加后缀，其中是能保证文件名唯一的。返回长度为的字符串数组，其中是创建第个文件夹时系统分配给该文件夹的实际名称。,1<=names.length<=5*10^41<=names[i].length<=20names[i]由小写英文字母、数字和/或圆括号组成。,1,3
1208,191,3,184,题库,1,2,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你的国家有无数个湖泊，所有湖泊一开始都是空的。当第个湖泊下雨前是空的，那么它就会装满水。如果第个湖泊下雨前是，这个湖泊会发生。你的目标是避免任意一个湖泊发生洪水。给你一个整数数组，其中：请返回一个数组，满足：如果有多种可行解，请返回它们中的。如果没办法阻止洪水，请返回一个。请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。,rains[i]>0表示第天时，第rains[i]个湖泊会下雨。rains[i]==0表示第天没有湖泊会下雨，你可以选择湖泊并这个湖泊的水。ans.length==rains.length如果rains[i]>0，那么ans[i]==-1如果rains[i]==0ans[i]是你第天选择抽干的湖泊。1<=rains.length<=100<=rains[i]<=10,1,5
1209,230,2,109,题库,1,0,3,1,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个点的带权无向连通图，节点编号为到，同时还有一个数组，其中表示在和节点之间有一条带权无向边。最小生成树(MST)是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。,"2<=n<=1001<=edges.length<=min(200,n*(n-1)/2)edges[i].length==30<=from<to<n1<=weight<=1000所有(from,to数对都是互不相同的。",1,5
1210,59,4,82,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，数组里每个数都是的，其中是第个员工的工资。请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。,3<=salary.length<=10010^3<=salary[i]<=10^6salary[i]是唯一的。与真实值误差在10^-5以内的结果都将视为正确答案。,1,2
1211,97,3,13,题库,0,0,0,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个正整数和。如果正整数满足，那么我们就说正整数是整数的因子。考虑整数的所有因子，将它们。请你返回第个因子。如果的因子数少于，请你返回。你可以设计时间复杂度小于O(n)的算法来解决此问题吗？,1<=k<=n<=1000,1,2
1212,73,2,31,题库,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个二进制数组，你需要从中删掉一个元素。请你在删掉元素的结果数组中，返回最长的且只包含1的非空子数组的长度。如果不存在这样的子数组，请返回0。,1<=nums.length<=10nums[i]要么是要么是,1,3
1213,140,3,135,题库,0,1,1,0,2,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数表示某所大学里课程的数目，编号为到，数组中，表示一个先修课的关系，也就是课程必须在课程之前上。同时你还有一个整数。在一个学期中，你可以同时上门课，前提是这些课的先修课在之前的学期里已经上过了。请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。,"1<=n<=151<=k<=n0<=relations.length<=n*(n-1)/2relations[i].length==21<=x,y<=n!=y所有先修关系都是不同的，也就是说relations[i]!=relations[j]题目输入的图是个有向无环图。",1,4
1214,109,2,39,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，其中的值可以是、、或者，分别表示向北、向南、向东、向西移动一个单位。你从二维平面上的原点处开始出发，按所指示的路径行走。如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回；否则，返回。,1<=path.length<=10path[i]为'N''S''E'或'W',1,2
1215,75,3,47,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，其中数组长度是偶数，值为。现在需要把数组恰好分成对，以使每对数字的和都能够被整除。如果存在这样的分法，请返回；否则，返回。,arr.length==n1<=n<=10为偶数-10<=arr[i]<=101<=k<=10,1,3
1216,69,3,45,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。请你统计并返回中能满足其最小元素与最大元素的小于或等于的子序列的数目。由于答案可能很大，请将结果对取余后返回。,1<=nums.length<=101<=nums[i]<=101<=target<=10,1,4
1217,97,2,158,题库,1,0,3,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组和一个整数。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标x的值从小到大排序。也就是说，并且在的前提下，总成立。请你找出的，其中且。题目测试数据保证至少存在一对能够满足的点。,"2<=points.length<=10^5points[i].length==2-10^8<=points[i][0],points[i][1]<=10^80<=k<=2*10^8对于所有的1<=i<j<=points.lengthpoints[i][0]<points[j][0]都成立。也就是说，是严格递增的。",1,5
1218,71,2,38,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数字数组。如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为。如果可以重新排列数组形成等差数列，请返回；否则，返回。,2<=arr.length<=1000-10^6<=arr[i]<=10^6,1,2
1219,198,3,145,题库,2,0,0,0,0,0,1,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一块木板，长度为个。一些蚂蚁在木板上移动，每只蚂蚁都以的速度移动。其中，一部分蚂蚁向移动，其他蚂蚁向移动。当两只向方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。而当蚂蚁在某一时刻到达木板的一端时，它立即从木板上掉下来。给你一个整数和两个整数数组以及。两个数组分别标识向左或者向右移动的蚂蚁在时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。,1<=n<=10^40<=left.length<=n+10<=left[i]<=n0<=right.length<=n+10<=right[i]<=n1<=left.length+right.length<=n+1left和right中的所有值都是唯一的，并且每个值只能出现在二者之一中。,1,3
1220,28,2,24,题库,2,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的二进制矩阵，请你返回有多少个的元素全部都是1。,"1<=m,n<=150mat[i][j]仅包含或",1,5
1221,88,5,43,题库,1,1,0,2,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串和一个整数。其中，表示一个很大的整数，字符串中的每个字符依次对应整数上的各个。你可以交换这个整数相邻数位的数字次。请你返回你能得到的最小整数，并以字符串形式返回。,1<=num.length<=30000num只包含且不含有前导01<=k<=10^9,1,4
1222,33,3,218,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，它的格式为，其中：请你将字符串转变为的格式，其中：,"Day是集合{""1st"",""2nd"",""3rd"",""4th"",...,""30th"",""31st""}中的一个元素。Month是集合{""Jan"",""Feb"",""Mar"",""Apr"",""May"",""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",""Nov"",""Dec""}中的一个元素。Year的范围在​[1900,2100]之间。YYYY表示4位的年份。表示2位的月份。表示2位的天数。给定日期保证是合法的，所以不需要处理异常输入。",1,1
1223,111,3,74,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，它包含个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含个数字的数组。请你返回在新数组中下标为到的所有数字和（包括左右端点）。由于答案可能很大，请你将它对10^9+7取模后返回。,1<=nums.length<=10^3nums.length==n1<=nums[i]<=1001<=left<=right<=n*(n+1)/2,1,4
1224,48,3,34,题库,2,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组。每次操作你可以选择中的任意一个元素并将它改成。在，返回中最大值与最小值的最小差值。,1<=nums.length<=10-10<=nums[i]<=10,1,3
1225,139,5,10,题库,0,1,0,0,0,2,0,1,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Alice和Bob两个人轮流玩一个游戏，Alice先手。一开始，有个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走非零个石子。如果石子堆里没有石子了，则无法操作的玩家输掉游戏。给你正整数，且已知两个人都采取最优策略。如果Alice会赢得比赛，那么返回，否则返回。,1<=n<=10^5,1,3
1226,41,3,34,题库,1,0,1,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组。如果一组数字满足==且<，就可以认为这是一组。返回好数对的数目。,1<=nums.length<=1001<=nums[i]<=100,1,4
1227,72,4,36,题库,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个二进制字符串（仅由'0'和'1'组成的字符串）。返回所有字符都为1的子字符串的数目。由于答案可能很大，请你将它对10^9+7取模后返回。,s[i]=='0'或s[i]=='1'1<=s.length<=10^5,1,2
1228,153,3,116,题库,1,0,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由个节点（下标从0开始）组成的无向加权图，该图由一个描述边的列表组成，其中表示连接节点a和b的一条无向边，且该边遍历成功的概率为。指定两个节点分别作为起点和终点，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。如果不存在从到的路径，请。只要答案与标准答案的误差不超过，就会被视作正确答案。,"2<=n<=10^40<=start,end<nstart!=end0<=a,b<na!=b0<=succProb.length==edges.length<=2*10^40<=succProb[i]<=1每两个节点之间最多有一条边",1,4
1229,158,2,56,题库,0,0,0,0,0,3,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心。给你一个数组，其中表示第个客户在二维地图上的位置，返回到所有客户的换句话说，请你为服务中心选址，该位置的坐标需要使下面的公式取到最小值：与真实值误差在之内的答案将被视作正确答案。,"1<=positions.length<=50positions[i].length==20<=x,y<=100",1,3
1230,53,1,68,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,用户表：查询拥有的用户。有效的邮箱包含符合下列条件的前缀名和域名：按任意顺序返回结果表。查询格式如下所示。,前缀名是包含字母（大写或小写）、数字、下划线'_'、句点'.'和/或横杠'-'的字符串。前缀名以字母开头。'@leetcode.com',1,1
1231,79,2,37,题库,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,超市正在促销，你可以用个空水瓶从超市兑换一瓶水。最开始，你一共购入了瓶水。如果喝掉了水瓶中的水，那么水瓶就会变成空的。给你两个整数和，返回你可以喝到多少瓶水。,1<=numBottles<=1002<=numExchange<=100,1,2
1232,180,3,88,题库,0,2,2,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵树（即，一个连通的无环无向图），这棵树由编号从到的n个节点组成，且恰好有条。树的根节点为节点，树上的每一个节点都有一个标签，也就是字符串中的一个小写字符（编号为的节点的标签就是）边数组以的形式给出，该格式表示节点和之间存在一条边。返回一个大小为的数组，其中表示第个节点的子树中与节点标签相同的节点数。树中的子树是由中的某个节点及其所有后代节点组成的树。,"1<=n<=10^5edges.length==n-1edges[i].length==20<=a,b<n!=blabels.length==nlabels仅由小写英文字母组成",1,5
1233,134,2,27,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个只包含小写字母的字符串，你需要找到中最多数目的非空子字符串，满足如下条件：请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。请注意，你可以以顺序返回最优解的子字符串。,1<=s.length<=10^5只包含小写英文字母。,1,2
1234,68,3,49,题库,1,1,0,1,1,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Winston构造了一个如上所示的函数。他有一个整数数组和一个整数，他想找到让最小的和。请你返回的最小值。请注意，的输入参数和需要满足。,1<=arr.length<=10^51<=arr[i]<=10^60<=target<=10^7,1,4
1235,29,2,18,题库,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你两个非负整数和。请你返回和之间（包括二者）奇数的数目。,0<=low<=high<=10^9,1,1
1236,44,5,33,题库,1,1,0,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。请你返回和为的子数组数目。由于答案可能会很大，请你将结果对取余后返回。,1<=arr.length<=10^51<=arr[i]<=100,1,4
1237,69,4,27,题库,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，一个分割被称为「好分割」当它满足：将分割成2个字符串和，它们连接起来等于且和中不同字符的数目相同。请你返回中好分割的数目。,只包含小写英文字母。1<=s.length<=10^5,1,3
1238,78,4,68,题库,1,2,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个数组，数组与数组有同样的维度，且一开始全部为0。请你返回从得到的最少操作次数，每次操作需遵循以下规则：答案保证在32位有符号整数以内。,initial中选择子数组，并将子数组中每个元素增加1。1<=target.length<=10^51<=target[i]<=10^5,1,5
1239,111,1,0,题库,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,患者信息表：查询患有I类糖尿病的患者ID（patient_id）、患者姓名（patient_name）以及其患有的所有疾病代码（conditions）。I类糖尿病的代码总是包含前缀。按返回结果表。查询结果格式如下示例所示。,,1,1
1240,55,2,74,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串和一个的整数数组。请你重新排列字符串，其中第个字符需要移动到指示的位置。返回重新排列后的字符串。,s.length==indices.length==n1<=n<=100仅包含小写英文字母0<=indices[i]<nindices的所有的值都是,1,2
1241,110,3,41,题库,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为、下标从开始的二进制字符串。你自己有另一个长度为的二进制字符串，最初每一位上都是0。你想要让和相等。在一步操作，你可以选择下标（）并翻转在内的所有位。翻转意味着变为，而变为。返回使与相等需要的最少翻转次数。,n==target.length1<=n<=10target[i]为'0'或'1',1,2
1242,51,5,54,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根节点和一个整数。如果二叉树中两个节点之间的小于或者等于，那它们就可以构成一组。返回树中。,"tree的节点数在[1,2^10]范围内。每个节点的值都在[1,100]之间。1<=distance<=10",1,3
1243,171,3,39,题库,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,是一种常用的字符串压缩方法，它将连续的相同字符（重复2次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串，将替换为，替换为`。因此压缩后的字符串变为。注意，本问题中，压缩时没有在单个字符后附加计数。给你一个字符串和一个整数。你需要从字符串中删除最多个字符，以使的行程长度编码长度最小。请你返回删除最多个字符后，。,1<=s.length<=1000<=k<=s.length仅包含小写英文字母,1,2
1244,66,2,120,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，以及、、三个整数。请你统计其中好三元组的数量。如果三元组满足下列全部条件，则认为它是一个。其中表示的绝对值。返回。,"0<=i<j<k<arr.length|arr[i]-arr[j]|<=a|arr[j]-arr[k]|<=b|arr[i]-arr[k]|<=c3<=arr.length<=1000<=arr[i]<=10000<=a,b,c<=1000",1,2
1245,136,4,56,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由整数组成的整数数组和一个整数。每回合游戏都在数组的前两个元素（即和）之间进行。比较与的大小，较大的整数将会取得这一回合的胜利并保留在位置，较小的整数移至数组的末尾。当一个整数赢得个连续回合时，游戏结束，该整数就是比赛的。返回赢得比赛的整数。题目数据游戏存在赢家。,2<=arr.length<=10^51<=arr[i]<=10^6arr所含的整数各不相同1<=k<=10^9,1,2
1246,109,3,56,题库,2,1,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的二进制网格，每一次操作中，你可以选择网格的进行交换。一个符合要求的网格需要满足主对角线以上的格子全部都是。请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回。主对角线指的是从到的这些格子。,n==grid.lengthn==grid[i].length1<=n<=200grid[i][j]要么是要么是,1,3
1247,88,4,199,题库,1,2,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有两个且数组内元素互不相同的数组和。一条定义如下：得分定义为合法路径中不同数字的和。请你返回所有可能合法路径中的最大得分。由于答案可能很大，请你将它对10^9+7取余后返回。,"选择数组nums1或者nums2开始遍历（从下标0处开始）。从左到右遍历当前数组。如果你遇到了nums1和nums2中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。1<=nums1.length<=10^51<=nums2.length<=10^51<=nums1[i],nums2[i]<=10^7nums1和nums2都是严格递增的数组。",1,4
1248,62,2,83,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的正整数数组和一个整数。请你找到这个数组里第个缺失的正整数。你可以设计一个时间复杂度小于O(n)的算法解决此问题吗？,1<=arr.length<=10001<=arr[i]<=10001<=k<=1000对于所有1<=i<j<=arr.length的和满足arr[i]<arr[j],1,2
1249,163,3,110,题库,1,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串和，你的目标是在次操作以内把字符串转变成。在第次操作时（），你可以选择进行如下操作：切换1个字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以切换后会变成）。第次操作意味着该字符应切换次请记住任意一个下标最多只能被操作1次。如果在不超过次操作内可以把字符串转变成，那么请你返回，否则请你返回。,"选择字符串中满足1<=j<=s.length且之前未被选过的任意下标（下标从1开始），并将此位置的字符切换次。不进行任何操作。1<=s.length,t.length<=10^50<=k<=10^9和只包含小写英文字母。",1,2
1250,97,5,77,题库,1,1,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个括号字符串，它只包含字符和。一个括号字符串被称为平衡的当它满足：比方说，和都是平衡的，，和都是不平衡的。你可以在任意位置插入字符'('和')'使字符串平衡。请你返回让平衡的最少插入次数。,任何左括号'('必须对应两个连续的右括号'))'左括号'('必须在对应的连续两个右括号'))'之前。1<=s.length<=10^5只包含'('和')',1,3
1251,39,4,65,题库,1,0,1,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串。请返回中最长的的长度。「超赞子字符串」需满足满足下述两个条件：,该字符串是的一个非空子字符串进行任意次数的字符交换后，该字符串可以变成一个回文字符串1<=s.length<=10^5仅由数字组成,1,3
1252,158,3,86,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由大小写英文字母组成的字符串。一个整理好的字符串中，两个相邻字符和，其中，要满足如下条件:请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的字符并删除，直到字符串整理好为止。请返回整理好的。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。空字符串也属于整理好的字符串，尽管其中没有任何字符。,s[i]是小写字符，则s[i+1]不可以是相同的大写字符。s[i]是大写字符，则s[i+1]不可以是相同的小写字符。1<=s.length<=100只包含小写和大写英文字母,1,2
1253,113,4,88,题库,1,1,0,0,0,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你两个正整数和，二进制字符串的形成规则如下：其中表示串联操作，返回反转后得到的字符串，而则会翻转x中的每一位（0变为1，而1变为0）。例如，符合上述描述的序列的前4个字符串依次是：请你返回的，题目数据保证一定在长度范围以内。,"=""0""i>1时，=Si-1+""1""+reverse(invert(Si-1=""0""=""0=""011001""=""01110010110001""1<=n<=201<=k<=2-1",1,2
1254,38,4,55,题库,1,1,1,0,1,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组和一个整数。请你返回子数组的最大数目，且每个子数组中数字和都为。,1<=nums.length<=10^5-10^4<=nums[i]<=10^40<=target<=10^6,1,4
1255,201,2,70,题库,2,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一根长度为个单位的木棍，棍上从到标记了若干位置。例如，长度为的棍子可以标记如下：给你一个整数数组，其中表示你需要将棍子切开的位置。你可以按顺序完成切割，也可以根据需要更改切割的顺序。每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。返回切棍子的。,"2<=n<=10^61<=cuts.length<=min(n-1,100)1<=cuts[i]<=n-1cuts数组中的所有整数都互不相同",1,3
1256,49,2,34,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回；否则，返回。,1<=arr.length<=10001<=arr[i]<=1000,1,1
1257,134,2,10,题库,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,存在一个长度为的数组，其中（）。一次操作中，你可以选出两个下标，记作和（）并使减去、加上（即且）。最终的目标是使数组中的所有元素都。题目测试用例将会：在执行若干步操作后，数组中的所有元素最终可以全部相等。给你一个整数，即数组的长度。请你返回使数组中所有元素相等所需的。,1<=n<=10^4,1,1
1258,151,2,87,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在代号为C-137的地球上，Rick发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick有个空的篮子，第个篮子的位置在，Morty想把个球放到这些篮子里，使得任意两球间最大。已知两个球如果分别位于和，那么它们之间的磁力为。给你一个整数数组和一个整数，请你返回最大化的最小磁力。,n==position.length2<=n<=10^51<=position[i]<=10^9所有position中的整数互不相同2<=m<=position.length,1,3
1259,67,4,77,题库,0,2,0,0,0,0,0,0,0,0,0,1,1,1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,厨房里总共有个橘子，你决定每一天选择如下方式之一吃这些橘子：每天你只能从以上3种方案中选择一种方案。请你返回吃掉所有个橘子的最少天数。,吃掉一个橘子。如果剩余橘子数能被2整除，那么你可以吃掉n/2个橘子。如果剩余橘子数能被3整除，那么你可以吃掉2*(n/3)个橘子。1<=n<=2*10^9,1,2
1260,45,4,9,题库,1,0,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你一个整数，请你每隔三位添加点（即"".""符号）作为千位分隔符，并将结果以字符串格式返回。",0<=n<2^31,1,1
1261,88,2,92,题库,0,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个，个节点编号为到，以及一个边数组，其中表示一条从点到点的有向边。找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。你可以以任意顺序返回这些节点编号。,"2<=n<=10^51<=edges.length<=min(10^5,n*(n-1)/2)edges[i].length==20<=fromto<n所有点对(from,to互不相同。",1,1
1262,68,5,36,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个与大小相同且初始值全为0的数组，请你调用以上函数得到整数数组。请你返回将变成的最少函数调用次数。答案保证在32位有符号整数以内。,1<=nums.length<=10^50<=nums[i]<=10^9,1,3
1263,180,3,63,题库,2,2,0,1,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维字符网格数组，大小为，你需要检查中是否存在形成的环。一个环是一条开始和结束于同一个格子的长度的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有。同时，你也不能回到上一次移动时所在的格子。比方说，环是不合法的，因为从移动到回到了上一次移动时的格子。如果中有相同值形成的环，请你返回，否则返回。,m==grid.lengthn==grid[i].length1<=m<=5001<=n<=500grid只包含小写英文字母。,1,5
1264,164,3,82,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数和一个整数数组。有一条圆形赛道由个扇区组成，扇区编号从到。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由个阶段组成。其中，第个阶段将会从扇区开始，到扇区结束。举例来说，第阶段从开始，到结束。请你以数组形式返回经过次数最多的那几个扇区，按扇区编号排列。注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。,2<=n<=1001<=m<=100rounds.length==m+11<=rounds[i]<=nrounds[i]!=rounds[i+1]，其中0<=i<m,1,2
1265,66,3,142,题库,2,1,0,0,0,2,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有3n堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：给你一个整数数组，其中是第堆中硬币的数目。返回你可以获得的最大硬币数目。,每一轮中，你将会选出3堆硬币（不一定连续）。Alice将会取走硬币数量最多的那一堆。你将会取走硬币数量第二多的那一堆。Bob将会取走最后一堆。重复这个过程，直到没有更多硬币。3<=piles.length<=10^5piles.length%3==01<=piles[i]<=10^4,1,5
1266,193,4,64,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，该数组表示一个从到的数字排列。有一个长度为的二进制字符串，该字符串上的所有位最初都设置为。在从到的每个步骤中（假设二进制字符串和都是从开始索引的情况下），二进制字符串上位于位置的位将会设为。给你一个整数，请你找出二进制字符串上存在长度为的一组的最后步骤。一组是一个连续的、由组成的子串，且左右两边不再有可以延伸的。返回存在长度为的的最后步骤。如果不存在这样的步骤，请返回。,n==arr.length1<=n<=10^51<=arr[i]<=narr中的所有整数互不相同1<=m<=arr.length,1,3
1267,187,3,47,题库,1,1,0,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,几块石子，每块石子都有一个关联值，关联值为整数，由数组给出。游戏中的每一轮：Alice会将这行石子分成两个（即，左侧行和右侧行）；Bob负责计算每一行的值，即此行中所有石子的值的总和。Bob会丢弃值最大的行，Alice的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob让Alice决定丢弃哪一行。下一轮从剩下的那一行开始。只时，游戏结束。Alice的分数最初为。返回,1<=stoneValue.length<=5001<=stoneValue[i]<=10^6,1,4
1268,105,5,50,题库,2,0,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数数组，请你找出一个长度为且在数组中至少重复次的模式。是由一个或多个值组成的子数组（连续的子序列），重复多次但。模式由其长度和重复次数定义。如果数组中存在至少重复次且长度为的模式，则返回，否则返回。,2<=arr.length<=1001<=arr[i]<=1001<=m<=1002<=k<=100,1,2
1269,77,3,40,题库,1,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你求出乘积为正数的最长子数组的长度。一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。请你返回乘积为正数的最长子数组长度。,1<=nums.length<=10^5-10^9<=nums[i]<=10^9,1,3
1270,107,2,53,题库,2,2,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个大小为，由若干和组成的二维网格，其中表示陆地，表示水。由水平方向或竖直方向上相邻的（陆地）连接形成。如果，则认为陆地是；否则，陆地就是。一天内，可以将陆地单元（）更改为水单元（）。返回使陆地分离的最少天数。,"m==grid.lengthn==grid[i].length1<=m,n<=30grid[i][j]为或",1,5
1271,203,3,55,题库,1,3,3,1,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组表示到的一个排列。我们按照元素在中的顺序依次插入一个初始为空的二叉搜索树（BST）。请你统计将重新排序后，统计满足如下条件的方案数：重排后得到的二叉搜索树与原本数字顺序得到的二叉搜索树相同。比方说，给你，我们得到一棵2为根，1为左孩子，3为右孩子的树。数组也能得到相同的BST，但会得到一棵不同的BST。请你返回重排后，与原数组得到相同二叉搜索树的方案数。由于答案可能会很大，请将结果对取余数。,1<=nums.length<=10001<=nums[i]<=nums.lengthnums中所有数互不相同,1,10
1272,58,3,54,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正方形矩阵，请你返回矩阵对角线元素的和。请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。,n==mat.length==mat[i].length1<=n<=1001<=mat[i][j]<=100,1,2
1273,115,4,37,题库,1,0,0,0,0,1,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个二进制串（一个只包含0和1的字符串），我们可以将分割成3个字符串s1,s2,s3（s1+s2+s3=s）。请你返回分割的方案数，满足s1，s2和s3中字符'1'的数目相同。由于答案可能很大，请将它对10^9+7取余后返回。",s[i]=='0'或者s[i]=='1'3<=s.length<=10^5,1,2
1274,77,4,34,题库,1,1,2,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，请你删除一个子数组（可以为空），使得中剩下的元素是的。一个子数组指的是原数组中连续的一个子序列。请你返回满足题目要求的最短子数组的长度。,1<=arr.length<=10^50<=arr[i]<=10^9,1,5
1275,174,3,106,题库,1,2,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的整数数组，其中表示第个城市的位置。同时给你，和分别表示出发城市、目的地城市和你初始拥有的汽油总量每一步中，如果你在城市，你可以选择任意一个城市，满足且，并移动到城市。从城市移动到消耗的汽油量为，表示的绝对值。请注意，任何时刻都为负，且你经过任意城市超过一次（包括和）。请你返回从到所有可能路径的数目。由于答案可能很大，请将它对取余后返回。,"2<=locations.length<=1001<=locations[i]<=10所有locations中的整数互不相同0<=start,finish<locations.length1<=fuel<=200",1,3
1276,165,2,31,题库,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个仅包含小写英文字母和字符的字符串，请你将所有的转换为若干小写字母，使最终的字符串不包含任何的字符。注意：你修改非字符。题目测试用例保证字符，不存在连续重复的字符。在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。仅包含小写英文字母和字符,1<=s.length<=100仅包含小写英文字母和'?'字符,1,1
1277,39,4,226,题库,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数数组和，请你返回根据以下规则形成的三元组的数目（类型1和类型2）：,"类型1：三元组(i,j,k)，如果nums1[i]==nums2[j]*nums2[k]其中0<=i<nums1.length且0<=j<k<nums2.length类型2：三元组(i,j,k)，如果nums2[i]==nums1[j]*nums1[k]其中0<=i<nums2.length且0<=j<k<nums1.length1<=nums1.length,nums2.length<=10001<=nums1[i],nums2[i]<=10^5",1,4
1278,167,3,79,题库,2,2,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Alice把个气球排列在一根绳子上。给你一个下标从开始的字符串，其中是第个气球的颜色。Alice想要把绳子装扮成，且她不希望两个连续的气球涂着相同的颜色，所以她喊来Bob帮忙。Bob可以从绳子上移除一些气球使绳子变成。给你一个下标从开始的整数数组，其中是Bob从绳子上移除第个气球需要的时间（以秒为单位）。返回Bob使绳子变成需要的。,n==colors.length==neededTime.length1<=n<=101<=neededTime[i]<=10colors仅由小写英文字母组成,1,4
1279,180,3,176,题库,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,Alice和Bob共有一个无向图，其中包含n个节点和3种类型的边：给你一个数组，其中表示节点和之间存在类型为的双向边。请你在保证图仍能够被Alice和Bob完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice和Bob都可以到达所有其他节点，则认为图是可以完全遍历的。返回可以删除的最大边数，如果Alice和Bob无法完全遍历图，则返回-1。,"类型1：只能由Alice遍历。类型2：只能由Bob遍历。类型3：Alice和Bob都可以遍历。1<=n<=10^51<=edges.length<=min(10^5,3*n*(n-1)/2)edges[i].length==31<=edges[i][0]<=31<=edges[i][1]<edges[i][2]<=n所有元组(type,u,v互不相同",1,2
1280,85,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：表：有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个SQL查询，来查找这些顾客的ID，以及他们只光顾不交易的次数。返回以排序的结果表。查询结果格式如下例所示。,,1,1
1281,63,4,63,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个大小为的矩阵，其中是或，请返回。定义：如果并且第行和第列中的所有其他元素均为（行和列的下标均），则位置被称为特殊位置。,"rows==mat.lengthcols==mat[i].length1<=rows,cols<=100mat[i][j]是或",1,2
1282,183,3,206,题库,2,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一份位朋友的亲近程度列表，其中总是。对每位朋友，包含一份的朋友列表。换句话说，排在列表前面的朋友与的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以到之间的整数表示。所有的朋友被分成几对，配对情况以列表给出，其中表示与配对，且与配对。但是，这样的配对情况可能会使其中部分朋友感到不开心。在与配对且与配对的情况下，如果同时满足下述两个条件，就会不开心：返回。,"与的亲近程度胜过与与的亲近程度胜过与2<=n<=500是偶数preferences.length==npreferences[i].length==n-10<=preferences[i][j]<=n-1preferences[i]不包含preferences[i]中的所有值都是独一无二的pairs.length==n/2pairs[i].length==2!=y0<=x,y<=n-1每位朋友都被包含在一对中",1,2
1283,91,5,44,题库,1,0,2,1,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，表示2D平面上的一些点，其中。连接点和点的费用为它们之间的：，其中表示的绝对值。请你返回将所有点连接的最小总费用。只有任意两点之间一条简单路径时，才认为所有点都已连接。,"1<=points.length<=1000-10<=x,y<=10所有点,y两两不同。",1,4
1284,95,4,73,题库,2,1,0,0,0,0,0,0,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你两个字符串和，请你通过若干次以下操作将字符串转化成字符串：比方说，对下划线所示的子字符串进行操作可以由得到。如果可以将字符串变成，返回。否则，返回。一个定义为一个字符串中连续的若干字符。,选择中一个子字符串并将它包含的字符就地排序。s.length==t.length1<=s.length<=10和都只包含数字字符，即'0'到'9',1,3
1285,80,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,"表:表:写一个SQL,报告余额高于10000的所有用户的名字和余额.账户的余额等于包含该账户的所有交易的总和.返回结果表单没有顺序要求.查询结果格式如下例所示.",,1,1
1286,77,3,33,题库,1,0,0,0,1,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个正整数数组，请你计算所有可能的奇数长度子数组的和。定义为原数组中的一个连续子序列。请你返回中。你可以设计一个O(n)时间复杂度的算法解决此问题吗？,1<=arr.length<=1001<=arr[i]<=1000,1,3
1287,85,3,94,题库,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,有一个整数数组，和一个查询数组，其中。第个查询求的结果，和数组索引都是的。你可以任意排列中的数字，请你返回所有查询结果之和的最大值。由于答案可能会很大，请你将它对后返回。,n==nums.length1<=n<=100<=nums[i]<=101<=requests.length<=10requests[i].length==20<=start<=end<n,1,4
1288,92,5,40,题库,1,0,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，请你移除子数组（可以为），使得剩余元素的能被整除。将整个数组都移除。请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回。定义为原数组中连续的一组元素。,1<=nums.length<=101<=nums[i]<=101<=p<=10,1,3
1289,75,4,159,题库,2,0,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个奇怪的打印机，它有如下两个特殊的打印规则：给你一个初始没有颜色的的矩形，其中是位置的颜色。如果你能按照上述规则打印出矩形，请你返回，否则返回。,"每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。一旦矩形根据上面的规则使用了一种颜色，那么相同的颜色不能再被使用m==targetGrid.lengthn==targetGrid[i].length1<=m,n<=601<=targetGrid[row][col]<=60",1,4
1290,149,5,48,题库,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证。请你重新排列空格，使每对相邻单词之间的空格数目都，并尽可能该数目。如果不能重新平均分配所有空格，请，这也意味着返回的字符串应当与原字符串的长度相等。返回。,1<=text.length<=100text由小写英文字母和''组成text中至少包含一个单词,1,1
1291,114,3,24,题库,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。字符串拆分后可以得到若干，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是。注意：是字符串中的一个连续字符序列。仅包含小写英文字母,1<=s.length<=16仅包含小写英文字母,1,3
1292,120,3,58,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个大小为的矩阵。最初，你位于左上角，每一步，你可以在矩阵中或移动。在从左上角开始到右下角结束的所有路径中，找出具有的路径。路径的积是沿路径访问的单元格中所有整数的乘积。返回对的结果。如果最大积为，则返回。取余是在得到最大积之后执行的。,"m==grid.lengthn==grid[i].length1<=m,n<=15-4<=grid[i][j]<=4",1,3
1293,135,3,81,题库,2,1,0,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两组点，其中第一组中有个点，第二组中有个点，且。任意两点间的连接成本由大小为矩阵给出，其中是第一组中的点和第二组中的点的连接成本。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。返回连通两组点所需的最小成本。,"size==cost.lengthsize==cost[i].length1<=size,size<=12size>=size0<=cost[i][j]<=100",1,5
1294,116,3,186,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,每当用户执行变更文件夹操作时，LeetCode文件系统都会保存一条日志记录。下面给出对变更操作的说明：给你一个字符串列表，其中是用户在步执行的操作。文件系统启动时位于主文件夹，然后执行中的操作。执行完所有变更文件夹操作后，请你找出。,"""../""：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则继续停留在当前文件夹""./""：继续停留在当前文件夹""x/""：移动到名为的子文件夹中。题目数据保证总是存在文件夹1<=logs.length<=102<=logs[i].length<=10logs[i]包含小写英文字母，数字，'.'和'/'logs[i]符合语句中描述的格式文件夹名称由小写英文字母和数字组成",1,3
1295,286,3,78,题库,2,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在经营一座摩天轮，该摩天轮共有，每个座舱。你可以轮转座舱，但每次轮转都需要支付一定的运行成本。摩天轮每次轮转都恰好转动1/4周。给你一个长度为的数组，是在第次轮转（下标从0开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转次。每位游客在登上离地面最近的座舱前都会支付登舱成本，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。你可以随时停下摩天轮，即便是。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，。注意，如果有超过4位游客在等摩天轮，那么只有4位游客可以登上摩天轮，其余的需要等待。返回最大化利润所需执行的。如果不存在利润为正的方案，则返回。,"n==customers.length1<=n<=100<=customers[i]<=501<=boardingCost,runningCost<=100",1,2
1296,197,1,559,题库,0,1,2,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数，给定一个人和当前的继承顺序，该函数返回的下一继承人。比方说，假设王国由国王，他的孩子Alice和Bob（Alice比Bob年长）和Alice的孩子Jack组成。通过以上的函数，我们总是能得到一个唯一的继承顺序。请你实现类：,"ThroneInheritance(stringkingName)初始化一个ThroneInheritance类的对象。国王的名字作为构造函数的参数传入。voidbirth(stringparentName,stringchildName)表示parentName新拥有了一个名为childName的孩子。voiddeath(stringname)表示名为name的人死亡。一个人的死亡不会影响Successor函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。string[]getInheritanceOrder()返回死亡人员的当前继承顺序列表。1<=kingName.length,parentName.length,childName.length,name.length<=15kingNameparentNamechildName和name仅包含小写英文字母。所有的参数childName和kingName互不相同所有death函数中的死亡名字name要么是国王，要么是已经出生了的人员名字。每次调用birth(parentName,childName)时，测试用例都保证parentName对应的人员是活着的。最多调用birth和death最多调用次getInheritanceOrder",1,4
1297,243,3,63,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,我们有栋楼，编号从到。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。给你一个数组，其中，表示一个员工请求从编号为的楼搬到编号为的楼。一开始，所以从请求列表中选出的若干个请求是可行的需要满足。意思是每栋楼的员工数目该楼的员工数数目。比方说且两个员工要离开楼，一个员工要离开楼，一个员工要离开楼，如果该请求列表可行，应该要有两个员工搬入楼，一个员工搬入楼，一个员工搬入楼。请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。,"1<=n<=201<=requests.length<=16requests[i].length==20<=from,to<n",1,4
1298,60,1,254,题库,1,0,0,0,1,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。请你实现类：,"ParkingSystem(intbig,intmedium,intsmall)初始化ParkingSystem类，三个参数分别对应每种停车位的数目。booladdCar(intcarType)检查是否有carType对应的停车位。carType有三种类型：大，中，小，分别用数字和表示。一辆车只能停在carType对应尺寸的停车位中。如果没有空车位，请返回false，否则将该车停入车位并返回true0<=big,medium,small<=1000carType取值为或最多会调用addCar函数1000",1,3
1299,206,2,162,题库,3,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个。给你字符串数组和，其中对应一个人的名字和他在内使用员工卡的时间。使用时间的格式是，形如，比方说和。请你返回去重后的收到系统警告的员工名字，将它们按排序后返回。请注意-视为一个小时时间范围内，而-不被视为一小时时间范围内。,"1<=keyName.length,keyTime.length<=10keyName.length==keyTime.lengthkeyTime格式为""HH:MM""保证[keyName[i],keyTime[i]]形成的二元对互不相同1<=keyName[i].length<=10keyName[i]只包含小写英文字母。",1,4
1300,120,5,85,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个非负整数数组和，其中是二维矩阵中第行元素的和，是第列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。请找到大小为的任意矩阵，且该矩阵满足和的要求。请你返回任意一个满足题目要求的二维矩阵，题目保证存在可行矩阵。,"1<=rowSum.length,colSum.length<=5000<=rowSum[i],colSum[i]<=10sum(rowSum)==sum(colSum)",1,3
1301,181,5,278,题库,1,1,2,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有个服务器，编号为到，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是。请求分配到服务器的规则如下：给你一个的正整数数组，表示第个任务的到达时间，和另一个数组，其中表示第个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。请你返回包含所有序号的列表，你可以以任意顺序返回这个列表。,"（序号从0开始）个请求到达。如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。如果第(i%k)个服务器空闲，那么对应服务器会处理该请求。否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第0个服务器开始继续找下一个空闲的服务器）。比方说，如果第个服务器在忙，那么会查看第(i+1)个服务器，第(i+2)个服务器等等。1<=k<=101<=arrival.length,load.length<=10arrival.length==load.length1<=arrival[i],load[i]<=10arrival保证严格递增",1,4
1302,100,4,35,题库,2,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个非负整数数组。如果存在一个数，使得中恰好有个元素，那么就称是一个，而是该数组的。注意：是的中的元素。如果数组是一个，请返回它的特征值。否则，返回。可以证明的是，如果是特殊数组，那么其特征值是。,1<=nums.length<=1000<=nums[i]<=1000,1,3
1303,48,5,128,题库,0,1,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果一棵二叉树满足下述几个条件，则可以称为：给你二叉树的根节点，如果二叉树为，则返回，否则返回。,"二叉树根节点所在层下标为，根的子节点所在层下标为，根的孙节点所在层下标为，依此类推。偶数下标层上的所有节点的值都是整数，从左到右按顺序严格递增奇数下标层上的所有节点的值都是整数，从左到右按顺序严格递减树中节点数在范围[1,101<=Node.val<=10",1,3
1304,277,3,88,题库,2,0,0,0,1,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个点数组和一个表示角度的整数，你的位置是，其中且都表示X-Y平面上的整数坐标。最开始，你面向东方进行观测。你进行移动改变位置，但可以通过调整观测角度。换句话说，和不能改变。你的视野范围的角度用表示，这决定了你观测任意方向时可以多宽。设为你逆时针自转旋转的度数，那么你的视野就是角度范围所指示的那片区域。对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度，那么你就可以看到它。同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。返回你能看到的点的最大数目。,"1<=points.length<=10points[i].length==2location.length==20<=angle<3600<=pos,pos,x,y<=100",1,5
1305,40,2,65,题库,0,2,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，你需要重复执行多次下述操作将其转换为：返回将转换为的最小操作次数。,翻转的二进制表示中最右侧位（第位）。如果第(i-1)位为且从第(i-2)位到第位都为，则翻转的二进制表示中的第位。0<=n<=10,1,3
1306,88,2,279,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果字符串满足以下条件之一，则可以称之为，可以简写为）：类似地，可以定义任何有效括号字符串的：例如：、、都是（嵌套深度分别为0、1、2），而、都不是。给你一个，返回该字符串的。,"字符串是一个空字符串，或者是一个不为""(""或"")""的单字符。字符串可以写为与字符串连接），其中和都是有效括号字符串字符串可以写为(A)，其中是一个有效括号字符串depth("""")=0depth(C)=0，其中是单个字符的字符串，且该字符不是""(""或者"")""depth(A+B)=max(depth(A),depth(B))，其中和都是有效括号字符串depth(""(""+A+"")"")=1+depth(A)，其中是一个有效括号字符串1<=s.length<=100由数字0-9和字符'+''-''*''/''('')'组成题目数据保证括号表达式是有效的括号表达式",1,2
1307,142,3,83,题库,0,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,座城市和一些连接这些城市的道路共同组成一个基础设施网络。每个都表示在城市和之间有一条双向道路。两座不同城市构成的的定义为：与这两座城市相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算。整个基础设施网络的是所有不同城市对中的。给你整数和数组，返回整个基础设施网络的。,"2<=n<=1000<=roads.length<=n*(n-1)/2roads[i].length==20<=a,b<=n-1!=b每对城市之间最多只有一条道路相连",1,1
1308,146,3,53,题库,1,0,0,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你两个字符串和，它们长度相同。请你选择一个下标，将两个字符串都在分割开。由可以得到两个字符串：和，满足，同理，由可以得到两个字符串和，满足。请你判断或者能否构成回文串。当你将一个字符串分割成和时，或者可以为空。比方说，那么，，和都是合法分割。如果，那么请返回，否则返回。，表示连接字符串和。,"1<=a.length,b.length<=10a.length==b.length和都只包含小写英文字母",1,2
1309,241,3,68,题库,1,1,1,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你个城市，编号为从到。同时给你一个大小为的数组，其中表示城市和之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵。一棵是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。对于从到，请你找到城市间恰好为的所有子树数目。请你返回一个大小为的数组，其中第个元素（）是城市间恰好等于的子树数目。，两个城市间距离定义为它们之间需要经过的边的数目。,"2<=n<=15edges.length==n-1edges[i].length==21<=u,v<=n题目保证,v所表示的边互不相同。",1,5
1310,51,5,45,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请你删除最小的数字和最大的数字后，剩余数字的平均值。与误差在的结果都被视为正确结果。,20<=arr.length<=1000arr.length倍数0<=arr[i]<=10,1,2
1311,242,3,138,题库,2,0,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组和一个整数。数组中包含一些网络信号塔，其中表示第个网络信号塔的坐标是且信号强度参数为。所有坐标都是在X-Y坐标系内的坐标。两个坐标之间的距离用计算。整数表示一个塔的。如果一个坐标跟塔的距离在以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以以外的距离该塔是。如果第个塔能到达，那么该塔在此处的信号为，其中是塔跟此坐标的距离。一个坐标的是所有该坐标的塔的信号强度之和。请你返回数组，表示最大的坐标点。如果有多个坐标网络信号一样大，请你返回字典序最小的坐标。,"坐标(x1,y1)字典序比另一个坐标(x2,y2)要么x1<x2要么x1==x2且y1<y2⌊val⌋表示小于等于val的最大整数（向下取整函数）。1<=towers.length<=50towers[i].length==30<=x,y,q<=501<=radius<=50",1,2
1312,118,5,19,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一维空间的个点，其中第个点（编号从到）位于处，请你找到线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是。这个线段不需要全部覆盖全部个点，且它们的端点重合。请你返回个不重叠线段的方案数。由于答案可能很大，请将结果对后返回。,2<=n<=10001<=k<=n-1,1,2
1313,24,1,240,题库,0,0,0,1,0,1,1,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,请你实现三个API，和来实现奇妙序列。请实现类：,"Fancy()初始化一个空序列对象。voidappend(val)将整数val添加在序列末尾。voidaddAll(inc)将所有序列中的现有数值都增加incvoidmultAll(m)将序列中的所有现有数值都乘以整数intgetIndex(idx)得到下标为idx处的数值（下标从0开始），并将结果对+7取余。如果下标大于等于序列的长度，请返回1<=val,inc,m<=1000<=idx<=10总共最多会有次对appendaddAllmultAll和getIndex的调用。",1,3
1314,56,4,24,题库,1,0,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，请你返回计算长度时不含这两个字符。如果不存在这样的子字符串，返回。是字符串中的一个连续字符序列。,1<=s.length<=300只含小写英文字母,1,2
1315,193,4,174,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串以及两个整数和。其中，字符串的长度为偶数，且仅由数字到组成。你可以在上按任意顺序多次执行下面两个操作之一：请你返回在上执行上述操作任意次后可以得到的的字符串。如果两个字符串长度相同，那么字符串字典序比字符串小可以这样定义：在和出现不同的第一个位置上，字符串中的字符出现在字母表中的时间早于中的对应字符。例如，字典序比小，因为不同的第一个位置是在第三个字符，显然出现在之前。,"累加：将加到中所有下标为奇数的元素上（下标从0开始）。数字一旦超过就会变成，如此循环往复。例如，s=""3456""且a=5，则执行此操作后变成""3951""轮转：将向右轮转位。例如，s=""3456""且b=1，则执行此操作后变成""6345""2<=s.length<=100s.length是偶数仅由数字到组成1<=a<=91<=b<=s.length-1",1,2
1316,157,3,92,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数。然而，球队中的矛盾会限制球员的发挥，所以必须选出一支的球队。如果一名年龄较小球员的分数一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。给你两个列表和，其中每组和表示第名球员的分数和年龄。请你返回。,"1<=scores.length,ages.length<=1000scores.length==ages.length1<=scores[i]<=101<=ages[i]<=1000",1,3
1317,172,3,104,题库,1,0,0,1,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有座城市，编号从到。编号为和的两座城市直接连通的前提是：和的公因数中，至少有一个某个阈值。更正式地说，如果存在整数，且满足以下所有条件，则编号和的城市之间有一条道路：给你两个整数和，以及一个待查询数组，请你判断每个查询指向的城市和是否连通（即，它们之间是否存在一条路径）。返回数组，其中。如果第个查询中指向的城市和连通，则为；如果不连通，则为。,"x%z==0y%z==0z>threshold2<=n<=100<=threshold<=n1<=queries.length<=10queries[i].length==21<=a,b<=cities!=b",1,3
1318,244,2,129,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,LeetCode设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计个），每次一个。给你一个长度为的字符串，其中表示测试序列中第个被按下的键。是一个升序排列的列表，其中表示松开第个键的时间。字符串和数组的。第个键在时间为时被按下，接下来每个键都在前一个键松开时被按下。测试人员想要找出按键的键。第次按键的持续时间为，第次按键的持续时间为。注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。请返回单次按键的键，如果有多个这样的键，则返回的那个键。,releaseTimes.length==nkeysPressed.length==n2<=n<=10001<=releaseTimes[i]<=10releaseTimes[i]<releaseTimes[i+1]keysPressed仅由小写英文字母组成,1,2
1319,186,2,84,题库,2,0,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是。更正式地，数列是等差数列，只需要满足：对于每个有效的，都成立。例如，下面这些都是：下面的数列：给你一个由个整数组成的数组，和两个由个整数组成的数组和，后两个数组表示组范围查询，其中第个查询对应范围。所有数组的下标都是的。返回元素构成的答案列表。如果子数组可以形成，的值就是；否则的值就是。,n==nums.lengthm==l.lengthm==r.length2<=n<=5001<=m<=5000<=l[i]<r[i]<n-10<=nums[i]<=10,1,2
1320,141,3,86,题库,2,3,1,1,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,你准备参加一场远足活动。给你一个二维的地图，其中表示格子的高度。一开始你在最左上角的格子，且你希望去最右下角的格子（注意下标从开始编号）。你每次可以往，，，四个方向之一移动，你想要找到耗费最小的一条路径。一条路径耗费的是路径上相邻格子之间的决定的。请你返回从左上角走到右下角的最小。,"rows==heights.lengthcolumns==heights[i].length1<=rows,columns<=1001<=heights[i][j]<=10",1,7
1321,82,4,176,题库,2,1,2,1,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个的矩阵，请你返回一个新的矩阵，其中是的秩。每个元素的是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：题目保证按照上面规则数组是唯一的。,"秩是从1开始的一个整数。如果两个元素和在同一行或者同一列如果p<q，那么rank(p)<rank(q)如果p==q，那么rank(p)==rank(q)如果p>q，那么rank(p)>rank(q)需要越越好。m==matrix.lengthn==matrix[i].length1<=m,n<=500-10<=matrix[row][col]<=10",1,6
1322,69,1,0,题库,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,用户表：注册表：写一条SQL语句，查询各赛事的用户注册百分率，保留两位小数。返回的结果表按的排序，若相同则按的排序。查询结果如下示例所示。,,0,1
1323,62,3,37,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，请你将数组按照每个值的频率排序。如果有多个值的频率相同，请你按照数值本身将它们排序。请你返回排序后的数组。,1<=nums.length<=100-100<=nums[i]<=100,1,3
1324,96,2,53,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你个二维平面上的点，其中，请你返回两点之间内部不包含任何点的的宽度。的定义是固定宽度，而y轴上无限延伸的一块区域（也就是高度为无穷大）。为宽度最大的一个垂直区域。请注意，垂直区域的点区域内。,"n==points.length2<=n<=10points[i].length==20<=x,y<=10",1,2
1325,139,4,37,题库,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串和，请你找出中的非空子串的数目，这些子串满足替换以后，是串的子串。换言之，请你找到和串中只有一个字符不同的子字符串对的数目。比方说，and只有一个字符不同：/，所以这一对子字符串会给答案加1。请你返回满足上述条件的不同子字符串对数目。一个是一个字符串中连续的字符。,"1<=s.length,t.length<=100和都只包含小写英文字母。",1,3
1326,138,4,303,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串列表和一个目标字符串。中所有字符串都。你的目标是使用给定的字符串列表按照下述规则构造：，在构造目标字符串的过程中，你可以按照上述规定使用列表中的。请你返回使用构造的方案数。由于答案可能会很大，请对后返回。（译者注：此题目求的是有多少个不同的序列，详情请见示例。）,从左到右依次构造target的每一个字符。为了得到target第个字符（下标从开始），当target[i]=words[j][k]时，你可以使用words列表中第个字符串的第个字符。一旦你使用了words中第个字符串的第个字符，你不能再使用words字符串列表中任意单词的第个字符（x<=k）。也就是说，所有单词下标小于等于的字符都不能再被使用。请你重复此过程直到得到目标字符串target1<=words.length<=10001<=words[i].length<=1000words中所有单词长度相同。1<=target.length<=1000words[i]和target都仅包含小写英文字母。,1,3
1327,92,3,186,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，数组中的每个整数。另有一个由整数数组构成的数组，其中的整数也。请你以连接中的数组以形成。但是，对每个数组中的整数重新排序。如果可以连接中的数组形成，返回；否则，返回。,"1<=pieces.length<=arr.length<=100sum(pieces[i].length)==arr.length1<=pieces[i].length<=arr.length1<=arr[i],pieces[i][j]<=100arr中的整数互不相同pieces中的整数互不相同（也就是说，如果将pieces扁平化成一维数组，数组中的所有整数互不相同）",1,2
1328,70,3,8,题库,0,1,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个整数，请返回长度为、仅由元音(,,,,)组成且按的字符串数量。字符串按需要满足：对于所有有效的，在字母表中的位置总是与相同或在之前。",1<=n<=50,1,3
1329,80,3,154,题库,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，表示建筑物的高度。另有一些砖块和梯子。你从建筑物开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。当从建筑物移动到建筑物（下标）时：,如果当前建筑物的高度大于或等于下一建筑物的高度，则不需要梯子或砖块如果当前建筑的高度下一个建筑的高度，您可以使用一架梯子或(h[i+1]-h[i])个砖块1<=heights.length<=101<=heights[i]<=100<=bricks<=100<=ladders<=heights.length,1,3
1330,171,3,123,题库,1,1,0,0,0,2,0,0,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Bob站在单元格，想要前往目的地：。他只能向或向走。你可以为Bob提供导航来帮助他到达目的地。用字符串表示，其中每个字符：能够为Bob导航到目的地的指令可以有多种，例如，如果目的地是，和都是有效。然而，Bob很挑剔。因为他的幸运数字是，他想要遵循的导航前往目的地。的编号。给你一个整数数组和一个整数，请你返回可以为Bob提供前往目的地导航的。,"'H'，意味着水平向右移动'V'，意味着竖直向下移动destination.length==21<=row,column<=151<=k<=nCr(row+column,row)，其中nCr(a,b)表示组合数，即从个物品中选个物品的不同方案数。",1,4
1331,33,3,97,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数。按下述规则生成一个长度为的数组：返回生成数组中的值。,nums[0]=0nums[1]=12<=2*i<=n时，nums[2*i]=nums[i]2<=2*i+1<=n时，nums[2*i+1]=nums[i]+nums[i+1]0<=n<=100,1,3
1332,86,3,23,题库,2,1,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果字符串中两个不同字符相同的情况，就称是。给你一个字符串，返回使成为需要删除的字符数。字符串中字符的是该字符在字符串中的出现次数。例如，在字符串中，的频次是，而的频次是。,1<=s.length<=10仅含小写英文字母,1,4
1333,235,4,77,题库,2,2,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有一些球的库存，里面包含着不同颜色的球。一个顾客想要总数为的球。这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的的数目。比方说还剩下个黄球，那么顾客买第一个黄球的时候该黄球的价值为。这笔交易以后，只剩下个黄球了，所以下一个黄球的价值为（也就是球的价值随着顾客购买同色球是递减的）给你整数数组，其中表示第种颜色球一开始的数目。同时给你整数，表示顾客总共想买的球数目。你可以按照卖球。请你返回卖了个球以后总价值之和。由于答案可能会很大，请你返回答案对的结果。,"1<=inventory.length<=101<=inventory[i]<=101<=orders<=min(sum(inventory[i]),10",1,6
1334,147,3,108,题库,1,3,1,2,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，你需要根据中的元素创建一个有序数组。一开始你有一个空的数组，你需要遍历中的元素，将它们依次插入数组中。每一次插入操作的是以下两者的：比方说，如果要将插入到，那么插入操作的为(元素和小于，元素大于），插入后变成。请你返回将中所有元素依次插入后的。由于答案会很大，请将它对后返回。,nums中严格小于instructions[i]的数字数目。nums中严格大于instructions[i]的数字数目。1<=instructions.length<=101<=instructions[i]<=10,1,7
1335,118,3,111,题库,1,0,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为的数组以及一个密钥。为了获得正确的密码，你需要替换掉每一个数字。所有数字会被替换。由于是循环的，下一个元素是，且前一个元素是。给你数组和整数密钥，请你返回解密后的结果来拆除炸弹！,如果k>0，将第个数字用接下来个数字之和替换。如果k<0，将第个数字用个数字之和替换。如果k==0，将第个数字用替换。n==code.length1<=n<=1001<=code[i]<=100-(n-1)<=k<=n-1,1,1
1336,70,2,31,题库,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，它仅包含字符和​​​​。你可以删除中任意数目的字符，使得。当不存在下标对满足，且的同时，此时认为是的。请你返回使的删除次数。,1<=s.length<=10s[i]要么是'a'要么是'b',1,3
1337,130,3,157,题库,1,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,有一只跳蚤的家在数轴上的位置处。请你帮助它从位置出发，到达它的家。跳蚤跳跃的规则如下：跳蚤可以往前跳它的家的位置，但是它的位置。给你一个整数数组，其中是跳蚤不能跳到的位置，同时给你整数，和，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达的可行方案，请你返回。,"它可以跳恰好个位置（即往右跳）。它可以跳恰好个位置（即往左跳）。它不能往后跳次。它不能跳到任何forbidden数组中的位置。1<=forbidden.length<=10001<=a,b,forbidden[i]<=20000<=x<=2000forbidden中所有位置互不相同。位置不在forbidden中。",1,3
1338,108,3,144,题库,1,2,0,0,2,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的整数数组，这个数组中至多有个不同的值。同时你有个顾客的订单，其中，整数是第位顾客订单的数目。请你判断是否能将中的整数分配给这些顾客，且满足：如果你可以分配中的整数满足上面的要求，那么请返回，否则返回。,位顾客恰好quantity[i]个整数。位顾客拿到的整数都是相同的每位顾客都满足上述两个要求。n==nums.length1<=n<=101<=nums[i]<=1000m==quantity.length1<=m<=101<=quantity[i]<=10nums中至多有个不同的数字。,1,5
1339,75,1,265,题库,1,0,1,0,0,0,2,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有个对，其中是到之间的一个整数，是一个字符串。不存在相同的两个对。设计一个流，以顺序获取个对，并在多次调用时返回一些值。实现类：否则，返回一个空列表。,"OrderedStream(intn)构造一个能接收个值的流，并将当前指针ptr设为String[]insert(intid,Stringvalue)向流中存储新的(id,value)如果流存储有id=ptr的(id,value)对，则找出从id=ptr开始的最长id连续递增序列，并按顺序返回与这些id关联的值的列表。然后，将ptr更新为最后那个id+1否则，返回一个空列表。1<=n<=10001<=id<=nvalue.length==5value仅由小写字母组成每次调用insert都会使用一个唯一的恰好调用次insert",1,4
1340,83,4,113,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串：你可以根据需要对任意一个字符串多次使用这两种操作。给你两个字符串，和。如果和，就返回；否则，返回。,"操作1：交换任意两个例如，->a操作2：将一个字符的每次出现转换为另一个例如，abb->baa（所有转化为，而所有的转换为1<=word1.length,word2.length<=10word1和word2仅包含小写英文字母",1,3
1341,87,3,40,题库,1,1,1,0,2,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个整数数组和一个整数。每一次操作时，你应当移除数组最左边或最右边的元素，然后从中减去该元素的值。请注意，需要数组以供接下来的操作使用。如果可以将减到，返回；否则，返回。,1<=nums.length<=101<=nums[i]<=101<=x<=10,1,5
1342,151,3,129,题库,0,2,0,0,2,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你四个整数、、和。有一个网格，和两种类型的人：内向的人和外向的人。总共有个内向的人和个外向的人。请你决定网格中应当居住多少人，并为每个人分配一个网格单元。注意，让所有人都生活在网格中。每个人的计算如下：邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。是每个人幸福感的。返回。,"内向的人时有120个幸福感，但每存在一个邻居（内向的或外向的）他都会个幸福感。外向的人时有个幸福感，每存在一个邻居（内向的或外向的）他都会个幸福感。1<=m,n<=50<=introvertsCount,extrovertsCount<=min(m*n,6)",1,4
1343,151,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"表:现在有一个工厂网站由几台机器运行，每台机器上运行着相同数量的进程.请写出一条SQL计算每台机器各自完成一个进程任务的平均耗时.完成一个进程任务的时间指进程的减去.平均耗时通过计算每台机器上所有进程任务的总耗费时间除以机器上的总进程数量获得.结果表必须包含和对应的别名,且以返回表。具体参考例子如下。",,1,1
1344,53,3,142,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串数组和。如果两个数组表示的字符串相同，返回；否则，返回是由数组中的所有元素连接形成的字符串。,"1<=word1.length,word2.length<=101<=word1[i].length,word2[i].length<=101<=sum(word1[i].length),sum(word2[i].length)<=10word1[i]和word2[i]由小写字母组成",1,2
1345,131,2,66,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,的是它在字母表中的位置（从开始），因此的数值为，的数值为，的数值为，以此类推。字符串由若干小写字符组成，为各字符的数值之和。例如，字符串的数值等于。给你两个整数和。返回等于且等于的的字符串。注意，如果字符串在字典排序中位于之前，就认为字典序比小，有以下两种情况：,是的一个前缀；如果是x[i]!=y[i]的第一个位置，且x[i]在字母表中的位置比y[i]靠前。1<=n<=10n<=k<=26*n,1,2
1346,123,3,113,题库,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。你需要选择一个下标（下标从开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。比方说，如果，那么：如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个。请你返回删除操作后，剩下的数组是的。,"选择删除下标，剩下的数组为nums=[6,7,4,1]选择删除下标，剩下的数组为nums=[6,1,4,1]选择删除下标，剩下的数组为nums=[6,1,7,4]1<=nums.length<=101<=nums[i]<=10",1,2
1347,99,3,89,题库,2,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个任务数组，其中：比方说，如果任务为且你当前的能量为，那么你不能开始这个任务。如果你当前的能量为，你可以完成这个任务，且完成它后剩余能量为。你可以按照完成任务。请你返回完成所有任务的初始能量。,actual是完成第个任务需要耗费的实际能量。minimum是开始第个任务前需要达到的最低能量。1<=tasks.length<=101<=actual<=minimum<=10,1,3
1348,50,1,0,题库,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：修复名字，使得只有第一个字符是大写的，其余都是小写的。返回按排序的结果表。返回结果格式示例如下。,,1,1
1349,83,3,66,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，如果字符串连续重复次形成的字符串是的一个子字符串，那么单词的。单词的是单词在中最大的重复值。如果不是的子串，那么重复值为。给你一个字符串和，请你返回。,1<=sequence.length<=1001<=word.length<=100sequence和word都只包含小写英文字母。,1,2
1350,84,2,60,题库,0,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个链表和，它们包含的元素分别为个和个。请你将中下标从到的全部节点都删除，并将接在被删除节点的位置。下图中蓝色边和节点展示了操作后的结果：请你返回结果链表的头指针。,3<=list1.length<=101<=a<=b<list1.length-11<=list2.length<=10,1,1
1351,62,1,411,题库,1,0,2,0,0,0,2,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你设计一个队列，支持在前，中，后三个位置的和操作。请你完成类：请注意当有中间位置的时候，选择靠前面的位置进行操作。比方说：,"FrontMiddleBack()初始化队列。voidpushFront(intval)将val添加到队列的最前面voidpushMiddle(intval)将val添加到队列的正中间voidpushBack(intval)将val添加到队里的最后面intpopFront()将最前面的元素从队列中删除并返回值，如果删除之前队列为空，那么返回intpopMiddle()将正中间的元素从队列中删除并返回值，如果删除之前队列为空，那么返回intpopBack()将最后面的元素从队列中删除并返回值，如果删除之前队列为空，那么返回添加到[1,2,3,4,5]的中间位置，结果数组为[1,2,,3,4,5][1,2,,4,5,6]的中间位置弹出元素，返回，数组变为[1,2,4,5,6]1<=val<=10最多调用1000次pushFrontpushMiddlepushBackpopFrontpopMiddle和popBack",1,5
1352,35,2,171,题库,1,3,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,我们定义是当且仅当它满足：给你整数数组​，请你返回将变成的​删除次数。,arr.length>=3存在某个下标从0开始）满足0<i<arr.length-1arr[0]<arr[1]<...<arr[i-1]<arr[i]arr[i]>arr[i+1]>...>arr[arr.length-1]3<=nums.length<=10001<=nums[i]<=10题目保证nums删除一些元素后一定能得到山形数组。,1,4
1353,77,3,71,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的整数网格，其中是第位客户在第家银行托管的资产数量。返回最富有客户所拥有的。客户的就是他们在各家银行托管的资产数量之和。最富有客户就是最大的客户。,"m==accounts.lengthn==accounts[i].length1<=m,n<=501<=accounts[i][j]<=100",1,2
1354,151,2,49,题库,1,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个整数数组和一个正整数，返回长度为且最具的子序列。数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。在子序列和子序列第一个不相同的位置上，如果中的数字小于中对应的数字，那么我们称子序列比子序列（相同长度下）更具。例如，比更具竞争力，在第一个不相同的位置，也就是最后一个位置上，小于。,1<=nums.length<=100<=nums[i]<=101<=k<=nums.length,1,4
1355,102,3,47,题库,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组和一个整数。每一次操作，你可以将中的任何整数替换为到之间的另一个整数。如果对于所有下标（），都等于同一个数，则数组是。例如，数组是互补的，因为对于所有下标，。返回使数组的操作次数。,n==nums.length2<=n<=101<=nums[i]<=limit<=10是偶数。,1,3
1356,74,3,143,题库,1,1,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个由个正整数组成的数组。你可以对数组的任意元素执行任意次数的两类操作：数组的是数组中任意两个元素之间的。返回数组在执行某些操作之后可以拥有的。,"如果元素是偶数例如，如果数组是[1,2,3,4]，那么你可以对最后一个元素执行此操作，使其变成[1,2,3,如果元素是例如，如果数组是[1,2,3,4]，那么你可以对第一个元素执行此操作，使其变成,2,3,4]n==nums.length2<=n<=5*101<=nums[i]<=10",1,4
1357,99,3,53,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你设计一个可以解释字符串的。由、和/或按某种顺序组成。Goal解析器会将解释为字符串、解释为字符串，解释为字符串。然后，按原顺序将经解释得到的字符串连接成一个字符串。给你字符串，返回对的解释结果。,"1<=command.length<=100command由""G""""()""和/或""(al)""按某种顺序组成",1,1
1358,64,2,40,题库,2,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。每一步操作中，你需要从数组中选出和为的两个整数，并将它们移出数组。返回你可以对数组执行的最大操作数。,1<=nums.length<=101<=nums[i]<=101<=k<=10,1,4
1359,41,3,8,题库,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个整数，请你将到的二进制表示连接起来，并返回连接结果对应的数字对取余的结果。,1<=n<=10,1,3
1360,140,3,60,题库,1,1,0,0,2,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组​​​和一个整数。你需要将这个数组划分到个相同大小的子集中，使得同一个子集里面没有两个相同的元素。一个子集的是该子集里面最大值和最小值的差。请你返回将数组分成个子集后，各子集的的，如果无法分成分成个子集，返回。子集的定义是数组中一些数字的集合，对数字顺序没有要求。,1<=k<=nums.length<=16nums.length能被整除。1<=nums[i]<=nums.length,1,4
1361,56,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：查询所有无效推文的编号（ID）。当推文内容中的字符数时，该推文是无效的。以返回结果表。查询结果格式如下所示：,,1,1
1362,61,3,101,题库,2,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个由不同字符组成的字符串和一个字符串数组。如果一个字符串的每一个字符都在中，就称这个字符串是。请你返回数组中的数目。,1<=words.length<=101<=allowed.length<=1<=words[i].length<=10allowed中的字符互不相同words[i]和allowed只包含小写英文字母。,1,4
1363,73,2,43,题库,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个有序整数数组。请你建立并返回一个整数数组，它跟长度相同，且等于与数组中所有其他元素差的绝对值之和。换句话说，等于，其中且（下标从0开始）。,2<=nums.length<=101<=nums[i]<=nums[i+1]<=10,1,3
1364,199,3,111,题库,2,1,1,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,Alice和Bob轮流玩一个游戏，Alice先手。一堆石子里总共有个石子，轮到某个玩家时，他可以一个石子并得到这个石子的价值。Alice和Bob对石子价值有。双方都知道对方的评判标准。给你两个长度为的整数数组和。和分别表示Alice和Bob认为第个石子的价值。所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用进行游戏。请你推断游戏的结果，用如下的方式表示：,"如果Alice赢，返回如果Bob赢，返回如果游戏平局，返回n==aliceValues.length==bobValues.length1<=n<=101<=aliceValues[i],bobValues[i]<=100",1,6
1365,128,4,362,题库,1,1,3,1,1,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有和。给你一个箱子数组和三个整数,和，其中。箱子需要按照运输，同时每次运输需要遵循以下步骤：卡车在将所有箱子运输并卸货后，最后必须回到仓库。请你返回将所有箱子送到相应码头的次数。","ports​​i表示第个箱子需要送达的码头，weights是第个箱子的重量。portsCount是码头的数目。maxBoxes和maxWeight分别是卡车每趟运输箱子数目和重量的限制。卡车从boxes队列中按顺序取出若干个箱子，但不能违反maxBoxes和maxWeight限制。对于在卡车上的箱子，我们需要按顺序处理它们，卡车会通过一趟行程将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要额外行程，箱子也会立马被卸货。卡车上所有箱子都被卸货后，卡车需要一趟行程回到仓库，从箱子队列里再取出一些箱子。1<=boxes.length<=101<=portsCount,maxBoxes,maxWeight<=101<=ports​​i<=portsCount1<=weights<=maxWeight",1,7
1366,54,2,130,题库,1,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，表示比赛中的队伍数。比赛遵循一种独特的赛制：返回在比赛中进行的配对次数，直到决出获胜队伍为止。,如果当前队伍数是，那么每支队伍都会与另一支队伍配对。总共进行n/2场比赛，且产生n/2支队伍进入下一轮。如果当前队伍数为，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行(n-1)/2场比赛，且产生(n-1)/2+1支队伍进入下一轮。1<=n<=200,1,2
1367,79,3,36,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果一个十进制数字不含任何前导零，且每一位上的数字不是就是，那么该数字就是一个。例如，和都是，而和不是。给你一个表示十进制整数的字符串，返回和为的的最少数目。,1<=n.length<=10仅由数字组成不含任何前导零并总是表示正整数,1,2
1368,179,2,44,题库,1,1,0,0,0,2,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，。有块石子排成一排。每个玩家的回合中，可以从行中最左边的石头或最右边的石头，并获得与该行中剩余石头值之相等的得分。当没有石头可移除时，得分较高者获胜。鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力。爱丽丝的目标是最大限度地。给你一个整数数组，其中表示的第个石头的值，如果爱丽丝和鲍勃都，请返回他们。,n==stones.length2<=n<=10001<=stones[i]<=1000,1,4
1369,103,3,53,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你个长方体，其中第个长方体的长宽高表示为（）。请你从选出一个，并将它们堆叠起来。如果且且，你就可以将长方体堆叠在长方体上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。返回可以得到的。,"n==cuboids.length1<=n<=1001<=width,length,height<=100",1,3
1370,39,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：对于每一个和，返回的以及的的数量。按返回结果表。查询结果格式如下示例所示。,,1,1
1371,109,5,136,题库,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串形式的电话号码。由数字、空格、和破折号组成。请你按下述方式重新格式化电话号码。最后用破折号将这些块连接起来。注意，重新格式化过程中生成仅含1个数字的块，并且生成两个含2个数字的块。返回格式化后的电话号码。,首先，所有的空格和破折号。其次，将数组从左到右每3个一组分块，直到2个数字：单个含2个数字的块。3个数字：单个含3个数字的块。4个数字：两个分别含2个数字的块。2<=number.length<=100number由数字和字符'-'及''组成。number中至少含个数字。,1,1
1372,84,2,32,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，请你从中删除一个含有的子数组删除子数组的就是子数组各元素之。返回子数组可获得的如果数组是数组的一个连续子序列，即如果它等于，那么它就是的一个子数组。,1<=nums.length<=101<=nums[i]<=10,1,3
1373,122,3,36,题库,1,1,3,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个整数。一开始你在下标处。每一步，你最多可以往前跳步，但你不能跳出数组的边界。也就是说，你可以从下标跳到两个端点的任意位置。你的目标是到达数组最后一个位置（下标为），你的为经过的所有数字之和。请你返回你能得到的。,"1<=nums.length,k<=10-10<=nums[i]<=10",1,6
1374,123,2,133,题库,2,0,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个点组成的无向图边集，其中表示点和点之间有一条长度为的边。请注意，两个点之间可能有。给你一个查询数组，其中，你的任务是对于每个查询，判断是否存在从到的路径，且这条路径上的每一条边都。请你返回一个，其中，当的查询结果为时，第个值为，否则为。,"2<=n<=101<=edgeList.length,queries.length<=10edgeList[i].length==3queries[j].length==30<=u,v,p,q<=n-1!=v!=q1<=dis,limit<=10两个点之间可能有边。",1,4
1375,201,2,166,题库,2,0,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"学校的自助午餐提供圆形和方形的三明治，分别用数字和表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个里，每一轮：这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。给你两个整数数组和，其中是栈里面第个三明治的类型（是栈的顶部），是初始队列里第名学生对三明治的喜好（是队列的最开始位置）。请你返回无法吃午餐的学生数量。","如果队列最前面的学生栈顶的三明治，那么会拿走它并离开队列。否则，这名学生会放弃这个三明治并回到队列的尾部。1<=students.length,sandwiches.length<=100students.length==sandwiches.lengthsandwiches[i]要么是，要么是students[i]要么是，要么是",1,4
1376,144,2,110,题库,2,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个餐厅，只有一位厨师。你有一个顾客数组，其中：当一位顾客到达时，他将他的订单给厨师，厨师一旦空闲的时候就开始做这位顾客的菜。每位顾客会一直等待到厨师完成他的订单。厨师同时只能做一个人的订单。厨师会严格按照做菜。请你返回所有顾客需要等待的时间。与标准答案误差在范围以内，都视为正确结果。,"arrival是第位顾客到达的时间，到达时间按非递减顺序排列。time是给第位顾客做菜需要的时间。1<=customers.length<=101<=arrival,time<=10arrival<=arrivali+1",1,2
1377,112,2,124,题库,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个二进制字符串，它仅有或者组成。你可以使用下面的操作任意次对它进行修改：请你返回执行上述操作任意次以后能得到的。如果二进制字符串对应的十进制数字大于二进制字符串对应的十进制数字，那么我们称二进制字符串大于二进制字符串。,"操作1：如果二进制串包含子字符串""00""，你可以用""10""比方说，010""->""010""操作2：如果二进制串包含子字符串""10""，你可以用""01""比方说，""000""->""0001<=binary.length<=10binary仅包含'0'和'1'",1,2
1378,56,3,47,题库,1,1,0,0,2,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数。仅包含和。每一次移动，你可以选择两个数字并将它们交换。请你返回使中包含个的交换次数。,1<=nums.length<=10nums[i]要么是，要么是1<=k<=sum(nums),1,4
1379,101,2,38,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个偶数长度的字符串。将其拆分成长度相同的两半，前一半为，后一半为。两个字符串的前提是它们都含有相同数目的元音（，，，，，，，，，）。注意，可能同时含有大写和小写字母。如果和相似，返回；否则，返回。,2<=s.length<=1000s.length是偶数由大写和小写字母组成,1,2
1380,160,2,94,题库,1,1,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一棵特殊的苹果树，一连天，每天都可以长出若干个苹果。在第天，树上会长出个苹果，这些苹果将会在天后（也就是说，第天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用且表示。你打算每天吃一个苹果来保证营养均衡。注意，你可以在这天之后继续吃苹果。给你两个长度为的整数数组和，返回你可以吃掉的苹果的最大数目,"apples.length==ndays.length==n1<=n<=2*100<=apples[i],days[i]<=2*10只有在apples[i]=0时，days[i]=0才成立",1,3
1381,210,3,108,题库,3,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"用一个大小为的二维网格表示一个箱子。你有颗球。箱子的顶部和底部都是开着的。箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的""V""形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。返回一个大小为的数组，其中是球放在顶部的第列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回。","将球导向右侧的挡板跨过左上角和右下角，在网格中用表示。将球导向左侧的挡板跨过右上角和左下角，在网格中用表示。m==grid.lengthn==grid[i].length1<=m,n<=100grid[i][j]为或",1,5
1382,124,2,71,题库,1,0,0,1,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个由非负整数组成的数组。另有一个查询数组，其中。第个查询的答案是和任何数组中不超过的元素按位异或（）得到的最大值。换句话说，答案是，其中所有均满足。如果中的所有元素都大于，最终答案就是。返回一个整数数组作为查询的答案，其中且是第个查询的答案。,"1<=nums.length,queries.length<=10queries[i].length==20<=nums[j],x,m<=10",1,3
1383,73,2,141,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你将一些箱子装在上。给你一个二维数组，其中：整数表示卡车上可以装载的。只要箱子数量不超过，你就可以选择任意箱子装到卡车上。返回卡车可以装载的总数,"numberOfBoxes是类型的箱子的数量。numberOfUnitsPerBox是类型每个箱子可以装载的单元数量。1<=boxTypes.length<=10001<=numberOfBoxes,numberOfUnitsPerBox<=10001<=truckSize<=10",1,3
1384,125,2,49,题库,1,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,是指的一餐，其美味程度之和等于2的幂。你可以搭配两道餐品做一顿大餐。给你一个整数数组，其中是第​​​​道餐品的美味程度，返回你可以用数组中的餐品做出的不同的数量。结果需要对取余。注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。,1<=deliciousness.length<=100<=deliciousness[i]<=2,1,2
1385,63,3,109,题库,1,1,0,0,2,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们称一个分割整数数组的方案是，当它满足：给你一个整数数组，请你返回分割方案数目。由于答案可能会很大，请你将结果对取余后返回。,数组被分成三个连续子数组，从左至右分别命名为left，mid，rightleft中元素和小于等于mid中元素和，mid中元素和小于等于right中元素和。3<=nums.length<=100<=nums[i]<=10,1,4
1386,187,2,70,题库,1,2,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组，包含若干的整数，以及另一个整数数组，包含重复元素。每一次操作中，你可以在的任意位置插入任一整数。比方说，如果，那么你可以在中间添加得到。你可以在数组最开始或最后面添加整数。请你返回操作次数，使得成为的一个子序列。一个数组的指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，是的子序列（加粗元素），但不是子序列。,"1<=target.length,arr.length<=101<=target[i],arr[i]<=10target不包含任何重复元素。",1,4
1387,115,3,10,题库,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,Hercy想要为购买第一辆车存钱。他都往力扣银行里存钱。最开始，他在周一的时候存入块钱。从周二到周日，他每天都比前一天多存入块钱。在接下来每一个周一，他都会比多存入块钱。给你，请你返回在第天结束的时候他在力扣银行总共存了多少块钱。,1<=n<=1000,1,1
1388,54,2,105,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串和两个整数和。你可以执行下面两种操作任意次。请返回对字符串执行上面操作若干次能得到的最大得分。,"删除子字符串""ab""并得到比方说，从xbae""删除，得到""cxbae""删除子字符串""ba""并得到比方说，从""cabx删除，得到""cabxe""1<=s.length<=101<=x,y<=10只包含小写英文字母。",1,3
1389,170,2,58,题库,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你找到满足下面条件的一个序列：序列里面两个数和之间的，我们定义为它们下标绝对值之差。请你返回满足上述条件中的序列。题目保证在给定限制条件下，一定存在解。一个序列被认为比序列（两者长度相同）字典序更大的条件是：和中第一个不一样的数字处，序列的数字比序列的数字大。比方说，比字典序更大，因为第一个不同的位置是第三个数字，且比大。,整数在序列中只出现一次。到之间每个整数都恰好出现两次。对于每个到之间的整数，两个之间出现的距离恰好为1<=n<=20,1,2
1390,141,3,159,题库,0,0,2,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组，其中，并且满足：令为满足下面条件的有根树的方案数：两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。请你返回：一棵指的是只有一个根节点的树，所有边都是从根往外的方向。我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的。根节点没有祖先。,"pairs中没有重复元素<y树所包含的所有节点值都在pairs中。一个数对,y出现在pairs中当且仅当是的祖先或者是的祖先。注意：构造出来的树不一定是二叉树。如果ways==0，返回如果ways==1，返回如果ways>1，返回1<=pairs.length<=101<=x<y<=500pairs中的元素互不相同。",1,2
1391,89,2,56,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,整数数组由个非负整数组成。经编码后变为长度为的另一个整数数组，其中。例如，经编码后得到。给你编码后的数组和原数组的第一个元素（）。请解码返回原数组。可以证明答案存在并且是唯一的。,2<=n<=10encoded.length==n-10<=encoded[i]<=100<=first<=10,1,2
1392,46,5,36,题库,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你链表的头节点和一个整数。链表正数第个节点和倒数第个节点的值后，返回链表的头节点（链表）。,链表中节点的数目是1<=k<=n<=100<=Node.val<=100,1,2
1393,136,3,130,题库,1,1,0,1,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你两个整数数组和，长度都是。还有一个数组，其中每个表示你可以交换数组中下标为和（）的两个元素。注意，你可以按顺序交换一对特定下标指向的元素。相同长度的两个数组和间的是元素不同的下标数量。形式上，其值等于满足（）的下标（）的数量。在对数组执行数量的交换操作后，返回和间的。,"n==source.length==target.length1<=n<=101<=source[i],target[i]<=100<=allowedSwaps.length<=10allowedSwaps[i].length==20<=a,b<=n-1!=b",1,3
1394,126,2,35,题库,1,2,0,0,2,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，其中是完成第项工作要花费的时间。请你将这些工作分配给位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的得以。返回分配方案中尽可能的。,1<=k<=jobs.length<=121<=jobs[i]<=10,1,5
1395,117,2,62,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组，其中表示第个矩形的长度为、宽度为。如果存在同时满足和，就可以将第个矩形切成边长为的正方形。例如，矩形可以切成边长最大为的正方形。设为可以从矩形数组切分得到的的边长。请你统计有多少个矩形能够切出边长为的正方形，并返回矩形。,"1<=rectangles.length<=1000rectangles[i].length==21<=l,w<=10!=w",1,1
1396,41,2,48,题库,1,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由正整数组成的数组，请你返回满足的元组的数量。其中、、和都是中的元素，且。,1<=nums.length<=10001<=nums[i]<=10nums中的所有元素互不相同,1,2
1397,57,4,64,题库,3,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个二进制矩阵，它的大小为，你可以将中的按任意顺序重新排列。请你返回最优方案下将重新排列后，全是的子矩阵面积。,m==matrix.lengthn==matrix[i].length1<=m*n<=10matrix[i][j]要么是，要么是,1,4
1398,137,5,458,题库,2,2,2,0,0,2,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。它们所处的环境设定是一个的方格，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。猫和老鼠按照如下规则移动：游戏有4种方式会结束：给你的矩阵和两个整数和，双方都采取最优策略，如果老鼠获胜，那么请你返回，否则返回。,"玩家由字符'C'（代表猫）和'M'（代表老鼠）表示。地板由字符'.'表示，玩家可以通过这个格子。墙用字符'#'表示，玩家不能通过这个格子。食物用字符'F'表示，玩家可以通过这个格子。字符'C'，'M'和'F'在grid中都只会出现一次。老鼠先移动，然后两名玩家轮流移动。每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出gridcatJump和mouseJump是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。它们可以停留在原地。老鼠可以跳跃过猫的位置。如果猫跟老鼠处在相同的位置，那么猫获胜。如果猫先到达食物，那么猫获胜。如果老鼠先到达食物，那么老鼠获胜。如果老鼠不能在1000次操作以内到达食物，那么猫获胜。rows==grid.lengthcols=grid[i].length1<=rows,cols<=8grid[i][j]只包含字符'C''M''F''.'和'#'grid中只包含一个'C''M'和'F'1<=catJump,mouseJump<=8",1,8
1399,54,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,EASY,表：写出SQL语句，对于每一个用户，返回该用户的关注者数量。按的顺序返回结果表。查询结果的格式如下示例所示。,,1,1
1400,138,1,0,题库,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,Table:对于此问题，我们将至少有一个其他员工需要向他汇报的员工，视为一个经理。编写SQL查询需要听取汇报的所有经理的ID、名称、直接向该经理汇报的员工人数，以及这些员工的平均年龄，其中该平均年龄需要四舍五入到最接近的整数。返回的结果集需要按照进行排序。查询结果的格式如下：,,1,1
1401,78,2,41,题库,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有一个自行车手打算进行一场公路骑行，这条路线总共由个不同海拔的点组成。自行车手从海拔为的点开始骑行。给你一个长度为的整数数组，其中是点和点的（）。请你返回。,n==gain.length1<=n<=100-100<=gain[i]<=100,1,2
1402,126,2,294,题库,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个由个用户组成的社交网络里，我们获取到一些用户之间的好友关系。两个用户之间可以相互沟通的条件是他们都掌握同一门语言。给你一个整数，数组和数组，它们的含义如下：你可以选择语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你需要教会多少名用户。,"总共有种语言，编号从到languages[i]是第位用户掌握的语言集合。friendships[i]=[u​​​​​​i​​​,v​​​​​​i表示​​​​​​​​​​​i​​​​​和为好友关系。2<=n<=500languages.length==m1<=m<=5001<=languages[i].length<=n1<=languages[i][j]<=n1<=u​​​​​​i<v​​​​​​i<=languages.length1<=friendships.length<=500所有的好友关系​​​​​i,​​​​​​i都是唯一的。languages[i]中包含的值互不相同。",1,2
1403,80,2,30,题库,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，它是前个正整数的排列，且是个。它被加密成另一个长度为的整数数组，满足。比方说，如果，那么。给你数组，请你返回原始数组。题目保证答案存在且唯一。,3<=n<10是奇数。encoded.length==n-1,1,2
1404,107,2,31,题库,1,1,0,0,0,3,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个二维整数数组，其中。第个查询要求构造长度为、每个元素都是正整数的数组，且满足所有元素的乘积为，请你找出有多少种可行的方案。由于答案可能会很大，方案数需要对。请你返回一个整数数组，满足，其中是第个查询的结果。,"1<=queries.length<=101<=n,k<=10",1,5
1405,78,3,36,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个字符串，格式为（小时：分钟），其中某几位数字被隐藏（用表示）。有效的时间为到之间的所有时间，包括和。替换中隐藏的数字，返回你可以得到的最晚有效时间。,time的格式为hh:mm题目数据保证你可以由输入的字符串生成有效的时间,1,2
1406,66,2,85,题库,1,0,1,0,2,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你两个字符串和，二者均由小写字母组成。一步操作中，你可以将或中的改变为。操作的最终目标是满足下列三个条件：返回达成目标所需的操作数,"中的每个字母在字母表中严格小于中的每个字母中的每个字母在字母表中严格小于中的每个字母和由同一个字母组成。1<=a.length,b.length<=10和只由小写字母组成",1,4
1407,72,4,75,题库,2,2,1,0,2,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维矩阵和一个整数，矩阵大小为由非负整数组成。矩阵中坐标的可由对所有满足且的元素（）执行异或运算得到。请你找出的所有坐标中第大的值（）。,"m==matrix.lengthn==matrix[i].length1<=m,n<=10000<=matrix[i][j]<=101<=k<=m*n",1,7
1408,82,3,63,题库,0,2,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,有一个立方体房间，其长度、宽度和高度都等于个单位。请你在房间里放置个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：给你一个整数，返回接触地面的盒子的可能数量,你可以把盒子放在地板上的任何地方。如果盒子需要放置在盒子的顶部，那么盒子竖直的四个侧面都与另一个盒子或墙相邻。1<=n<=10,1,3
1409,117,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"表:计算每位员工每天在办公室花费的总时间（以分钟为单位）。请注意，在一天之内，同一员工是可以多次进入和离开办公室的。在办公室里一次进出所花费的时间为out_time减去in_time。返回结果表单的顺序无要求。
查询结果的格式如下：",,1,1
1410,183,3,26,题库,0,0,1,0,1,1,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你在一家生产小球的玩具厂工作，有个小球，编号从开始，到结束（包括和，即）。另有无限数量的盒子，编号从到。你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号的小球应当放入编号的盒子，而编号的小球应当放入编号的盒子。给你两个整数和，返回放有最多小球的盒子中的小球数量如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。,1<=lowLimit<=highLimit<=10,1,3
1411,143,3,129,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,存在一个由个不同元素组成的整数数组，但你已经记不清具体内容。好在你还记得中的每一对相邻元素。给你一个二维整数数组，大小为，其中每个表示元素和在中相邻。题目数据保证所有由元素和组成的相邻元素对都存在于中，存在形式可能是，也可能是。这些相邻元素对可以出现。返回。如果存在多种解答，返回即可。,"nums.length==nadjacentPairs.length==n-1adjacentPairs[i].length==22<=n<=10-10<=nums[i],u,v<=10题目数据保证存在一些以adjacentPairs作为元素对的数组nums",1,2
1412,140,2,358,题库,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的正整数数组，其中表示你拥有的第类糖果的数目。同时给你一个二维数组，其中。你按照如下规则进行一场游戏：请你构建一个布尔型数组，用以给出中每一项的对应答案。此数组满足：注意，只要满足上面3条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。请你返回得到的数组。,你从第天开始吃糖果。你在吃完第i-1类糖果之前，吃任何一颗第类糖果。在吃完所有糖果之前，你必须每天吃糖果。answer.length==queries.lengthanswer[i]是queries[i]的答案。answer[i]为true的条件是：在每天吃不超过dailyCap颗糖果的前提下，你可以在第favoriteDay天吃到第favoriteType类糖果；否则answer[i]为false1<=candiesCount.length<=101<=candiesCount[i]<=101<=queries.length<=10queries[i].length==30<=favoriteType<candiesCount.length0<=favoriteDay<=101<=dailyCap<=10,1,2
1413,61,2,33,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，如果可以将它分割成三个回文子字符串，那么返回，否则返回。当一个字符串正着读和反着读是一模一样的，就称其为。,3<=s.length<=2000​​​​​​只包含小写英文字母。,1,2
1414,37,3,34,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组。数组中唯一元素是那些只出现的元素。请你返回中唯一元素的。,1<=nums.length<=1001<=nums[i]<=100,1,3
1415,43,2,70,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。一个子数组的为。请你找出中最大的任意子数组（），并返回该。定义如下：,如果是负整数，那么abs(x)=-x如果是非负整数，那么abs(x)=x1<=nums.length<=10-10<=nums[i]<=10,1,2
1416,68,3,30,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个只包含字符，和的字符串，你可以执行下面这个操作（5个步骤）任意次：请你返回对字符串执行上面操作任意次以后（可能0次），能得到的。,1<=s.length<=10只包含字符'a''b'和'c',1,2
1417,166,3,76,题库,2,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个数组，其中，表示第个会议在天开始，第天结束，如果你参加这个会议，你能得到价值。同时给你一个整数表示你能参加的最多会议数目。你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。请你返回能得到的会议价值。,1<=k<=events.length1<=k*events.length<=101<=startDay<=endDay<=101<=value<=10,1,4
1418,111,3,34,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组。的源数组中，所有元素与相同，但按非递减顺序排列。如果能够由源数组轮转若干位置（包括0个位置）得到，则返回；否则，返回。源数组中可能存在。我们称数组在轮转个位置后得到长度相同的数组，当它们满足，其中为取余运算。,1<=nums.length<=1001<=nums[i]<=100,1,1
1419,94,3,12,题库,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在玩一个单人游戏，面前放置着大小分别为​​​​​​、和​​​​​​的石子。每回合你都要从两个中取出一颗石子，并在得分上加分。当存在的空堆时，游戏停止。给你三个整数、和，返回可以得到的。,"1<=a,b,c<=10",1,3
1420,181,2,257,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你两个字符串和。你需要按下述方式构造一个新字符串：如果或非空，选择继续操作：返回你可以构造的字典序的合并字符串长度相同的两个字符串和比较字典序大小，如果在和出现不同的第一个位置，中字符在字母表中的出现顺序位于中相应字符之后，就认为字符串按字典序比字符串更大。例如，按字典序比更大，因为两个字符串出现不同的第一个位置是第四个字符，而在字母表中的出现顺序位于之后。,"如果word1非空，将word1中的第一个字符附加到merge的末尾，并将其从word1例如，word1=""abc""merge=""dv""，在执行此选项操作之后，word1=""bc""，同时merge=""dva""如果word2非空，将word2中的第一个字符附加到merge的末尾，并将其从word2例如，word2=""abc""merge=""""，在执行此选项操作之后，word2=""bc""，同时merge=""a""1<=word1.length,word2.length<=3000word1和word2仅由小写英文组成",1,3
1421,104,3,47,题库,1,1,0,0,3,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个目标值。你需要从中选出一个子序列，使子序列元素总和最接近。也就是说，如果子序列元素和为，你需要。返回可能的。注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。,1<=nums.length<=40-10<=nums[i]<=10-10<=goal<=10,1,5
1422,42,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：编写解决方案找出既是低脂又是可回收的产品编号。返回结果。返回结果格式如下例所示：,,1,1
1423,108,3,27,题库,1,0,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个仅由字符和组成的字符串。一步操作中，你可以将任一变成，或者将变成。定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串是交替字符串，而字符串不是。返回使变成所需的操作数。,1<=s.length<=10s[i]是'0'或'1',1,1
1424,85,3,23,题库,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，返回中的数目。由于答案可能很大，只需返回对后的结果。的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同质字符串。是字符串中的一个连续字符序列。,1<=s.length<=10由小写字符串组成,1,2
1425,83,3,128,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中表示第个袋子里球的数目。同时给你一个整数。你可以进行如下操作至多次：你的开销是单个袋子里球数目的，你想要开销。请你返回进行上述操作后的最小开销。,"选择任意一个袋子，并将袋子里的球分到2个新的袋子中，每个袋子里都有正整数比方说，一个袋子里有个球，你可以把它们分到两个新袋子里，分别有个和个球，或者分别有个和个球。1<=nums.length<=101<=maxOperations,nums[i]<=10",1,2
1426,140,2,74,题库,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个无向图，整数表示图中节点的数目，数组表示图中的边，其中，表示和之间有一条无向边。一个指的是节点组成的集合且这三个点之间有边。是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。请你返回所有连通三元组中度数的，如果图中没有连通三元组，那么返回。,"2<=n<=400edges[i].length==21<=edges.length<=n*(n-1)/21<=u,v<=n!=v图中没有重复的边。",1,1
1427,147,4,29,题库,1,1,1,0,2,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,当一个字符串包含的每一种字母的大写和小写形式出现在中，就称这个字符串是字符串。比方说，是美好字符串，因为和同时出现了，且和也同时出现了。然而，不是美好字符串因为出现了，而没有出现。给你一个字符串，请你返回最长的。如果有多个答案，请你返回出现的一个。如果不存在美好子字符串，请你返回一个空字符串。,1<=s.length<=100只包含大写和小写英文字母。,1,5
1428,192,3,116,题库,2,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的二维整数数组，同时给你一个整数数组。你是否可以从中选出个的子数组，使得第个子数组与（下标从开始）完全相同，且如果，那么第个子数组在中出现的位置在第个子数组前面。（也就是说，这些子数组在中出现的顺序需要与顺序相同）如果你可以找出这样的个子数组，请你返回，否则返回。如果不存在下标为的元素属于不止一个子数组，就称这些子数组是的。子数组指的是原数组中连续元素组成的一个序列。,"groups.length==n1<=n<=101<=groups[i].length,sum(groups[i].length)<=101<=nums.length<=10-10<=groups[i][j],nums[k]<=10",1,3
1429,110,2,234,题库,2,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的整数矩阵，它代表了一个由和单元格组成的地图。你需要按照如下规则给每个单元格安排高度：找到一种安排高度的方案，使得矩阵中的最高高度值。请你返回一个大小为的整数矩阵，其中是格子的高度。如果有多种解法，请返回。,"如果isWater[i][j]==0，格子(i,j)是一个格子。如果isWater[i][j]==1，格子(i,j)是一个格子。每个格子的高度都必须是非负的。如果一个格子是，那么它的高度必须为任意相邻的格子高度差为。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）m==isWater.lengthn==isWater[i].length1<=m,n<=1000isWater[i][j]要么是，要么是至少有个水域格子。",1,3
1430,197,2,82,题库,0,2,1,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个节点的树（也就是一个无环连通无向图），节点编号从到，且恰好有条边，每个节点有一个值。树的为0号点。给你一个整数数组和一个二维数组来表示这棵树。表示第个点的值，表示节点和节点在树中有一条边。当，我们称两个数和是，其中是和的。从节点到最短路径上的点都是节点的祖先节点。一个节点它自己的祖先节点。请你返回一个大小为的数组，其中是离节点最近的祖先节点且满足和是，如果不存在这样的祖先节点，为。,"nums.length==n1<=nums[i]<=501<=n<=10edges.length==n-1edges[j].length==20<=u,v<n!=v",1,4
1431,70,3,53,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串和。请你从开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。返回。,"1<=word1.length,word2.length<=100word1和word2由小写英文字母组成",1,2
1432,168,2,41,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个盒子。给你一个长度为的二进制字符串，其中的值为表示第个盒子是的，而的值为表示盒子里有小球。在一步操作中，你可以将小球从某个盒子移动到一个与之相邻的盒子中。第个盒子和第个盒子相邻需满足。注意，操作执行后，某些盒子中可能会存在不止一个小球。返回一个长度为的数组，其中是将所有小球移动到第个盒子所需的操作数。每个都需要根据盒子的进行计算。,n==boxes.length1<=n<=2000boxes[i]为'0'或'1',1,2
1433,73,2,147,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个长度分别和的整数数组和，其中，数组下标计数。初始时，你的分数为。你需要执行恰好步操作。在第步操作（计数）中，需要：在执行步操作后，返回分数,"选择数组nums开头处或者末尾处的整数你获得multipliers[i]*x分，并累加到你的分数中。从数组nums中移除。n==nums.lengthm==multipliers.length1<=m<=10m<=n<=10-1000<=nums[i],multipliers[i]<=1000",1,2
1434,112,3,143,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个字符串和，请你按下述方法构造一个字符串：返回可按上述方法构造的最长的。如果无法构造回文串，返回。字符串的一个是通过从中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。是正着读和反着读结果一致的字符串。,"word1中选出某个子序列subsequence1word2中选出某个子序列subsequence2连接两个子序列subsequence1+subsequence2，得到字符串。1<=word1.length,word2.length<=1000word1和word2由小写英文字母组成",1,2
1435,84,2,216,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个数组，其中，描述第件物品的类型、颜色以及名称。另给你一条由两个字符串和表示的检索规则。如果第件物品能满足下述条件之一，则认为该物品与给定的检索规则：统计并返回。,"ruleKey==""type""且ruleValue==typeruleKey==""color""且ruleValue==colorruleKey==""name""且ruleValue==name1<=items.length<=101<=type.length,color.length,name.length,ruleValue.length<=10ruleKey等于""type""""color""或""name""所有字符串仅由小写字母组成",1,2
1436,107,4,274,题库,1,2,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你打算做甜点，现在需要购买配料。目前共有种冰激凌基料和种配料可供选购。而制作甜点需要遵循以下几条规则：给你以下三个输入：你希望自己做的甜点总成本尽可能接近目标价格。返回最接近的甜点成本。如果有多种方案，返回的一种。,"必须选择冰激凌基料。可以添加一种或多种配料，也可以不添加任何配料。每种类型的配料最多两份baseCosts，一个长度为的整数数组，其中每个baseCosts[i]表示第种冰激凌基料的价格。toppingCosts，一个长度为的整数数组，其中每个toppingCosts[i]表示第种冰激凌配料的价格。target，一个整数，表示你制作甜点的目标价格。n==baseCosts.lengthm==toppingCosts.length1<=n,m<=101<=baseCosts[i],toppingCosts[i]<=101<=target<=10",1,3
1437,120,3,55,题库,1,1,1,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个长度可能不等的整数数组和。两个数组中的所有值都在到之间（包含和）。每次操作中，你可以选择数组中的任意一个整数，将它变成到之间的值（包含和）。请你返回使中所有数的和与中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回。,"1<=nums1.length,nums2.length<=101<=nums1[i],nums2[i]<=6",1,4
1438,201,2,135,题库,1,0,3,0,0,1,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在一条单车道上有辆车，它们朝着同样的方向行驶。给你一个长度为的数组，其中，它表示：简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里一辆车的速度。请你返回一个数组，其中是第辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则为。答案精度误差需在以内。,"position是第辆车和道路起点之间的距离（单位：米）。题目保证position<positioni+1speed是第辆车的初始速度（单位：米/秒）。1<=cars.length<=101<=position,speed<=10position<positioni+1",1,5
1439,154,3,53,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数和，表示你在一个笛卡尔坐标系下的处。同时，在同一个坐标系下给你一个数组，其中表示在处有一个点。当一个点与你所在的位置有相同的坐标或者相同的坐标时，我们称这个点是。请返回距离你当前位置最近的点的下标（下标从开始）。如果有多个最近的有效点，请返回下标的一个。如果没有有效点，请返回。两个点和之间的为。,"1<=points.length<=10points[i].length==21<=x,y,a,b<=10",1,1
1440,67,3,8,题库,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，如果你可以将表示成若干个不同的三的幂之和，请你返回，否则请返回。对于一个整数，如果存在整数满足，我们称这个整数是三的幂。,1<=n<=10,1,1
1441,58,2,48,题库,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个字符串的定义为：出现频率最高字符与出现频率最低字符的出现次数之差。给你一个字符串，请你返回它所有子字符串的之和。,"比方说，""abaacc""的美丽值为3-1=21<=s.length<=500只包含小写英文字母。",1,3
1442,112,2,124,题库,0,1,1,0,1,0,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个无向图，无向图由整数，表示图中节点的数目，和组成，其中表示和之间有一条无向边。同时给你一个代表查询的整数数组。第个查询的答案是满足如下条件的点对的数目：请你返回一个数组，其中且是第个查询的答案。请注意，图中可能会有。,"a<bcnt是与或者相连的边的数目，且cnt严格大于queries[j]2<=n<=2*101<=edges.length<=101<=u,v<=n!=v1<=queries.length<=200<=queries[j]<edges.length",1,3
1443,33,2,40,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二进制字符串，该字符串。如果包含，返回​​​。否则，返回。,1<=s.length<=100s[i]​​​​为'0'或'1's[0]为'1',1,1
1444,78,2,65,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,MEDIUM,给你一个整数数组，和两个整数与。数组有一条重要属性：。返回使数组元素总和等于所需要向数组中添加的，添加元素数组中这一属性。注意，如果，那么等于；否则，等于。,1<=nums.length<=101<=limit<=10-limit<=nums[i]<=limit-10<=goal<=10,1,2
1445,197,2,107,题库,0,1,4,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现有一个加权无向连通图。给你一个正整数，表示图中有个节点，并按从到给节点编号；另给你一个数组，其中每个表示存在一条位于节点和之间的边，这条边的权重为。从节点出发到节点的路径是一个形如的节点序列，满足、且在所有符合的节点和之间存在一条边。路径的距离定义为这条路径上所有边的权重总和。用表示节点和之间路径的最短距离。为满足的一条路径，其中。返回从节点出发到节点的。由于数字可能很大，请返回对的结果。,"1<=n<=2*10n-1<=edges.length<=4*10edges[i].length==31<=u,v<=n!=v1<=weight<=10任意两个节点之间至多存在一条边任意两个节点之间至少存在一条路径",1,5
1446,78,3,41,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组​​​和一个整数​​​​​。区间（）的是对下标位于和（包括和）之间所有元素进行运算的结果：。返回数组中，以使所有长度为的区间异或结果等于零。,1<=k<=nums.length<=2000​​​​​​0<=nums[i]<2,1,3
1447,125,1,0,题库,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,Table:一个员工可以属于多个部门。当一个员工加入的时候，他需要决定哪个部门是他的直属部门。请注意，当员工只加入一个部门的时候，那这个部门将默认为他的直属部门，虽然表记录的值为.请编写一段SQL，查出员工所属的直属部门。返回结果没有顺序要求。示例：,,1,1
1448,85,4,58,题库,1,0,1,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你长度相等的两个字符串和。一次操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。如果对执行就可以使两个字符串相等，返回；否则，返回。,"1<=s1.length,s2.length<=100s1.length==s2.length和仅由小写英文字母组成",1,3
1449,98,2,75,题库,0,0,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有一个无向的图，由个编号从到的节点组成。星型图有一个节点，并且恰有条边将中心节点与其他每个节点连接起来。给你一个二维整数数组，其中表示在节点和之间存在一条边。请你找出并返回所表示星型图的中心节点。,3<=n<=10edges.length==n-1edges[i].length==21<=u<=n!=v题目数据给出的edges表示一个有效的星型图,1,1
1450,240,2,79,题库,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组，其中，表示你提前知道了第个班级总共有个学生，其中只有个学生可以通过考试。给你一个整数，表示额外有个聪明的学生，他们能通过任何班级的期末考。你需要给这个学生每人都安排一个班级，使得班级的通过率。一个班级的等于这个班级通过考试的学生人数除以这个班级的总人数。是所有班级的通过率之和除以班级数目。请你返回在安排这个学生去对应班级后的平均通过率。与标准答案误差范围在以内的结果都会视为正确结果。,1<=classes.length<=10classes[i].length==21<=pass<=total<=101<=extraStudents<=10,1,3
1451,54,2,50,题库,1,1,2,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数。一个子数组的定义为。一个子数组的两个端点下标需要满足。请你返回子数组的最大可能。,1<=nums.length<=101<=nums[i]<=2*100<=k<nums.length,1,5
1452,78,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：请你重构表，查询每个产品在不同商店的价格，使得输出的格式变为。如果这一产品在商店里没有出售，则不输出这一行。输出结果表中的。查询输出格式请参考下面示例。,,1,1
1453,49,2,32,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个混合字符串，请你返回中的数字，如果不存在第二大的数字，请你返回。由小写英文字母和数字组成。,1<=s.length<=500只包含小写英文字母和（或）数字。,1,2
1454,131,1,480,题库,0,0,1,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在时刻之后秒过期。如果验证码被更新了，那么它会在（可能与之前的不同）时刻延长秒。请你实现类：如果一个验证码在时刻过期，且另一个操作恰好在时刻发生（或者操作），过期事件其他操作。,"AuthenticationManager(inttimeToLive)构造AuthenticationManager并设置timeToLive参数。generate(stringtokenId,intcurrentTime)给定tokenId，在当前时间currentTime生成一个新的验证码。renew(stringtokenId,intcurrentTime)将给定tokenId且未过期的验证码在currentTime时刻更新。如果给定tokenId对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。countUnexpiredTokens(intcurrentTime)请返回在给定currentTime时刻，未过期的验证码数目。1<=timeToLive<=101<=currentTime<=101<=tokenId.length<=5tokenId只包含小写英文字母。所有generate函数的调用都会包含独一无二的tokenId值。所有函数调用中，currentTime的值严格递增所有函数的调用次数总共不超过2000次。",1,2
1455,99,3,42,题库,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个长度为的整数数组，它代表你拥有的个硬币。第个硬币的值为。如果你从这些硬币中选出一部分硬币，它们的和为，那么称，你可以出。请返回从开始（），你最多能出多少个连续整数。你可能有多个相同值的硬币。,coins.length==n1<=n<=4*101<=coins[i]<=4*10,1,2
1456,84,3,68,题库,1,2,0,0,2,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你，它是一个大小为的正整数数组。你必须对这个数组执行次操作。在第次操作时（操作编号从开始），你需要：请你返回次操作后你能获得的分数和最大为多少。函数是和的最大公约数。,"选择两个元素和获得分数i*gcd(x,y)和从nums中删除。1<=n<=7nums.length==2*n1<=nums[i]<=10",1,7
1457,93,4,34,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数组成的数组，返回中一个子数组的最大可能元素和。子数组是数组中的一个连续数字序列。已知子数组，若对所有（），都成立，则称这一子数组为子数组。注意，大小为的子数组也视作子数组。,1<=nums.length<=1001<=nums[i]<=100,1,1
1458,176,2,345,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中每个表示有笔类型为、价格为的订单。订单类型可以分为两种：注意，表示一批共计笔的独立订单，这些订单的价格和类型相同。对于所有有效的，由表示的所有订单提交时间均早于表示的所有订单。存在由未执行订单组成的。积压订单最初是空的。提交订单时，会发生以下情况：输入所有订单后，返回积压订单中的。由于数字可能很大，所以需要返回对取余的结果。,"表示这是一批采购订单buy表示这是一批销售订单sell如果该订单是一笔采购订单buy，则可以查看积压订单中价格的销售订单sell。如果该销售订单sell的价格低于或等于当前采购订单buy的价格，则匹配并执行这两笔订单，并将销售订单sell从积压订单中删除。否则，采购订单buy将会添加到积压订单中。反之亦然，如果该订单是一笔销售订单sell，则可以查看积压订单中价格的采购订单buy。如果该采购订单buy的价格高于或等于当前销售订单sell的价格，则匹配并执行这两笔订单，并将采购订单buy从积压订单中删除。否则，销售订单sell将会添加到积压订单中。1<=orders.length<=10orders[i].length==31<=price,amount<=10orderType为或",1,3
1459,65,2,133,题库,0,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你三个正整数、和。你需要构造一个同时满足下述所有条件的数组（下标计数）：返回你所构造的数组中的。注意：等于的前提是；否则，等于。,nums.length==nnums[i]是正整数，其中0<=i<nabs(nums[i]-nums[i+1])<=1，其中0<=i<n-1nums中所有元素之和不超过maxSumnums[index]的值被最大化1<=n<=maxSum<=100<=index<n,1,2
1460,43,2,54,题库,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组（下标计数）以及两个整数：和，请返回的数目。是一个形如的数对，其中且。,1<=nums.length<=2*101<=nums[i]<=2*101<=low<=high<=2*10,1,3
1461,127,3,36,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，该字符串由数字和小写英文字母组成。请你用空格替换每个不是数字的字符。例如，将会变成。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：、、和。返回对完成替换后形成的整数的数目。只有当两个整数的的十进制表示不同，才认为这两个整数也不同。,1<=word.length<=1000word由数字和小写英文字母组成,1,2
1462,101,3,83,题库,2,0,0,0,0,1,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个偶数​​​​​​，已知存在一个长度为的排列，其中​（下标计数）。一步操作中，你将创建一个新数组，对于每个：然后将​​赋值​​给。要想使回到排列初始值，至少需要执行多少步操作？返回最小的操作步数。,如果i%2==0，那么arr[i]=perm[i/2]如果i%2==1，那么arr[i]=perm[n/2+(i-1)/2]2<=n<=1000​​​​​​是一个偶数,1,3
1463,140,3,319,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，它包含一些括号对，每个括号中包含一个的键。你知道许多键对应的值，这些关系由二维字符串数组表示，其中，表示键对应的值为。你需要替换的括号对。当你替换一个括号对，且它包含的键为时，你需要：中每个键最多只会出现一次。中不会有嵌套的括号。请你返回替换括号对后的结果字符串。,"比方说，字符串""(name)is(age)yearsold""中，有括号对，分别包含键""name""和""age""key和括号用对应的值value替换。如果从knowledge中无法得知某个键对应的值，你需要将key和括号用问号""?""替换（不需要引号）。1<=s.length<=100<=knowledge.length<=10knowledge[i].length==21<=key.length,value.length<=10只包含小写英文字母和圆括号'('和')'中每一个左圆括号'('都有对应的右圆括号')'中每对括号内的键都不会为空。中不会有嵌套括号对。key和value只包含小写英文字母。knowledge中的key不会重复。",1,3
1464,121,2,138,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个正整数。你需要构造一个正整数，它满足以下条件：请你返回的好因子的数目。由于答案可能会很大，请返回答案对的结果。请注意，一个质数的定义是大于，且不能被分解为两个小于该数的自然数相乘。一个数的质因子是将分解为若干个质因子，且它们的乘积为。,"质因数（质因数需要考虑重复的情况）的数目不超过primeFactors个。好因子的数目最大化。如果的一个因子可以被的每一个质因数整除，我们称这个因子是好因子。比方说，如果n=12，那么它的质因数为[2,2,3]，那么和是好因子，但和不是。1<=primeFactors<=10",1,2
1465,116,3,69,题库,1,0,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个坐标，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。如果所给格子的颜色是白色，请你返回，如果是黑色，请返回。给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。,coordinates.length==2'a'<=coordinates[0]<='h''1'<=coordinates[1]<='8',1,2
1466,164,4,108,题库,2,0,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，，，都是句子。每个单词都包含大写和小写英文字母。如果两个句子和，可以通过往其中一个句子插入一个任意的句子（）而得到另一个句子，那么我们称这两个句子是。比方说，且，我们可以往中和之间插入得到。给你两个句子和，如果和是相似的，请你返回，否则返回。,"1<=sentence1.length,sentence2.length<=100sentence1和sentence2都只包含大小写英文字母和空格。sentence1和sentence2中的单词都只由单个空格隔开。",1,3
1467,90,2,92,题库,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个数组，数组中只包含非负整数。定义的值为将整数各个数字位反转得到的结果。比方说，。我们称满足下面条件的下标对是：请你返回好下标对的数目。由于结果可能会很大，请将结果对后返回。,0<=i<j<nums.lengthnums[i]+rev(nums[j])==nums[j]+rev(nums[i])1<=nums.length<=100<=nums[i]<=10,1,4
1468,238,2,51,题库,1,2,0,0,2,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一个甜甜圈商店，每批次都烤个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前甜甜圈都必须已经全部销售完毕。给你一个整数和一个整数数组，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。你可以随意安排每批顾客到来的顺序。请你返回在此前提下，有多少组人会感到开心。,1<=batchSize<=91<=groups.length<=301<=groups[i]<=10,1,5
1469,125,3,120,题库,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。给你一个句子​​​​​​和一个整数​​​​​​，请你将​​​，​​​使截断后的句子仅含​​​​​​个单词。返回​​​​后得到的句子,"例如，""HelloWorld""""HELLO""和""helloworldhelloworld""都是句子。1<=s.length<=500的取值范围是[1,s中单词的数目]仅由大小写英文字母和空格组成中的单词之间由单个空格隔开不存在前导或尾随空格",1,2
1470,195,2,60,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你用户在LeetCode的操作日志，和一个整数。日志用一个二维整数数组表示，其中每个表示ID为的用户在分钟时执行了某个操作。可以同时执行操作，单个用户可以在同一分钟内执行。指定用户的定义为用户对LeetCode执行操作的。即使一分钟内执行多个操作，也只能按一分钟计数。请你统计用户活跃分钟数的分布情况，统计结果是一个长度为且的数组，对于每个（），表示等于的用户数。返回上面描述的答案数组。,"1<=logs.length<=100<=ID<=101<=time<=10的取值范围是[用户的最大用户活跃分钟数,10",1,2
1471,105,3,83,题库,2,1,1,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个正整数数组和，数组的长度都是。数组和的定义为所有（）的（）。你可以选用中的元素来替换中的一个元素，以绝对差值和。在替换数组中最多一个元素，返回最小绝对差值和。因为答案可能很大，所以需要对后返回。定义为：,"如果x>=0，值为，或者如果x<=0，值为n==nums1.lengthn==nums2.length1<=n<=101<=nums1[i],nums2[i]<=10",1,4
1472,97,2,85,题库,1,0,0,0,1,2,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个由正整数组成的数组。数字序列的定义为序列中所有整数的共有约数中的最大整数。数组的一个本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。计算并返回的所有子序列中最大公约数的。,"例如，序列[4,6,16]的最大公约数是例如，[2,5,10]是[1,2,1,,4,1,的一个子序列。1<=nums.length<=101<=nums[i]<=2*10",1,4
1473,43,3,62,题库,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,已知函数将会根据的正负返回特定值：给你一个整数数组。令为数组中所有元素值的乘积。返回。,如果是正数，返回如果是负数，返回如果是等于，返回1<=nums.length<=1000-100<=nums[i]<=100,1,2
1474,148,2,12,题库,2,1,1,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,共有名小伙伴一起做游戏。小伙伴们围成一圈，按从到编号。确切地说，从第名小伙伴顺时针移动一位会到达第名小伙伴的位置，其中，从第名小伙伴顺时针移动一位会回到第名小伙伴的位置。游戏遵循如下规则：给你参与游戏的小伙伴总数，和一个整数，返回游戏的获胜者。你能否使用线性时间复杂度和常数空间复杂度解决此问题？,1<=k<=n<=500,1,5
1475,236,3,143,题库,1,2,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的，它总共包含个，编号为到。一只青蛙从号点第二条跑道，它想要跳到点处。然而道路上可能有一些障碍。给你一个长度为的数组，其中（）表示在点处的跑道上有一个障碍。如果，那么点处没有障碍。任何一个点的三条跑道中障碍。这只青蛙从点跳到点且跑道不变的前提是点的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在点处到跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。这只青蛙从点0处跑道出发，并想到达点处的，请你返回。：点处和点处的任一跑道都不会有障碍。,比方说，如果obstacles[2]==1，那么说明在点2处跑道1有障碍。比方说，这只青蛙可以从点3处的跑道3跳到点3处的跑道1。obstacles.length==n+11<=n<=5*100<=obstacles[i]<=3obstacles[0]==obstacles[n]==0,1,3
1476,57,1,206,题库,0,0,3,0,0,0,2,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个整数和，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的。按照如下步骤计算：请你实现类：,"MKAverage(intm,intk)用一个空的数据流和两个整数和初始化MKAverage对象。voidaddElement(intnum)往数据流中插入一个新的元素numintcalculateMKAverage()对当前的数据流计算并返回MK平均数，结果需向下取整到最近的整数3<=m<=101<=k*2<m1<=num<=10addElement与calculateMKAverage总操作次数不超过次。",1,5
1477,88,3,80,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组（）。每一次操作中，你可以选择数组中一个元素，并将它增加。请你返回使的操作次数。我们称数组是，当它满足对于所有的都有。一个长度为的数组是严格递增的一种特殊情况。,"比方说，如果nums=[1,2,3]，你可以选择增加nums[1]得到nums=[1,,3]1<=nums.length<=50001<=nums[i]<=10",1,2
1478,120,2,137,题库,1,0,0,0,0,2,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个数组，其中，表示第个点在二维平面上的坐标。多个点可能会有的坐标。同时给你一个数组，其中，表示一个圆心在且半径为的圆。对于每一个查询，计算在第个圆点的数目。如果一个点在圆的，我们同样认为它在圆。请你返回一个数组，其中是第个查询的答案。,"1<=points.length<=500points[i].length==20<=x​​​​​​i,y​​​​​​i<=5001<=queries.length<=500queries[j].length==30<=x,y<=5001<=r<=500所有的坐标都是整数。",1,3
1479,57,3,79,题库,1,0,0,0,2,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，它由个非负整数组成，同时给你一个整数。你需要执行以下查询次：请你返回一个数组，其中是第个查询的结果。,nums.length==n1<=n<=101<=maximumBit<=200<=nums[i]<2maximumBitnums​​​中的数字已经按排好序。,1,3
1480,72,4,28,题库,1,0,0,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串（）。你需要对执行以下操作直到它变为一个有序字符串：请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对的结果。,1<=s.length<=3000​只包含小写英文字母。,1,3
1481,61,2,41,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,指包含英语字母表中每个字母至少一次的句子。给你一个仅由小写英文字母组成的字符串，请你判断是否为。如果是，返回；否则，返回。,1<=sentence.length<=1000sentence由小写英语字母组成,1,2
1482,153,3,50,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,夏日炎炎，小男孩Tony想买一些雪糕消消暑。商店中新到支雪糕，用长度为的数组表示雪糕的定价，其中表示第支雪糕的现金价格。Tony一共有现金可以用于消费，他想要买尽可能多的雪糕。Tony可以按任意顺序购买雪糕。给你价格数组和现金量，请你计算并返回Tony用现金能够买到的雪糕的。你必须使用计数排序解决此问题。,costs.length==n1<=n<=101<=costs[i]<=101<=coins<=10,1,3
1483,112,2,224,题库,2,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维数组，用于表示​​​​​​项从到编号的任务。其中意味着第​​​​项任务将会于时进入任务队列，需要的时长完成执行。现有一个单线程CPU，同一时间只能执行任务，该CPU将会按照下述方式运行：返回CPU处理任务的顺序。,"如果CPU空闲，且任务队列中没有需要执行的任务，则CPU保持空闲状态。如果CPU空闲，但任务队列中有需要执行的任务，则CPU将会选择执行时间最短的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。一旦某项任务开始执行，CPU在执行完整个任务前都不会停止。CPU可以在完成一项任务后，立即开始执行一项新任务。tasks.length==n1<=n<=101<=enqueueTime,processingTime<=10",1,3
1484,106,2,96,题库,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,列表的（）指对所有元素进行按位运算的结果。如果列表中仅有一个元素，那么其就等于该元素。给你两个下标计数的数组和，两数组均由非负整数组成。根据每个数对，构造一个由（按位运算）结果组成的列表。其中且。返回上述列表的。,"例如，[1,2,3,4]的异或和等于1XOR2XOR3XOR4=4，而[3]的异或和等于1<=arr1.length,arr2.length<=100<=arr1[i],arr2[j]<=10",1,3
1485,81,2,17,题库,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个整数（进制）和一个基数，请你将从进制表示转换为进制表示，计算并返回转换后各位数字的。转换后，各位数字应当视作是进制数字，且它们的总和也应当按进制表示返回。,1<=n<=1002<=k<=10,1,1
1486,85,3,40,题库,2,2,0,0,2,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,元素的是该元素在一个数组中出现的次数。给你一个整数数组和一个整数。在一步操作中，你可以选择的一个下标，并将该下标对应元素的值增加。执行最多次操作后，返回数组中最高频元素的,1<=nums.length<=101<=nums[i]<=101<=k<=10,1,6
1487,92,3,139,题库,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,当一个字符串满足如下条件时，我们称它是：比方说，字符串和都是，但是，和。给你一个只包含英文元音字母的字符串，请你返回中。如果不存在这样的子字符串，请返回。是字符串中一个连续的字符序列。,所有5个英文元音字母（'a''e''i''o''u'）都必须出现一次。这些元音字母的顺序都必须按照字典序升序排布（也就是说所有的'a'都在'e'前面，所有的'e'都在'i'前面，以此类推）1<=word.length<=5*10word只包含字符'a''e''i''o'和'u',1,2
1488,130,3,112,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在一座城市里，你需要建栋新的建筑。这些新的建筑会从到编号排成一列。这座城市对这些新建筑有一些规定：除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组的形式给出，其中，表示建筑的高度。题目保证每栋建筑在中，同时建筑出现在中。请你返回建筑能达到的。,"每栋建筑的高度必须是一个非负整数。第一栋建筑的高度是任意两栋相邻建筑的高度差不能超过2<=n<=100<=restrictions.length<=min(n-1,102<=id<=n是唯一的0<=maxHeight<=10",1,2
1489,112,2,99,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串，它的下标处为小写英文字母，下标处为数字。定义一个函数，其中是一个字符且是一个数字，函数返回字母表中后面第个字符。对于每个下标，你需要将数字用替换。请你替换所有数字以后，将字符串返回。题目不会超过。,"比方说，shift('a',5)='f'和shift('x',0)='x'1<=s.length<=100只包含小写英文字母和数字。对所有下标处的，满足shift(s[i-1],s[i])<='z'",1,1
1490,30,1,279,题库,0,0,1,0,0,0,1,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你设计一个管理个座位预约的系统，座位编号从到。请你实现类：,SeatManager(intn)初始化一个SeatManager对象，它管理从到编号的个座位。所有座位初始都是可预约的。intreserve()返回可以预约座位的最小编号，此座位变为不可预约。voidunreserve(intseatNumber)将给定编号seatNumber对应的座位变成可以预约。1<=n<=101<=seatNumber<=n每一次对reserve的调用，题目保证至少存在一个可以预约的座位。每一次对unreserve的调用，题目保证seatNumber在调用函数前都是被预约状态。reserve和unreserve的调用不超过次。,1,2
1491,87,3,182,题库,2,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组。请你对执行一些操作（也可以不进行任何操作），使得数组满足以下条件：你可以执行以下2种操作任意次：请你返回执行以上操作后，在满足前文所述的条件下，中可能的。,arr中第一个元素必须为任意相邻两个元素的差的绝对值小于等于，也就是说，对于任意的1<=i<arr.length数组下标从0开始），都满足abs(arr[i]-arr[i-1])<=1abs(x)为的绝对值。arr中任意元素的值，使其变为一个更小的正整数重新排列arr中的元素，你可以以任意顺序重新排列。1<=arr.length<=101<=arr[i]<=10,1,3
1492,136,2,138,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个酒店里有个房间，这些房间用二维整数数组表示，其中表示有一个房间号为的房间且它的面积为。每一个房间号保证是的。同时给你个查询，用二维数组表示，其中。第个查询的答案是满足如下条件的房间：如果差的绝对值有的，选择的。如果，答案为。请你返回长度为的数组，其中为第个查询的结果。,"房间的面积为minSize，且abs(id-preferred的值，其中abs(x)是的绝对值。n==rooms.length1<=n<=10k==queries.length1<=k<=101<=roomId,preferred<=101<=size,minSize<=10",1,3
1493,59,3,67,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组（下标计数）以及两个整数和，请你找出一个下标，满足且。注意：表示的绝对值。返回。题目数据保证存在于中。,1<=nums.length<=10001<=nums[i]<=100<=start<nums.lengthtarget存在于nums,1,1
1494,87,4,211,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个仅由数字组成的字符串。请你判断能否将拆分成两个或者多个，使子字符串的按排列，且每两个的数值之等于。如果可以按要求拆分，返回；否则，返回。是字符串中的一个连续字符序列。,"例如，字符串s=""0090089""可以拆分成[""0090"",""089""]，数值为[90,89]。这些数值满足按降序排列，且相邻值相差，这种拆分方法可行。另一个例子中，字符串s=""001""可以拆分成[""0"",""01""][""00"",""1""]或[""0"",""0"",""1""]。然而，所有这些拆分方法都不可行，因为对应数值分别是[0,1][0,1]和[0,0,1]，都不满足按降序排列的要求。1<=s.length<=20仅由数字组成",1,2
1495,100,3,137,题库,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个表示大整数的字符串，和一个整数。如果某个整数是中各位数字的一个且它的，则称这个整数为。可能存在很多妙数，但是只需要关注的那些。返回要得到第个需要对执行的。测试用例是按存在第个最小妙数而生成的。,"例如，num=""5489355142""第1个最小妙数是""5489355214""第2个最小妙数是""5489355241""第3个最小妙数是""5489355412""第4个最小妙数是""5489355421""2<=num.length<=10001<=k<=1000num仅由数字组成",1,3
1496,117,2,101,题库,2,1,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个二维整数数组，其中表示第个区间开始于、结束于（包含两侧取值，）。区间的定义为区间中包含的整数数目，更正式地表达是。再给你一个整数数组。第个查询的答案是满足的。如果不存在这样的区间，那么答案是。以数组形式返回对应查询的所有答案。,1<=intervals.length<=101<=queries.length<=10intervals[i].length==21<=left<=right<=101<=queries[j]<=10,1,5
1497,97,2,42,题库,1,0,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二维整数数组，其中每个表示第个人的出生和死亡年份。年份的定义为这一年期间活着的人的数目。第个人被计入年份的人口需要满足：在闭区间内。注意，人不应当计入他们死亡当年的人口中。返回且的年份。,1<=logs.length<=1001950<=birth<death<=2050,1,2
1498,117,3,80,题库,1,2,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你两个的整数数组​​​​​​和​​​​​​，数组下标均计数。下标对中且。如果该下标对同时满足且，则称之为下标对，该下标对的为​​。​​返回所有下标对中的。如果不存在有效下标对，返回。一个数组，如果每个均有成立，那么该数组是一个数组。,"1<=nums1.length<=101<=nums2.length<=101<=nums1[i],nums2[j]<=10nums1和nums2都是非递增数组",1,4
1499,114,3,74,题库,1,0,2,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,一个数组的定义为这个数组中数组的。给你一个正整数数组，请你返回任意的的。由于答案可能很大，请你返回答案对的结果。请注意，最小乘积的最大值考虑的是取余操作的结果。题目保证最小乘积的最大值在的情况下可以用保存。定义为一个数组的部分。,"比方说，数组[3,2,5]（最小值是）的最小乘积为2*(3+2+5)=2*10=201<=nums.length<=101<=nums[i]<=10",1,4
1500,154,2,71,题库,0,2,3,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个，它含有个节点和条边。节点编号从到。给你一个字符串，其中是小写英文字母，表示图中第个节点的（下标从开始）。同时给你一个二维数组，其中表示从节点到节点有一条。图中一条有效是一个点序列，对于所有，从到在图中有一条有向边。路径的是路径中颜色的节点数目。请你返回给定图中有效路径里面的如果图中含有环，请返回。,"n==colors.lengthm==edges.length1<=n<=100<=m<=10colors只含有小写英文字母。0<=a,b<n",1,6
1501,112,2,150,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。我们可以给一个句子添加，并且将句子中所有单词。给你一个的句子，它包含的单词不超过个，请你重新构造并得到原本顺序的句子。,"比方说，句子""Thisisasentence""可以被打乱顺序得到""sentence4a3is2This1""或者""is2sentence4This1a3""2<=s.length<=200只包含小写和大写英文字母、空格以及从到的数字。中单词数目为到个。中的单词由单个空格分隔。不包含任何前导或者后缀空格。",1,2
1502,160,2,23,题库,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和分别表示两个内存条剩余可用内存的位数。现在有一个程序每秒递增的速度消耗着内存。在第秒（秒数从1开始），有位内存被分配到的内存条（如果两者一样多，则分配到第一个内存条）。如果两者剩余内存都不足位，那么程序将。请你返回一个数组，包含，其中是程序意外退出的时间（单位为秒），和分别是两个内存条最后剩余内存的位数。,"0<=memory1,memory2<=2-1",1,1
1503,199,3,90,题库,2,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个的字符矩阵，它表示一个箱子的侧视图。箱子的每一个格子可能为：这个箱子被，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力影响障碍物的位置，同时箱子旋转不会产生，也就是说石头的水平位置不会发生改变。题目保证初始时中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。请你返回一个的矩阵，表示按照上述旋转后，箱子内的结果。,"'#'表示石头'*'表示固定的障碍物'.'表示空位置m==box.lengthn==box[i].length1<=m,n<=500box[i][j]只可能是'#''*'或者'.'",1,3
1504,59,2,32,题库,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，请你返回所有下标对的结果之和。由于答案可能会很大，请你返回答案对的结果。函数返回输入数字的整数部分。,1<=nums.length<=101<=nums[i]<=10,1,4
1505,113,3,61,题库,1,1,0,0,1,2,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个数组的定义为数组中所有元素按位的结果；如果数组为，则异或总和为。给你一个数组，请你求出中每个的，计算并返回这些值相加之。在本题中，元素的不同子集应计数。数组是数组的一个的前提条件是：从删除几个（也可能不删除）元素能够得到。,"例如，数组[2,5,6]的异或总和为2XOR5XOR6=11<=nums.length<=121<=nums[i]<=20",1,5
1506,108,3,31,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二进制字符串，现需要将其转化为一个。请你计算并返回转化所需的字符交换次数，如果无法完成转化，返回。是指：相邻字符之间不存在相等情况的字符串。例如，字符串和属于交替字符串，但不是。任意两个字符都可以进行交换，。,1<=s.length<=1000s[i]的值为'0'或'1',1,2
1507,34,1,320,题库,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数数组和，请你实现一个支持下述两类查询的数据结构：实现类：,"FindSumPairs(int[]nums1,int[]nums2)使用整数数组nums1和nums2初始化FindSumPairs对象。voidadd(intindex,intval)将val加到nums2[index]上，即，执行nums2[index]+=valintcount(inttot)返回满足nums1[i]+nums2[j]==tot的下标对(i,j)数目。1<=nums1.length<=10001<=nums2.length<=101<=nums1[i]<=101<=nums2[i]<=100<=index<nums2.length1<=val<=101<=tot<=10最多调用add和count函数各1000",1,3
1508,98,3,55,题库,0,1,0,0,0,2,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有根长度互不相同的木棍，长度为从到的整数。请你将这些木棍排成一排，并满足从左侧根木棍。从左侧木棍的前提是这个木棍的不存在比它木棍。给你和，返回符合题目要求的排列。由于答案可能很大，请返回对的结果。,"例如，如果木棍排列为,2,,4]，那么从左侧可以看到的就是长度分别为的木棍。1<=n<=10001<=k<=n",1,3
1509,98,3,77,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二进制字符串。如果字符串中由组成的连续子字符串由组成的连续子字符串，返回；否则，返回。注意，如果字符串中不存在，此时认为由组成的最长连续子字符串的长度是。字符串中不存在的情况也适用此规则。,"例如，s=""00010""中，由组成的最长连续子字符串的长度是，由组成的最长连续子字符串的长度是1<=s.length<=100s[i]不是'0'就是'1'",1,1
1510,180,3,109,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个浮点数，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐趟列车。另给你一个长度为的整数数组，其中表示第趟列车的行驶距离（单位是千米）。每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。返回能满足你准时到达办公室所要求全部列车的时速（单位：千米每小时），如果无法准时到达，则返回。生成的测试用例保证答案不超过，且的。,例如，第趟列车需要1.5小时，那你必须再等待0.5小时，搭乘在第2小时发车的第趟列车。n==dist.length1<=n<=101<=dist[i]<=101<=hour<=10hours中，小数点后最多存在两位数字,1,2
1511,89,2,117,题库,1,0,0,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的二进制字符串和两个整数和。一开始，你在下标处，且该位置的值一定为。当同时满足如下条件时，你可以从下标移动到下标处：如果你可以到达的下标处，请你返回，否则返回。,"i+minJump<=j<=min(i+maxJump,s.length-1)s[j]=='0'2<=s.length<=10s[i]要么是'0'，要么是'1's[0]=='0'1<=minJump<=maxJump<s.length",1,3
1512,163,3,42,题库,1,1,0,0,1,2,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,Alice和Bob玩一个游戏，两人轮流操作，。总共有个石子排成一行。轮到某个玩家的回合时，如果石子的数目，他将执行以下操作：当只剩下石子时，游戏结束。Alice和Bob的为。Alice的目标是分数差，Bob的目标是分数差。给你一个长度为的整数数组，其中是第个石子的价值。请你返回在双方都采用策略的情况下，Alice和Bob的。,n==stones.length2<=n<=10-10<=stones[i]<=10,1,5
1513,75,1,0,题库,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表:计算每个雇员的奖金。如果一个雇员的id是并且他的名字不是以，那么他的奖金是他工资的，否则奖金为。返回的结果按照排序。返回结果格式如下面的例子所示。,,1,1
1514,98,2,32,题库,1,0,1,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果一个字符串不含有任何重复字符，我们称这个字符串为字符串。给你一个字符串，请你返回中长度为的的数量。注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。是一个字符串中连续的字符序列。,1<=s.length<=100​​​​​​只包含小写英文字母。,1,4
1515,67,2,121,题库,2,1,0,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,一个数对的等于。是一个数对数组中最大的。给你一个长度为的数组，请你将中的元素分成个数对，使得：请你在最优数对划分的方案下，返回最小的。,"比方说，如果我们有数对(1,5)(2,3)和(4,4)最大数对和为max(1+5,2+3,4+4)=max(6,5,8)=8nums中每个元素在数对中，且最大数对和的值n==nums.length2<=n<=10是1<=nums[i]<=10",1,4
1516,159,3,59,题库,3,0,1,0,1,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个的整数矩阵。指的是中一个正菱形上的元素之和。本题中的菱形必须为正方形旋转45度，且四个角都在一个格子当中。下图是四个可行的菱形，每个菱形和应该包含的格子都用了相应颜色标注在图中。注意，菱形可以是一个面积为0的区域，如上图中右下角的紫色菱形所示。请你按照返回中三个最大的。如果不同的和少于三个，则将它们全部返回。,"m==grid.lengthn==grid[i].length1<=m,n<=1001<=grid[i][j]<=10",1,6
1517,53,2,120,题库,1,1,0,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个整数数组和，它们长度都为。两个数组的为（）。请你将中的元素重新排列，使得。请你返回重新排列之后的。,"比方说，[1,2,3]和[3,2,1]的异或值之和等于(1XOR3)+(2XOR2)+(3XOR1)=2+0+2=4n==nums1.lengthn==nums2.length1<=n<=140<=nums1[i],nums2[i]<=10",1,4
1518,119,3,155,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,字母的取决于字母在字母表中的位置，计数。即，、、，以此类推。对某个由小写字母组成的字符串而言，其就等于将中每个字母的按顺序并成对应整数。给你三个字符串、和，每个字符串都由从到（和）的小写英文字母组成。如果和的等于的数值，返回；否则，返回。,"例如，s=""acb""，依次连接每个字母的字母值可以得到""021""，转换为整数得到1<=firstWord.length,secondWord.length,targetWord.length<=8firstWordsecondWord和targetWord仅由从'a'到'j''a'和'j'）的小写英文字母组成",1,1
1519,113,2,140,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个非常大的整数和一个整数数字，大整数用一个字符串表示。中每一位数字和数字都处于闭区间中，且可能表示一个。你打算通过在的十进制表示的任意位置插入来的​​​​​​。但在负号的左边插入。返回插入操作后，用字符串表示的的最大值。,"例如，如果n=73且x=6，那么最佳方案是将插入和之间，使n=763如果n=-55且x=2，那么最佳方案是将插在第一个之前，使n=-2551<=n.length<=101<=x<=9​​​中每一位的数字都在闭区间[1,9]中。代表一个有效的整数。表示负数时，将会以字符'-'开始。",1,2
1520,349,2,72,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个的整数数组和，长度分别为​​​​​​和​​​​​​。是第​​​​台服务器的，而是处理第项任务（单位：秒）。你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第项任务在第秒可以开始处理，相应地，第项任务在第秒可以开始处理。处理第项任务时，你需要为它分配一台的空闲服务器。如果存在多台相同权重的空闲服务器，请选择的服务器。如果一台空闲服务器在第秒分配到第项任务，那么在时它将恢复空闲状态。如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并地处理剩余任务。如果有多项任务等待分配，则按照的顺序完成分配。如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。构建长度为的答案数组，其中是第项任务分配的服务器的下标。返回答案数组​​​​。,"servers.length==ntasks.length==m1<=n,m<=2*101<=servers[i],tasks[j]<=2*10",1,2
1521,276,3,222,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经条道路。道路的长度用一个长度为的整数数组表示，其中表示第条道路的长度（单位：）。另给你一个整数，表示你在道路上前进的速度（单位：）。当你通过第条路之后，就必须休息并等待，直到才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。然而，为了能准时到达，你可以选择一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。返回准时抵达会议现场所需要的，如果，返回。,例如，如果你通过一条道路用去1.4小时，那你必须停下来等待，到小时才可以继续通过下一条道路。如果通过一条道路恰好用去小时，就无需等待，可以直接继续。例如，假设通过第条道路用去1.4小时，且通过第条道路用去0.6小时。跳过第条道路的休息时间意味着你将会在恰好小时完成通过第条道路，且你能够立即开始通过第条道路。n==dist.length1<=n<=10001<=dist[i]<=101<=speed<=101<=hoursBefore<=10,1,2
1522,147,2,10,题库,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你的鸡蛋，和一栋从第层到第层共有层楼的建筑。已知存在楼层，满足，任何从的楼层落下的鸡蛋都，从的楼层落下的鸡蛋都。每次操作，你可以取一枚的鸡蛋并把它从任一楼层扔下（满足）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中这枚鸡蛋。请你计算并返回要确定的是多少？,1<=n<=1000,1,2
1523,40,3,96,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个大小为的二进制矩阵和。现矩阵中的元素，如果能够使与一致，返回；否则，返回,n==mat.length==target.lengthn==mat[i].length==target[i].length1<=n<=10mat[i][j]和target[i][j]不是就是,1,2
1524,61,3,36,题库,2,0,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，你的目标是令中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：返回使中的所有元素相等的操作次数。,1<=nums.length<=5*101<=nums[i]<=5*10,1,2
1525,77,3,145,题库,1,2,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个二进制字符串。你可以按任意顺序执行以下两种操作任意次：请你返回使变成字符串的前提下，的操作次数。我们称一个字符串是的，需要满足任意相邻字符都不同。,"类型1：删除字符串的第一个字符并将它到字符串结尾。类型2：选择字符串中任意一个字符并将该字符反转，也就是如果值为'0'，则反转得到'1'，反之亦然。比方说，字符串""010""和""1010""都是交替的，但是字符串""0100""不是。1<=s.length<=10s[i]要么是'0'，要么是'1'",1,4
1526,241,3,255,题库,2,1,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你个包裹，你需要把它们装在箱子里，。总共有个供应商提供的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。包裹的尺寸用一个整数数组表示，其中是第个包裹的尺寸。供应商用二维数组表示，其中是第个供应商提供的所有箱子尺寸的数组。你想要选择并只使用该供应商提供的箱子，使得。对于每个装了包裹的箱子，我们定义空间等于。为箱子中浪费空间的总和。请你选择箱子供应商，使得。如果将所有包裹放入箱子中，请你返回。由于答案可能会，请返回它对的结果。,"比方说，如果你想要用尺寸数组为[4,8]的箱子装下尺寸为[2,3,5]的包裹，你可以将尺寸为和的两个包裹装入两个尺寸为的箱子中，同时把尺寸为的包裹装入尺寸为的箱子中。总浪费空间为(4-2)+(4-3)+(8-5)=6n==packages.lengthm==boxes.length1<=n<=101<=m<=101<=packages[i]<=101<=boxes[j].length<=101<=boxes[j][k]<=10sum(boxes[j].length)<=10boxes[j]中的元素互不相同",1,4
1527,75,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,表:编写一个SQL查询，该查询可以获取在年登录过的所有用户的本年度登录时间。结果集包含年没有登录过的用户。返回的结果集可以按排列。查询结果格式如下例。,,1,1
1528,81,2,55,题库,1,0,1,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个二维整数数组和两个整数和。每个表示一个从到的。如果闭区间内每个整数都被中区间覆盖，那么请你返回，否则返回。已知区间，如果整数满足，那么我们称整数被覆盖了。,1<=ranges.length<=501<=start<=end<=501<=left<=right<=50,1,3
1529,178,2,46,题库,2,1,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,一个班级里有个学生，编号为到。每个学生会依次回答问题，编号为的学生先回答，然后是编号为的学生，以此类推，直到编号为的学生，然后老师会重复这个过程，重新从编号为的学生开始回答问题。给你一个长度为且下标从开始的整数数组和一个整数。一开始粉笔盒里总共有支粉笔。当编号为的学生回答问题时，他会消耗支粉笔。如果剩余粉笔数量，那么学生需要粉笔。请你返回需要粉笔的学生。,chalk.length==n1<=n<=101<=chalk[i]<=101<=k<=10,1,4
1530,81,2,58,题库,2,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个的指的是一个填满整数的方格阵，且每一行、每一列以及两条对角线的和。幻方中的整数。显然，每个的方格都是一个幻方。给你一个的整数矩阵，请你返回矩阵中的（即边长）。,"m==grid.lengthn==grid[i].length1<=m,n<=501<=grid[i][j]<=10",1,3
1531,118,3,310,题库,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个布尔表达式，用字符串表示。这个字符串包含字符，，（按位运算），（按位运算），和。你的目标是将布尔表达式的（也就是将变为，或者将变为），请你返回达成目标需要的次数。可执行的如下：的与。计算表达式时，括号优先级，然后按照的顺序运算。,"比方说，""()1|1""和""(1)&()""不是有效布尔表达式。而""1""""(((1))|(0))""和""1|(0&(1))""是布尔表达式。比方说，如果表达式expression=""1|1|(0&0)&1""，它的为1|1|(0&0)&1=1|1|0&1=1|0&1=1&1=1。我们想要执行操作将表达式的值变成将一个'1'变成一个'0'将一个'0'变成一个'1'将一个'&'变成一个'|'将一个'|'变成一个'&'1<=expression.length<=10expression只包含'1''0''&''|''('和')'所有括号都有与之匹配的对应括号。不会有空的括号（也就是说""()""不是expression的子字符串）。",1,4
1532,92,2,60,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组（下标计数）。在一步操作中，需先选出两个下标和，其中是一个非空字符串，接着将中的字符移动到中的位置上。如果执行任意步操作可以使中的每个字符串都相等，返回；否则，返回。,1<=words.length<=1001<=words[i].length<=100words[i]由小写英文字母组成,1,3
1533,261,3,113,题库,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串和，其中是的一个。同时，给你一个元素且下标计数的整数数组，该数组是中下标的一个子集（的下标也计数）。请你找出一个整数（），选出中的个下标，然后从中移除这些下标对应的个字符。整数需满足：在执行完上述步骤后，仍然是的一个。更正式的解释是，对于每个，先标记出位于的字符，接着移除所有标记过的字符，然后检查是否仍然是的一个子序列。返回你可以找出的，满足在移除字符后仍然是的一个子序列。字符串的一个是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。,1<=p.length<=s.length<=100<=removable.length<s.length0<=removable[i]<s.length是的一个子字符串和都由小写英文字母组成removable中的元素互不相同,1,3
1534,107,4,234,题库,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是一个由三个整数组成的数组。给你一个二维整数数组，其中表示第个。同时，给你一个整数数组，表示你想要得到的。为了得到，你需要对执行下面的操作（可能次）：如果通过以上操作我们可以使得目标成为的一个，则返回；否则，返回。,"选出两个下标（下标从0开始计数）和i!=j），并triplets[j]为[max(a,a),max(b,b),max(c,c例如，triplets[i]=[2,5,3]且triplets[j]=[1,7,5]triplets[j]将会更新为[max(2,1),max(5,7),max(3,5)]=[2,7,5]1<=triplets.length<=10triplets[i].length==target.length==31<=a,b,c,x,y,z<=1000",1,2
1535,351,2,92,题库,0,2,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,名运动员参与一场锦标赛，所有运动员站成一排，并根据站位从到编号（运动员是这一排中的第一个运动员，运动员是第二个运动员，依此类推）。锦标赛由多个回合组成（从回合开始）。每一回合中，这一排从前往后数的第名运动员需要与从后往前数的第名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。编号为和的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以谁是这一回合的获胜者。给你三个整数、和。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的回合数和回合数。,"例如，当前回合中，运动员1,2,4,6,7运动员需要和运动员比拼运动员需要和运动员比拼运动员轮空晋级下一回合2<=n<=281<=firstPlayer<secondPlayer<=n",1,2
1536,94,2,69,题库,2,1,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个2D网格中的是指那些其相邻格子(上、下、左、右)的元素。给你一个的矩阵，其中任意两个相邻格子的值都。找出并。你可以假设整个矩阵周边环绕着一圈值为的格子。要求必须写出时间复杂度为或的算法,"m==mat.lengthn==mat[i].length1<=m,n<=5001<=mat[i][j]<=10任意两个相邻元素均不相等.",1,3
1537,73,3,32,题库,1,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，表示一个大整数。请你在字符串的所有中找出，并以字符串形式返回。如果不存在奇数，则返回一个空字符串。是字符串中的一个连续的字符序列。,1<=num.length<=10num仅由数字组成且不含前导零,1,3
1538,203,3,226,题库,1,0,0,0,0,1,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一款新的在线电子游戏在近期发布，在该电子游戏中，以为周期规划若干时长为的游戏对局。这意味着，在、、和，将会开始一个新的对局，其中用一个从到的整数表示。游戏中使用，所以一天中最早的时间是，最晚的时间是。给你两个字符串和，均符合格式，分别表示你和游戏的确切时间，请计算在整个游戏会话期间，你完成的。如果，这表示你玩了个通宵（也就是从到午夜，再从午夜到）。假设你是从进入游戏，并在退出游戏，请计算并返回你完成的。,"例如，如果startTime=""05:20""且finishTime=""05:59""，这意味着你仅仅完成从05:30到05:45这一个完整对局。而你没有完成从05:15到05:30的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从05:45到06:00的完整对局，因为你是在对局结束前退出的游戏。startTime和finishTime的格式为HH:MM00<=HH<=2300<=MM<=59startTime和finishTime不相等",1,2
1539,132,2,105,题库,2,2,0,1,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个的二进制矩阵和，它们只包含（表示水域）和（表示陆地）。一个是由（水平或者竖直）上相邻的组成的区域。任何矩阵以外的区域都视为水域。如果的一个岛屿，被的一个岛屿包含，也就是说中该岛屿的每一个格子都被中同一个岛屿完全包含，那么我们称中的这个岛屿为。请你返回中的。,"m==grid1.length==grid2.lengthn==grid1[i].length==grid2[i].length1<=m,n<=500grid1[i][j]和grid2[i][j]都要么是要么是",1,5
1540,132,2,150,题库,1,0,1,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,MEDIUM,一个数组的定义为：且的的。如果中所有元素都，那么差绝对值的最小值为。给你一个整数数组和查询数组，其中。对于每个查询，计算中，子数组包含数组（下标从开始）中下标在和之间的所有元素（包含和在内）。请你返回，其中是第个查询的答案。是一个数组中连续的一段元素。的值定义为：,"比方说，数组[5,,7,2]差绝对值的最小值是|2-3|=1。注意答案不为，因为a[i]和a[j]必须不相等。如果x>=0，那么值为如果x<0，那么值为2<=nums.length<=101<=nums[i]<=1001<=queries.length<=2*100<=l<r<nums.length",1,2
1541,79,1,95,题库,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,表:查询每个工资类别的银行账户数量。工资类别如下：：所有工资美元。结果表包含所有三个类别。如果某个类别中没有帐户，则报告。按返回结果表。查询结果格式如下示例。,"""LowSalary""：所有工资严格低于20000美元。""AverageSalary""范围内的所有工资[$20000,$50000]""HighSalary""：所有工资严格大于50000美元。",1,1
1542,78,4,36,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组，如果删除元素后，数组，那么请你返回，否则返回。如果数组本身已经是严格递增的，请你也返回。数组是的定义为：对于任意下标的都满足。,2<=nums.length<=10001<=nums[i]<=1000,1,1
1543,73,2,81,题库,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串和，请你对反复执行以下操作直到子字符串都被删除：请你返回从中删除所有子字符串以后得到的剩余字符串。一个是一个字符串中连续的字符序列。,找到中最左边的子字符串part，并将它从中删除。1<=s.length<=10001<=part.length<=1000​​​​​​和part只包小写英文字母。,1,1
1544,129,2,65,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个下标从开始的数组的定义为下标处元素之减去下标处元素之。给你一个数组，请你返回中任意子序列的（子序列的下标从0开始编号）。一个数组的是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，是的一个子序列（加粗元素），但是不是。,"比方说，数组[4,2,5,3]的交替和为(4+5)-(2+3)=41<=nums.length<=101<=nums[i]<=10",1,2
1545,169,1,734,题库,1,0,3,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有一个电影租借公司和个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。所有电影用二维整数数组表示，其中表示商店有一份电影的拷贝，租借价格为。每个商店有编号为的电影拷贝。系统需要支持以下操作：请你实现类：测试数据保证操作中指定商店拥有的指定电影，且操作指定的商店指定电影。,"Search：找到拥有指定电影且未借出的商店中最便宜的5个。商店需要按照升序排序，如果价格相同，则shop的商店排在前面。如果查询结果少于5个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。Rent：从指定商店借出指定电影，题目保证指定电影在指定商店未借出Drop：在指定商店返还之前已借出的指定电影。Report：返回最便宜的5部已借出电影（可能有重复的电影ID），将结果用二维列表res返回，其中res[j]=[shop,movie表示第便宜的已借出电影是从商店shop借出的电影movieres中的电影需要按升序排序；如果价格相同，则shop的排在前面；如果仍然相同，则movie较小的排在前面。如果当前借出的电影小于5部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。MovieRentingSystem(intn,int[][]entries)将MovieRentingSystem对象用个商店和entries表示的电影列表初始化。List<Integer>search(intmovie)如上所述，返回未借出指定movie的商店列表。voidrent(intshop,intmovie)从指定商店shop借出指定电影movievoiddrop(intshop,intmovie)在指定商店shop返还之前借出的电影movieList<List<Integer>>report()如上所述，返回最便宜的已借出电影列表。1<=n<=3*101<=entries.length<=100<=shop<n1<=movie,price<=10每个商店有一份电影movie的拷贝。searchrentdrop和report的调用不超过次。",1,5
1546,57,2,67,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,两个数对和之间的定义为。给你一个整数数组，选出四个下标、、和，使数对和之间的取到。返回以这种方式取得的乘积差中的。,"例如，(5,6)和(2,7)之间的乘积差是(5*6)-(2*7)=164<=nums.length<=101<=nums[i]<=10",1,2
1547,142,2,71,题库,3,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个大小为的整数矩阵​​​，其中和都是；另给你一个整数。矩阵由若干层组成，如下图所示，每种颜色代表一层：矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其方向的相邻元素。轮转示例如下：返回执行次循环轮转操作后的矩阵。,"m==grid.lengthn==grid[i].length2<=m,n<=50和都是1<=grid[i][j]<=50001<=k<=10",1,3
1548,98,3,73,题库,1,0,1,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,如果某个字符串中字母出现次，则称其为字符串。给你一个字符串，该字符串由前十个小写英文字母组成（到）。请你返回中的数目如果同样的子字符串在中出现多次，那么应当对分别计数是字符串中的一个连续字符序列。,"例如，""ccjjc""和""abab""都是最美字符串，但""ab""不是。1<=word.length<=10word由从'a'到'j'的小写英文字母组成",1,4
1549,211,2,98,题库,0,1,3,0,0,2,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你是一只蚂蚁，负责为蚁群构筑间编号从到的新房间。给你一个且长度为的整数数组作为扩建计划。其中，表示在构筑房间之前，你必须先构筑房间，并且这两个房间必须相连。房间已经构筑完成，所以。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间可以访问到每个房间。你一次只能构筑房间。你可以在房间之间自由穿行，只要这些房间是。如果房间已经构筑完成，那么你就可以构筑房间。返回你构筑所有房间的。由于答案可能很大，请返回对的结果。,n==prevRoom.length2<=n<=10prevRoom[0]==-1对于所有的1<=i<n，都有0<=prevRoom[i]<n题目保证所有房间都构筑完成后，从房间可以访问到每个房间,1,6
1550,64,2,54,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个（）。请你构建一个的数组，其中，对于每个（），都满足。返回构建好的数组。是一个由到（和也包含在内）的不同整数组成的数组。,1<=nums.length<=10000<=nums[i]<nums.lengthnums中的元素互不相同,1,2
1551,304,3,59,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个且长度为的整数数组，其中是第个怪物与城市的（单位：米）。怪物以的速度走向城市。给你一个长度为的整数数组表示每个怪物的速度，其中是第个怪物的速度（单位：米/分）。怪物从时开始移动。你有一把武器，并可以在每一分钟的开始时使用，包括第0分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物在某一分钟开始时到达城市，这会被视为游戏，在你可以使用武器之前，游戏就会结束。返回在你输掉游戏前可以消灭的怪物的数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回。,"n==dist.length==speed.length1<=n<=101<=dist[i],speed[i]<=10",1,3
1552,110,3,80,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们称一个数字字符串是当它满足（下标从开始）下标处的数字为且下标处的数字为（，，或）。给你一个整数，请你返回长度为且为好数字的数字字符串。由于答案可能会很大，请你将它对。一个是每一位都由到组成的字符串，且可能包含前导0。,"比方说，""2582""是好数字，因为偶数下标处的数字（和）是偶数且奇数下标处的数字（和）为质数。但""3245""好数字，因为在偶数下标处但不是偶数。1<=n<=10",1,2
1553,230,3,94,题库,1,1,0,1,2,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个国家由个编号为到的城市组成。在这个国家里，城市之间都有一条道路连接。总共有个编号为到的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能出现，但同一个城市在一条路径中不会连续出现。给你一个整数和二维数组，其中是一个整数数组，表示第个朋友走过的路径，请你返回朋友都走过的的长度，如果不存在公共子路径，请你返回。一个指的是一条路径中连续的城市序列。,1<=n<=10m==paths.length2<=m<=10sum(paths[i].length)<=100<=paths[i][j]<npaths[i]中同一个城市不会连续重复出现。,1,5
1554,32,2,9,题库,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个指的是满足的三元组，和。给你一个整数，请你返回满足的的数目。,1<=n<=250,1,2
1555,157,3,130,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的迷宫矩阵（），矩阵中有空格子（用表示）和墙（用表示）。同时给你迷宫的入口，用表示你一开始所在格子的行和列。每一步操作，你可以往，，或者移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离的出口。的含义是上的。格子出口。请你返回从到最近出口的最短路径的，如果不存在这样的路径，请你返回。,"maze.length==mmaze[i].length==n1<=m,n<=100maze[i][j]要么是'.'，要么是'+'entrance.length==20<=entrancerow<m0<=entrancecol<nentrance一定是空格子。",1,3
1556,179,3,130,题库,0,1,0,0,0,2,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Alice和Bob玩一个游戏，两人轮流行动，。给你一个的字符串，每一个字符为数字字符或者。每一次操作中，如果中至少有一个，那么玩家可以执行以下操作：当中没有时，游戏结束。Bob获胜的条件是中前一半数字的和后一半数字的和。Alice获胜的条件是前一半的和与后一半的和。在Alice和Bob都采取策略的前提下，如果Alice获胜，请返回，如果Bob获胜，请返回。,"比方说，游戏结束时num=""243801""，那么Bob获胜，因为2+4+3=8+0+1。如果游戏结束时num=""243803""，那么Alice获胜，因为2+4+3!=8+0+32<=num.length<=10num.length是num只包含数字字符和'?'",1,3
1557,245,3,141,题库,0,1,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个国家有个城市，城市编号为到，题目保证都由双向道路。道路由二维整数数组表示，其中表示城市和之间有一条双向道路，耗费时间为分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。每次经过一个城市时，你需要付通行费。通行费用一个长度为且下标从开始的整数数组表示，其中是你经过城市需要支付的费用。一开始，你在城市，你想要在（包含分钟）到达城市。旅行的为你经过的所有城市（起点和终点城市的通行费）。给你，和，请你返回完成旅行的，如果无法在分钟以内完成旅行，请你返回。,"1<=maxTime<=1000n==passingFees.length2<=n<=1000n-1<=edges.length<=10000<=x,y<=n-11<=time<=10001<=passingFees[j]<=1000图中两个节点之间可能有多条路径。图中不含有自环。",1,2
1558,66,2,72,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个长度为的整数数组。请你构建一个长度为的答案数组，数组下标，对于所有的，满足下述所有要求：具体而言，由两个数组形成。返回数组。,ans[i]==nums[i]ans[i+n]==nums[i]n==nums.length1<=n<=10001<=nums[i]<=1000,1,1
1559,108,3,41,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，返回中的的个数。即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。是正着读和反着读一样的字符串。是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。,"例如，""ace""是的一个子序列。3<=s.length<=10仅由小写英文字母组成",1,3
1560,95,3,17,题库,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个整数和。构造一个的网格，其中每个单元格最开始是白色。请你用三种颜色为每个单元格涂色。所有单元格都需要被涂色。涂色方案需要满足：。返回网格涂色的方法数。因为答案可能非常大，返回的结果。,1<=m<=51<=n<=1000,1,1
1561,158,3,265,题库,0,2,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你个，存储在数组中（），对应棵不同的二叉搜索树。中的每棵二叉搜索树，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：如果在执行次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的；如果无法构造一棵有效的二叉搜索树返回。二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：叶节点是不含子节点的节点。,"选择两个不同的下标和，要求满足在trees[i]中的某个叶节点的值等于trees[j]的根节点的值trees[j]替换trees[i]中的那个叶节点。trees中移除trees[j]任意节点的左子树中的值都严格小于此节点的值。任意节点的右子树中的值都严格大于此节点的值。n==trees.length1<=n<=5*10每棵树中节点数目在范围[1,3]内。输入数据的每个节点可能有子节点但不存在子节点的子节点trees中不存在两棵树根节点值相同的情况。输入中的所有树都是有效的二叉树搜索树1<=TreeNode.val<=5*10",1,5
1562,109,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"表:表:用户的是消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为。确认率四舍五入到。编写一个SQL查询来查找每个用户的确认率。

以任意顺序返回结果表。

查询结果格式如下所示。

",,1,1
1563,122,3,118,题库,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。给你一个由若干单词组成的字符串，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的中单词的数目。,1<=text.length<=100<=brokenLetters.length<=26text由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格每个单词仅由小写英文字母组成brokenLetters由互不相同的小写英文字母组成,1,2
1564,138,4,54,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的整数数组，用于表示梯子上每一台阶的。当前你正站在高度为的地板上，并打算爬到最后一个台阶。另给你一个整数。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）高度的台阶。当然，你也可以在任何正高度处插入尚不存在的新台阶。返回爬到最后一阶时必须添加到梯子上的台阶数。,1<=rungs.length<=101<=rungs[i]<=101<=dist<=10rungs严格递增,1,2
1565,146,2,93,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的整数矩阵（下标从开始）。一开始你的得分为，你想最大化从矩阵中得到的分数。你的得分方式为：中选取一个格子，选中坐标为的格子会给你的总得分。然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行和（其中），选中坐标为和的格子，你的总得分。请你返回你能得到的得分。定义为：,"如果x>=0，那么值为如果x，那么值为m==points.lengthn==points[r].length1<=m,n<=101<=m*n<=100<=points[r][c]<=10",1,2
1566,161,2,139,题库,1,0,0,1,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一棵个节点的有根树，节点编号从到。每个节点的编号表示这个节点的（也就是说节点的基因值为）。两个基因值的是两者的。给你整数数组，其中是节点的父节点。如果节点是树的，那么。给你查询数组，其中。对于查询，请你找到和的，其中是节点到根之间的任意节点（包含和根节点）。更正式的，你想要最大化。请你返回数组，其中是第个查询的答案。,2<=parents.length<=10对于每个根节点的，有0<=parents[i]<=parents.length-1parents[root]==-11<=queries.length<=3*100<=node<=parents.length-10<=val<=2*10,1,3
1567,56,2,27,题库,1,0,1,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，如果是一个字符串，请你返回，否则请返回。如果中出现过的字符的出现次数，那么我们称字符串是字符串。,1<=s.length<=1000只包含小写英文字母。,1,3
1568,174,2,131,题库,1,0,2,0,0,0,0,1,1,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,有个朋友在举办一个派对，这些朋友从到编号。派对里有张椅子，编号为到。当一个朋友到达派对时，他会占据且未被占据的椅子。当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。给你一个下标从开始的二维整数数组，其中表示第个朋友到达和离开的时刻，同时给你一个整数。所有到达时间。请你返回编号为的朋友占据的。,比方说，当一个朋友到达时，如果椅子和被占据了，那么他会占据号椅子。n==times.length2<=n<=10times[i].length==21<=arrival<leaving<=100<=targetFriend<=n-1每个arrival时刻互不相同,1,3
1569,258,3,244,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有的颜色。给你二维整数数组，其中表示线段为且颜色为。线段间重叠部分的颜色会被。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个表示这个混合颜色。为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的来表示颜色集合。你想要用不重叠来这幅混合颜色的画。这些线段可以用二维数组表示，其中表示一个的颜色为。请你返回二维数组，它表示最终绘画的结果（被涂色的部分不出现在结果中）。你可以按返回最终数组的结果。是数轴上点和点之间的部分，点且点。,"比方说，如果颜色和被混合，那么结果颜色为{2,4,6}比方说，这幅画由segments=[[1,4,5],[1,7,7]]组成，那么它可以表示为painting=[[1,4,12],[4,7,7]][1,4)由颜色{5,7}组成（和为），分别来自第一个线段和第二个线段。[4,7)由颜色{7}组成，来自第二个线段。1<=segments.length<=2*10segments[i].length==31<=start<end<=101<=color<=10每种颜色color互不相同。",1,2
1570,119,2,57,题库,1,0,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有个人排成一个队列，编号为到。给你以一个整数数组，每个整数，表示第个人的高度。一个人能他右边另一个人的条件是这两人之间的所有人都比他们两人。更正式的，第个人能看到第个人的条件是且。请你返回一个长度为的数组，其中是第个人在他右侧队列中能的。,n==heights.length1<=n<=101<=heights[i]<=10heights中所有数互不相同,1,3
1571,127,2,112,题库,2,0,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由小写字母组成的字符串，以及一个整数。首先，用字母在字母表中的位置替换该字母，将为一个整数（也就是，用替换，用替换，...用替换）。接着，将整数为其。共重复操作。例如，如果且，那么执行下述步骤后得到的结果是整数：返回执行上述操作后得到的结果整数。,"转化：""zbax""➝""(26)(2)(1)(24)""➝""262124""➝262124转换#1262124➝2+6+2+1+2+4➝17转换#217➝1+7➝81<=s.length<=1001<=k<=10由小写英文字母组成",1,2
1572,176,3,61,题库,2,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个字符串，该字符串表示一个大整数。另给你一个长度为且的整数数组，该数组将中的每个数字映射到另一个数字。更规范的说法是，数字映射为数字。你可以选择的任一子字符串。子字符串意味着将每位数字替换为该数字在中的映射（也就是说，将替换为）。请你找出在对的任一子字符串执行突变操作（也可以不执行）后，可能得到的，并用字符串表示返回。是字符串中的一个连续序列。,1<=num.length<=10num仅由数字0-9组成change.length==100<=change[d]<=9,1,3
1573,257,2,164,题库,1,2,0,0,2,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一份由个问题组成的调查问卷，每个问题的答案要么是（no，否），要么是（yes，是）。这份调查问卷被分发给名学生和名导师，学生和导师的编号都是从到。学生的答案用一个二维整数数组表示，其中是一个整数数组，包含第名学生对调查问卷给出的答案（）。导师的答案用一个二维整数数组表示，其中是一个整数数组，包含第名导师对调查问卷给出的答案（）。每个学生都会被分配给导师，而每位导师也会分配到学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。请你找出最优的学生与导师的配对方案，以提高。给你和，返回可以得到的。,"例如，学生答案为[1,而导师答案为[0,，那么他们的兼容性评分为2，因为只有第二个和第三个答案相同。m==students.length==mentors.lengthn==students[i].length==mentors[j].length1<=m,n<=8students[i][k]为或mentors[j][k]为或",1,5
1574,286,5,362,题库,2,0,1,1,1,0,0,0,0,0,1,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组，其中是一个表示文件系统中第个文件夹的绝对路径的数组。如果两个文件夹（不需要在同一层级）包含子文件夹并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级需要相同。如果存在两个（或两个以上）文件夹，则需要将这些文件夹和所有它们的子文件夹为待删除。一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。返回二维数组，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按返回。,"例如，[""one"",""two"",""three""]表示路径""/one/two/three""例如，下面文件结构中的文件夹""/a""和""/b""相同。它们（以及它们的子文件夹）应该被/a/x/a/x/y/a/z/b/x/b/x/y/b/z然而，如果文件结构中还包含路径""/b/w""，那么文件夹""/a""和""/b""就不相同。注意，即便添加了新的文件夹""/b/w""，仍然认为""/a/x""和""/b/x""相同。1<=paths.length<=2*101<=paths[i].length<=5001<=paths[i][j].length<=101<=sum(paths[i][j].length)<=2*10path[i][j]由小写英文字母组成不会存在两个路径都指向同一个文件夹的情况对于不在根层级的任意文件夹，其父文件夹也会包含在输入中",1,5
1575,39,2,8,题库,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数。如果，返回；否则，返回。如果存在整数，满足，那么整数就是的一个。,1<=n<=10,1,1
1576,156,2,106,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你个项目，编号从到。同时给你一个整数数组，其中每个表示第个项目中的阶段任务数量。你可以按下面两个规则参与项目中的工作：一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将。注意，由于这些条件的限制，你可能无法完成所有阶段任务。返回在不违反上面规则的情况下你能工作多少周。,每周，你将会完成某一个项目中的恰好一个阶段任务。你每周都工作。连续的两周中，你参与并完成同一个项目中的两个阶段任务。n==milestones.length1<=n<=101<=milestones[i]<=10,1,2
1577,106,3,40,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个用无限二维网格表示的花园，整数坐标处都有一棵苹果树。整数坐标处的苹果树有个苹果。你将会买下正中心坐标是的一块，且每条边都与两条坐标轴之一平行。给你一个整数，请你返回土地的，使得有个苹果在土地。的值定义为：,如果x>=0，那么值为如果x<0，那么值为1<=neededApples<=10,1,2
1578,116,3,93,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,是由个，紧接着个，最后个组成的序列。给你一个数组（包含整数，和），请你返回。由于答案可能很大，请你将它对后返回。一个数组的是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的不同，那么这两个子序列是。,"比方说，[0,1,2]和[0,0,1,1,1,2]是特殊序列。相反，[2,1,0][1]和[0,1,2,0]就不是特殊序列。1<=nums.length<=100<=nums[i]<=2",1,2
1579,69,3,25,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个字符串如果没有相同字符，那么它就是一个。给你一个字符串，请你从删除的字符，使它变成一个。请你返回删除后的字符串。题目数据保证答案总是。,1<=s.length<=10只包含小写英文字母。,1,1
1580,262,2,89,题库,3,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的网格，其中表示游戏棋盘上的格子。棋盘上空格用表示，白色格子用表示，黑色格子用表示。游戏中每次操作步骤为：选择一个空格子，将它变成你正在执行的颜色（要么白色，要么黑色）。但是，操作必须满足：涂色后这个格子是（好线段可以是水平的，竖直的或者是对角线）。指的是一个包含的线段，线段两个端点格子为，且中间剩余格子的颜色都为（线段上不能有任何空格子）。你可以在下图找到好线段的例子：给你两个整数和以及一个字符，表示你正在执行操作的颜色（白或者黑），如果将格子变成颜色后，是一个操作，那么返回，如果不是合法操作返回。,"board.length==board[r].length==80<=rMove,cMove<8board[rMove][cMove]=='.'color要么是'B'要么是'W'",1,3
1581,177,3,52,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在设计一个动态数组。给你一个下标从开始的整数数组，其中是时刻数组中的元素数目。除此以外，你还有一个整数，表示你可以数组大小的次数（每次都可以调整成大小）。时刻数组的大小必须大于等于，因为数组需要有足够的空间容纳所有元素。时刻为，浪费空间为满足的每一个时刻浪费的空间。在调整数组大小不超过次的前提下，请你返回。数组最开始时可以为，且调整大小的操作次数。,1<=nums.length<=2001<=nums[i]<=100<=k<=nums.length-1,1,2
1582,166,2,25,题库,1,0,0,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的字符串，你需要找到两个子字符串，它们的长度都必须为，使得它们长度的乘积最大。更正式地，你想要选择四个整数，，，，使得，且子字符串和都是回文串且长度为奇数。表示下标从到且两端下标的子字符串。请你返回两个不重叠回文子字符串长度的乘积。指的是一个从前往后读和从后往前读一模一样的字符串。指的是一个字符串中一段连续字符。,2<=s.length<=10只包含小写英文字母。,1,3
1583,78,2,78,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串和一个字符串数组，请你判断是否为的。字符串要成为的，需要满足：可以由中的前（为）个字符串按顺序相连得到，且不超过。如果是的，返回；否则，返回。,1<=words.length<=1001<=words[i].length<=201<=s.length<=1000words[i]和仅由小写英文字母组成,1,2
1584,92,2,82,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，数组，其中表示第堆石子中的石子数量。另给你一个整数，请你执行下述操作次：你可以对石子多次执行此操作。返回执行次操作后，剩下石子的总数。为或的整数。（即，对向下取整）。,选出任一石子堆piles[i]，并从中floor(piles[i]/2)颗石子。1<=piles.length<=101<=piles[i]<=101<=k<=10,1,2
1585,84,3,116,题库,1,1,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，，且长度为偶数。字符串由个开括号和个闭括号组成。只有能满足下述所有条件的字符串才能称为：你可以交换两个下标所对应的括号次数。返回使变成所需要的交换次数。,字符串是一个空字符串，或者字符串可以记作，其中和都是平衡字符串，或者字符串可以写成[C]，其中是一个平衡字符串n==s.length2<=n<=10为偶数s[i]'['或']'开括号'['的数目为n/2，闭括号']'的数目也是n/2,1,4
1586,126,3,144,题库,1,1,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,你打算构建一些障碍赛跑路线。给你一个的整数数组，数组长度为，其中表示第个障碍的高度。对于每个介于和之间（包含和）的下标，在满足下述条件的前提下，请你找出能构成的最长障碍路线的长度：返回长度为的答案数组，其中是上面所述的下标对应的最长障碍赛跑路线的长度。,你可以选择下标介于到之间（包含和）的任意个障碍。在这条路线中，必须包含第个障碍。你必须按障碍在obstacles中的出现顺序布置这些障碍。除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍或者n==obstacles.length1<=n<=101<=obstacles[i]<=10,1,3
1587,73,1,22,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表:表:写出一个查询语句，找到所有的雇员id。当满足下面一个条件时，就被认为是雇员的信息丢失：返回这些雇员的id，。查询结果格式如下面的例子所示。,雇员的丢失了，或者雇员的薪水信息丢失了，或者,1,1
1588,56,3,93,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组和一个字符串，统计中有多少个字符串是的子字符串。返回字符串数目。是字符串中的一个连续字符序列。,1<=patterns.length<=1001<=patterns[i].length<=1001<=word.length<=100patterns[i]和word由小写英文字母组成,1,1
1589,109,2,32,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的数组，数组由若干整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都其两侧相邻元素的。更公式化的说法是，重新排列的数组应当满足这一属性：对于范围中的每个，均成立。返回满足题意的任一重排结果。,3<=nums.length<=100<=nums[i]<=10,1,3
1590,120,3,58,题库,0,2,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数。你有一个下标从开始的数组，这个数组包含范围内所有整数的二进制形式（两端都）。你可以进行以下操作次：比方说，如果且，交换右边数起第位后，我们得到和。请你算出进行以上操作以后，能得到的乘积。将乘积对后返回。答案应为取余的最小值。,nums中选择两个元素和。选择中的一位与对应位置的位交换。对应位置指的是两个整数相同位置的二进制位。1<=p<=60,1,3
1591,227,3,88,题库,2,3,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的二进制矩阵，其中表示陆地，表示水域。同时给你和分别表示矩阵中行和列的数目。一开始在第天，矩阵都是。但每一天都会有一块新陆地被淹没变成水域。给你一个下标从开始的二维数组，其中表示在第天，第行列（下标都是从开始）的陆地会变成（也就是变成）。你想知道从矩阵最一行走到最一行，且只经过陆地格子的是哪一天。你可以从最上面一行的格子出发，到达最下面一行的格子。你只能沿着基本方向移动（也就是上下左右）。请返回只经过陆地格子能从最一行走到最一行的。,"2<=row,col<=2*104<=row*col<=2*10cells.length==row*col1<=r<=row1<=c<=colcells中的所有格子坐标都是的。",1,6
1592,132,2,106,题库,0,2,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有一个具有个顶点的图，其中每个顶点标记从到（包含和）。图中的边用一个二维整数数组表示，其中表示顶点和顶点之间的双向边。每个顶点对由边连接，并且没有顶点存在与自身相连的边。请你确定是否存在从顶点开始，到顶点结束的。给你数组和整数、和，如果从到存在，则返回，否则返回。,"1<=n<=2*100<=edges.length<=2*10edges[i].length==20<=u,v<=n-1!=v0<=source,destination<=n-1不存在重复边不存在指向顶点自身的边",1,4
1593,97,3,61,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有一个特殊打字机，它由一个和一个组成，圆盘上标有小写英文字母到。当指针指向某个字母时，它才能被键入。指针指向字符。每一秒钟，你可以执行以下操作之一：给你一个字符串，请你返回键入所表示单词的秒数。,将指针顺时针或者逆时针移动一个字符。键入指针指向的字符。1<=word.length<=100word只包含小写英文字母。,1,2
1594,67,2,83,题库,2,1,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,MEDIUM,给你一个的整数方阵。你可以执行以下操作：如果两个元素有，那么它们就是的。你的目的是方阵元素的和。请你在执行以上操作之后，返回方阵的和。,选择matrix中两个元素，并将它们都n==matrix.length==matrix[i].length2<=n<=250-10<=matrix[i][j]<=10,1,3
1595,163,2,115,题库,0,1,3,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你在一个城市里，城市由个路口组成，路口编号为到，某些路口之间有道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。给你一个整数和二维整数数组，其中表示在路口和之间有一条需要花费时间才能通过的道路。你想知道花费从路口出发到达路口的方案数。请返回花费到达目的地的。由于答案可能很大，将结果对后返回。,"1<=n<=200n-1<=roads.length<=n*(n-1)/2roads[i].length==30<=u,v<=n-11<=time<=10!=v任意两个路口之间至多有一条路。从任意路口出发，你能够到达其他任意路口。",1,4
1596,95,4,34,题库,1,1,0,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,你写下了若干，并将它们连接成了一个字符串。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是的且任何数字有前导0。请你返回有多少种可能的可以得到字符串。由于答案可能很大，将结果对后返回。,1<=num.length<=3500num只含有数字'0'到'9',1,3
1597,108,1,0,题库,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表:查找这些员工的id，他们的薪水严格少于并且他们的上级经理已离职。当一个经理离开公司时，他们的信息需要从员工表中删除掉，但是表中的员工的这一列还是设置的离职经理的id。返回的结果按照从小到大排序。查询结果如下所示：,,0,1
1598,43,3,36,题库,1,0,0,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，返回数组中最大数和最小数的。两个数的是能够被两个数整除的最大正整数。,2<=nums.length<=10001<=nums[i]<=1000,1,3
1599,74,3,68,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串数组，该数组由个的二进制字符串组成，且每个字符串长度都是。请你找出并返回一个长度为且在中的二进制字符串如果存在多种答案，只需返回即可。,n==nums.length1<=n<=16nums[i].length==nnums[i]'0'或'1'nums中的所有字符串互不相同,1,3
1600,62,3,69,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的整数矩阵和一个整数。从矩阵的中选择一个整数，你的目标是所有选中元素之与目标值的。返回。和两数字的是的绝对值。,"m==mat.lengthn==mat[i].length1<=m,n<=701<=mat[i][j]<=701<=target<=800",1,3
1601,188,3,38,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,存在一个未知数组需要你进行还原，给你一个整数表示该数组的长度。另给你一个数组，由未知数组中全部个组成（子集中的元素没有特定的顺序）。返回一个长度为的数组表示还原得到的未知数组。如果存在答案，只需返回其中。如果可以由数组删除部分元素（也可能不删除或全删除）得到数组，那么数组就是数组的一个。的元素之和就是的一个。一个空数组的元素之和为。生成的测试用例将保证至少存在一个正确答案。,1<=n<=15sums.length==2-10<=sums[i]<=10,1,2
1602,62,2,37,题库,2,0,0,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的整数数组，其中表示第名学生的分数。另给你一个整数。从数组中选出任意名学生的分数，使这个分数间和的达到。返回可能的。,1<=k<=nums.length<=10000<=nums[i]<=10,1,3
1603,101,3,70,题库,3,2,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个字符串数组和一个整数。中的每个字符串都表示一个不含前导零的整数。返回中表示第大整数的字符串。重复的数字在统计时会视为不同元素考虑。例如，如果是，那么是最大的整数，是第二大的整数，是第三大的整数。,1<=k<=nums.length<=101<=nums[i].length<=100nums[i]仅由数字组成nums[i]不含任何前导零,1,6
1604,120,3,132,题库,1,2,0,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你被安排了个任务。任务需要花费的时间用长度为的整数数组表示，第个任务需要花费小时完成。一个中，你可以连续工作个小时，然后休息一会儿。你需要按照如下条件完成给定任务：给你和，请你按照上述要求，返回完成所有任务所需要的数目的。测试数据保证中的。,如果你在某一个时间段开始一个任务，你需要在同一个时间段完成它。完成一个任务后，你可以开始一个新的任务。你可以按任意顺序完成任务。n==tasks.length1<=n<=141<=tasks[i]<=10max(tasks[i])<=sessionTime<=15,1,5
1605,121,3,127,题库,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,给你一个二进制字符串。的一个如果是的且没有（除非数字是本身），那么它就是一个的子序列。请你找到的数目。请你返回中的数目。由于答案可能很大，请将它对后返回。一个指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。,"比方说，如果binary=""001""，那么所有子序列为[""0"",""0"",""1""]，所以的好子序列为""0""和""1""。注意，子序列""00""""01""和""001""不是好的，因为它们有前导0。1<=binary.length<=10binary只含有'0'和'1'",1,2
1606,130,4,39,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组，请你找到的中间位置（也就是所有可能中间位置下标最小的一个）。中间位置是满足的数组下标。如果，左边部分的和定义为。类似的，如果，右边部分的和定义为。请你返回满足上述条件的，如果不存在这样的中间位置，请你返回。本题与主站724题相同：,1<=nums.length<=100-1000<=nums[i]<=1000,1,2
1607,282,3,59,题库,2,2,0,0,0,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始，大小为的二进制矩阵，其中表示一单位的森林土地，表示一单位的农场土地。为了让农场保持有序，农场土地之间以矩形的的形式存在。每一个农场组都包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都与另一个农场组的任何一块土地在四个方向上相邻。可以用坐标系统表示，其中左上角坐标为，右下角坐标为。请你找到所有最左上角和最右下角的坐标。一个左上角坐标为且右下角坐标为的用长度为4的数组表示。请你返回一个二维数组，它包含若干个长度为4的子数组，每个子数组表示中的一个。如果没有任何农场组，请你返回一个空数组。可以以返回所有农场组。,"m==land.lengthn==land[i].length1<=m,n<=300land只包含和农场组都是的形状。",1,4
1608,111,1,633,题库,0,2,2,0,0,0,1,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一棵个节点的树，编号从到，以父节点数组的形式给出，其中是第个节点的父节点。树的根节点为号节点，所以，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。数据结构需要支持如下函数：请你实现类：,"Lock：指定用户给指定节点，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。Unlock：指定用户给指定节点，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。Upgrade：指定用户给指定节点，并且将该节点的所有子孙节点。只有如下3个条件指定节点当前状态为未上锁。指定节点至少有一个上锁状态的子孙节点（可以是用户上锁的）。指定节点没有任何上锁的祖先节点。LockingTree(int[]parent)用父节点数组初始化数据结构。lock(intnum,intuser)如果id为user的用户可以给节点num上锁，那么返回true，否则返回false。如果可以执行此操作，节点num会被id为user的用户unlock(intnum,intuser)如果id为user的用户可以给节点num解锁，那么返回true，否则返回false。如果可以执行此操作，节点num变为未上锁状态。upgrade(intnum,intuser)如果id为user的用户可以给节点num升级，那么返回true，否则返回false。如果可以执行此操作，节点num会被升级n==parent.length2<=n<=2000对于i!=0，满足0<=parent[i]<=n-1parent[0]==-10<=num<=n-11<=user<=10parent表示一棵合法的树。lockunlock和upgrade的调用总共不超过2000次。",1,5
1609,134,2,125,题库,1,1,0,0,2,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组。如果的一个子集中，所有元素的乘积可以表示为一个或多个的乘积，那么我们称它为。请你返回中不同的子集的数目对的结果。中的是通过删除中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。,"比方说，如果nums=[1,2,3,4][2,3][1,2,3]和[1,3]是子集，乘积分别为6=2*36=2*3和3=3[1,4]和[4]不是子集，因为乘积分别为4=2*2和4=2*21<=nums.length<=101<=nums[i]<=30",1,5
1610,24,3,74,题库,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的整数数组，返回满足下述条件的四元组的：,nums[a]+nums[b]+nums[c]==nums[d]，且a<b<c<d4<=nums.length<=501<=nums[i]<=100,1,2
1611,122,3,68,题库,2,1,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在参加一个多角色游戏，每个角色都有两个主要属性：和。给你一个二维整数数组，其中表示游戏中第个角色的属性。如果存在一个其他角色的攻击和防御等级该角色的攻击和防御等级，则认为该角色为。更正式地，如果认为角色存在的另一个角色，那么且。返回的数量。,"2<=properties.length<=10properties[i].length==21<=attack,defense<=10",1,5
1612,159,3,166,题库,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你需要访问个房间，房间从到编号。同时，每一天都有一个日期编号，从开始，依天数递增。你每天都会访问一个房间。最开始的第天，你访问号房间。给你一个长度为且的数组。在接下来的几天中，你访问房间的将根据下面的决定：请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对取余后的结果。,假设某一天，你访问号房间。如果算上本次访问，访问号房间的次数为，那么第二天需要访问nextVisit[i]所指定的房间，其中0<=nextVisit[i]<=i如果算上本次访问，访问号房间的次数为，那么第二天需要访问(i+1)modn号房间。n==nextVisit.length2<=n<=100<=nextVisit[i]<=i,1,2
1613,46,3,125,题库,2,0,0,1,0,2,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组，你可以在上执行下述操作：如果能使用上述交换方式将按排列，返回；否则，返回。,"如果gcd(nums[i],nums[j])>1，交换nums[i]和nums[j]的位置。其中gcd(nums[i],nums[j])是nums[i]和nums[j]的最大公因数。1<=nums.length<=3*102<=nums[i]<=10",1,5
1614,76,3,108,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串和一个字符。找出第一次出现的下标，中从下标开始、直到下标结束（含下标）的那段字符。如果中不存在字符，则无需进行任何操作。返回。,"例如，如果word=""abcdefd""且ch=""d""，那么你应该从下标0开始、直到下标结束（含下标）。结果字符串将会是dcbaefd""1<=word.length<=250word由小写英文字母组成是一个小写英文字母",1,2
1615,113,2,70,题库,1,0,1,0,1,2,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,用一个下标从开始的二维整数数组来表示个矩形，其中表示第个矩形的宽度和高度。如果两个矩形和（）的宽高比相同，则认为这两个矩形。更规范的说法是，两个矩形满足（使用实数除法而非整数除法），则认为这两个矩形。计算并返回中有多少对矩形。,"n==rectangles.length1<=n<=10rectangles[i].length==21<=width,height<=10",1,5
1616,152,3,25,题库,1,2,0,0,2,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，请你找到中两个，使得它们长度的。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是的。请你返回两个回文子序列长度可以达到的。指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个。,2<=s.length<=12只含有小写英文字母。,1,5
1617,159,3,121,题库,0,2,1,1,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一棵根节点为的，总共包含个节点，节点编号为到。给你一个下标从开始的整数数组，其中是节点的父节点。由于节点是，所以。总共有个基因值，每个基因值都用中的一个整数表示。给你一个下标从开始的整数数组，其中是节点的基因值，且基因值。请你返回一个数组，长度为，其中是以节点为根的子树内的基因值。节点为根的包含节点和它所有的节点。,n==parents.length==nums.length2<=n<=10对于i!=0，满足0<=parents[i]<=n-1parents[0]==-1parents表示一棵合法的树。1<=nums[i]<=10nums[i]互不相同。,1,4
1618,34,3,63,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组和一个整数，请你返回数对的数目，满足且。的值定义为：,如果x>=0，那么值为如果x<0，那么值为1<=nums.length<=2001<=nums[i]<=1001<=k<=99,1,3
1619,83,3,38,题库,2,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个整数数组可以转变成一个数组，转变方式为将中每个元素加入数组中，然后将所有元素。给你一个数组，如果是数组，那么请你返回数组，否则请返回空数组。的元素可以以顺序返回。,1<=changed.length<=100<=changed[i]<=10,1,4
1620,196,2,72,题库,2,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你驾驶出租车行驶在一条有个地点的路上。这个地点从近到远编号为到，你想要从开到，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。乘客信息用一个下标从开始的二维数组表示，其中表示第位乘客需要从地点前往，愿意支付元的小费。你选择接单的乘客，你可以元。你同时只能接一个订单。给你和，请你返回在最优接单方案下，你能盈利多少元。你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。,1<=n<=101<=rides.length<=3*10rides[i].length==31<=start<end<=n1<=tip<=10,1,4
1621,65,3,76,题库,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组。每一次操作中，你可以将中一个元素替换成整数。如果满足以下条件，那么它是：比方说，是，但是。请你返回使的操作次数。,nums中所有元素都是互不相同的。nums中元素与元素的差等于nums.length-11<=nums.length<=101<=nums[i]<=10,1,2
1622,63,3,86,题库,3,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,存在一种仅支持4种操作和1个变量的编程语言：最初，的值是给你一个字符串数组，这是由操作组成的一个列表，返回执行所有操作后，的。,"++X和X++使变量的值--X和X--使变量的值1<=operations.length<=100operations[i]将会是""++X""""X++""""--X""或""X--""",1,3
1623,37,3,142,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。对于每个下标（），的等于：返回符合的所有的。,，对于所有0<=j<i且i<k<=nums.length-1，满足nums[j]<nums[i]<nums[k]，如果满足nums[i-1]<nums[i]<nums[i+1]，且不满足前面的条件，如果上述条件全部不满足3<=nums.length<=101<=nums[i]<=10,1,1
1624,76,1,269,题库,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个在X-Y平面上的点构成的数据流。设计一个满足下述要求的算法：是一个正方形，除四条边长度相同外，还满足每条边都与x-轴或y-轴平行或垂直。实现类：,"一个在数据流中的新点到某个数据结构中可以添加的点，并会视作不同的点进行处理。给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个面积为正的轴对齐正方形满足该要求的方案数目DetectSquares()使用空数据结构初始化对象voidadd(int[]point)向数据结构添加一个新的点point=[x,y]intcount(int[]point)统计按上述方式与点point=[x,y]共同构造轴对齐正方形的方案数。point.length==20<=x,y<=1000调用add和count的总次数最多为5000",1,4
1625,149,3,124,题库,2,2,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的字符串，和一个整数。请你找出字符串中次的。是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。如果是的一个子序列，其中表示一个由串联次构造的字符串，那么就称是字符串中一个的子序列。返回字符串中。如果存在多个满足的子序列，则返回的那个。如果不存在这样的子序列，返回一个字符串。,"举个例子，""bba""是字符串""bababcba""中的一个重复次的子序列，因为字符串""bbabba""是由""bba""串联次构造的，而""bbabba""是字符串bab的一个子序列。n==s.length2<=k<=20002<=n<k*8由小写英文字母组成",1,5
1626,54,3,38,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个下标从开始的整数数组，该数组的大小为，请你计算能求得的，其中且。返回。如果不存在满足要求的和，返回。,n==nums.length2<=n<=10001<=nums[i]<=10,1,1
1627,248,3,58,题库,2,0,0,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的二维数组，数组大小为，其中表示矩阵中位置上的点数。现在有两个机器人正在矩阵上参与一场游戏。两个机器人初始位置都是，目标位置是。每个机器人只会(到)或(到)。游戏开始，机器人从移动到，并收集路径上单元格的全部点数。对于路径上所有单元格，途经后会重置为。然后，机器人从移动到，同样收集路径上单元的全部点数。注意，它们的路径可能会存在相交的部分。机器人想要打击竞争对手，使机器人收集到的点数。与此相对，机器人想要自己收集到的点数。两个机器人都发挥出自己的的前提下，返回机器人收集到的,grid.length==2n==grid[r].length1<=n<=5*101<=grid[r][c]<=10,1,3
1628,127,3,229,题库,3,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的矩阵，它代表一个填字游戏的状态。填字游戏格子中包含小写英文字母（已填入的单词），表示格的和表示格子的。如果满足以下条件，那么我们可以（从左到右从右到左）或（从上到下从下到上）填入一个单词：给你一个字符串，如果可以被放入中，请你返回，否则请返回。,"该单词不占据任何'#'对应的格子。每个字母对应的格子要么是''（空格）要么与board中已有字母如果单词是放置的，那么该单词左边和右边格子不能为''或小写英文字母。如果单词是放置的，那么该单词上边和下边格子不能为''或小写英文字母。m==board.lengthn==board[i].length1<=m*n<=2*10board[i][j]可能为'''#'或者一个小写英文字母。1<=word.length<=max(m,n)word只包含小写英文字母。",1,3
1629,126,3,238,题库,2,2,1,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，它包含数字，加法运算符和乘法运算符，这个字符串表示一个的只含有的数学表达式（比方说）。有位小学生将计算这个数学表达式，并遵循如下：给你一个长度为的整数数组，表示每位学生提交的答案。你的任务是给数组按照如下打分：请你返回所有学生的分数和。,"如果一位学生的答案表达式的正确结果，这位学生将得到分。否则，如果答案由一处或多处错误的运算顺序计算得到，那么这位学生能得到分。否则，这位学生将得到分。3<=s.length<=31表示一个只包含0-9'+'和'*'的合法表达式。表达式中所有整数运算数字都在闭区间[0,9]以内。1<=数学表达式中所有运算符数目（'+'和'*'<=15测试数据保证正确表达式结果在范围[0,1000]以内。n==answers.length1<=n<=100<=answers[i]<=1000",1,6
1630,136,4,54,题库,3,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的一维整数数组和两个整数和。你需要使用中元素创建一个行列的二维数组。中下标从到（都）的元素构成二维数组的第一行，下标从到（都）的元素构成二维数组的第二行，依此类推。请你根据上述过程返回一个的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。,"1<=original.length<=5*101<=original[i]<=101<=m,n<=4*10",1,3
1631,45,3,105,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个字符串数组和一个字符串，请你返回（两个字符串连接）结果等于的下标（需满足）的数目。,2<=nums.length<=1001<=nums[i].length<=1002<=target.length<=100nums[i]和target只包含数字。nums[i]和target不含有任何前导0。,1,2
1632,178,3,114,题库,1,1,0,0,2,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,一位老师正在出一场由道判断题构成的考试，每道题的答案为true（用表示）或者false（用表示）。老师想增加学生对自己做出答案的不确定性，方法是有结果的题数。（也就是连续出现true或者连续出现false）。给你一个字符串，其中是第个问题的正确结果。除此以外，还给你一个整数，表示你能进行以下操作的最多次数：请你返回在不超过次操作的情况下，连续或者的数目。,每次操作中，将问题的正确答案改为'T'或者'F'（也就是将answerKey[i]改为'T'或者'F'）。n==answerKey.length1<=n<=5*10answerKey[i]要么是'T'，要么是'F'1<=k<=n,1,4
1633,96,3,124,题库,2,0,1,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始且长度为的整数数组。数组的方案数定义为符合以下两个条件的数目：同时给你一个整数。你可以将中元素变为或数组。请你返回在改变一个元素的前提下，有多少种方法使得上述两个条件都满足。,"1<=pivot<nnums[0]+nums[1]+...+nums[pivot-1]==nums[pivot]+nums[pivot+1]+...+nums[n-1]n==nums.length2<=n<=10-10<=k,nums[i]<=10",1,5
1634,86,3,29,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，由个字符组成，每个字符不是就是。一次定义为从中选出并将选中的每个字符都转换为。注意，如果字符已经是，只需要保持。返回将中所有字符均转换为需要执行的操作次数。,3<=s.length<=1000s[i]为'X'或'O',1,2
1635,219,4,44,题库,2,0,0,0,0,1,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现有一份次投掷单个骰子的观测数据，骰子的每个面从到编号。观测数据中缺失了份，你手上只拿到剩余次投掷的数据。幸好你有之前计算过的这次投掷数据的。给你一个长度为的整数数组，其中是第次观测的值。同时给你两个整数和。返回一个长度为的数组，包含所有缺失的观测数据，且满足这次投掷的是。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。个数字的为这些数字求和后再除以。注意是一个整数，所以次投掷的总和需要被整除。,"m==rolls.length1<=n,m<=101<=rolls[i],mean<=6",1,3
1636,148,3,124,题库,1,1,0,0,1,2,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Alice和Bob再次设计了一款新的石子游戏。现有一行n个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组，其中是第个石子的价值。Alice和Bob轮流进行自己的回合，先手。每一回合，玩家需要从中移除任一石子。假设两位玩家均采用决策。如果Alice获胜，返回；如果Bob获胜，返回。,如果玩家移除石子后，导致所有已移除石子的价值可以被3整除，那么该玩家就输掉游戏如果不满足上一条，且移除后没有任何剩余的石子，那么Bob将会直接获胜（即便是在Alice的回合）。1<=stones.length<=101<=stones[i]<=10,1,5
1637,159,3,73,题库,1,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，一个整数，一个字母以及另一个整数。返回中长度为且的子序列，该子序列同时应满足字母出现次。生成的测试用例满足在中出现次。是由原字符串删除一些（或不删除）字符且不改变剩余字符顺序得到的剩余字符串。字符串字典序比字符串小的定义为：在和出现不同字符的第一个位置上，字符串的字符在字母表中的顺序早于字符串的字符。,1<=repetition<=k<=s.length<=5*10由小写英文字母组成letter是一个小写英文字母，在中至少出现repetition,1,4
1638,53,3,80,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你三个整数数组、和，请你构造并返回一个数组，且由在数组中出现的所有值组成数组中的元素可以按顺序排列。
","1<=nums1.length,nums2.length,nums3.length<=1001<=nums1[i],nums2[j],nums3[k]<=100",1,2
1639,76,3,70,题库,3,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的二维整数网格和一个整数。每一次操作，你可以对中的任一元素或。是全部元素都相等的网格。返回使网格化为单值网格所需的操作数。如果不能，返回。,"m==grid.lengthn==grid[i].length1<=m,n<=101<=m*n<=101<=x,grid[i][j]<=10",1,4
1640,156,1,348,题库,0,0,3,0,0,0,2,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一支股票价格的数据流。数据流中每一条记录包含一个和该时间点股票对应的。不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录前一条错误的记录。请你设计一个算法，实现：请你实现类：,"更新股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将之前的错误价格。找到当前记录里最新股票价格最新股票价格定义为时间戳最晚的股票价格。找到当前记录里股票的最高价格找到当前记录里股票的最低价格StockPrice()初始化对象，当前无股票价格记录。voidupdate(inttimestamp,intprice)在时间点timestamp更新股票价格为priceintcurrent()返回股票最新价格intmaximum()返回股票最高价格intminimum()返回股票最低价格1<=timestamp,price<=10updatecurrentmaximum和minimum调用次数不超过currentmaximum和minimum被调用时，update操作已经被调用过",1,5
1641,73,3,40,题库,1,2,1,0,3,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的整数数组。你需要将分成长度为的数组，分别求出两个数组的和，并两个数组和之。中每个元素都需要放入两个数组之一。请你返回的数组和之差。,1<=n<=15nums.length==2*n-10<=nums[i]<=10,1,7
1642,139,3,112,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个房间里有个座位和名学生，房间用一个数轴表示。给你一个长度为的数组，其中是第个座位的位置。同时给你一个长度为的数组，其中是第位学生的位置。你可以执行以下操作任意次：请你返回使所有学生都有座位坐的，并确保没有两位学生的座位相同。请注意，初始时有可能有多个座位或者多位学生在位置。,"增加或者减少第位学生的位置，每次变化量为（也就是将第位学生从位置移动到x+1或者x-1n==seats.length==students.length1<=n<=1001<=seats[i],students[j]<=100",1,2
1643,132,3,209,题库,1,1,0,0,0,2,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,总共有个颜色片段排成一列，每个颜色片段要么是要么是。给你一个长度为的字符串，其中表示第个颜色片段的颜色。Alice和Bob在玩一个游戏，他们从这个字符串中删除颜色。Alice。假设Alice和Bob都采用最优策略，如果Alice获胜，请返回，否则Bob获胜，返回。,如果一个颜色片段为'A'且相邻两个颜色都是颜色'A'，那么Alice可以删除该颜色片段。Alice不可以删除任何颜色'B'片段。如果一个颜色片段为'B'且相邻两个颜色都是颜色'B'，那么Bob可以删除该颜色片段。Bob不可以删除任何颜色'A'片段。Alice和Bob从字符串两端删除颜色片段。如果其中一人无法继续操作，则该玩家掉游戏且另一玩家1<=colors.length<=10colors只包含字母'A'和'B',1,4
1644,386,2,277,题库,1,1,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个有个服务器的计算机网络，服务器编号为到。同时给你一个二维整数数组，其中表示服务器和之间有一条信息线路，在内它们之间可以传输数目的信息。再给你一个长度为且下标从开始的整数数组。题目保证所有服务器都是的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。编号为的服务器是服务器，其他服务器为服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按线路传输，也就是说每个信息都会以到达主服务器。主服务器会处理新到达的信息并按照每条信息来时的路线发送回复信息。在秒的开始，所有数据服务器都会发送各自需要处理的信息。从第秒开始，一秒最时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为状态。请返回计算机网络变为状态的。,"如果还没收到任何回复信息，那么该服务器会周期性信息。数据服务器每patience[i]秒都会重发一条信息，也就是说，数据服务器在上一次发送信息给主服务器后的patience[i]秒会重发一条信息给主服务器。否则，该数据服务器不会重发信息。n==patience.length2<=n<=10patience[0]==0对于1<=i<n，满足1<=patience[i]<=101<=edges.length<=min(10,n*(n-1)/2)edges[i].length==20<=u,v<n!=v不会有重边。每个服务器都直接或间接与别的服务器相连。",1,3
1645,47,3,113,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给你两个且下标从开始的整数数组和以及一个整数，请你返回第（从开始编号）小的的乘积，其中且。
","1<=nums1.length,nums2.length<=5*10-10<=nums1[i],nums2[j]<=101<=k<=nums1.length*nums2.lengthnums1和nums2都是从小到大排好序的。",1,2
1646,151,4,190,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,句子是由若干组成的一个列表，间用空格分隔，句子没有前导或尾随空格。每个token要么是一个由数字组成的不含前导零的，要么是一个由小写英文字母组成的。给你一个表示句子的字符串，你需要检查中的数字是否从左到右严格递增（即，除了最后一个数字，中的数字都严格小于它的数字）。如果满足题目要求，返回，否则，返回。,"示例，""apuppyhas2eyes4legs""是一个由7个token组成的句子：""2""和""4""是数字，其他像""puppy""这样的tokens属于单词。3<=s.length<=200由小写英文字母、空格和数字到组成（包含和中数字token的数目在和100之间（包含和100中的token之间由单个空格分隔中至少有数字中的每个数字都是一个100的数，且不含前导零不含前导或尾随空格",1,1
1647,126,1,471,题库,2,0,1,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有个账户，编号从到。每个账号的初始余额存储在一个下标从开始的整数数组中，其中第个账户的初始余额是。请你执行所有交易。如果满足下面全部条件，则交易：实现类：,"指定的账户数量在和之间，且取款或者转账需要的钱的总数小于或者等于账户余额。Bank(long[]balance)使用下标从开始的整数数组balance初始化该对象。booleantransfer(intaccount1,intaccount2,longmoney)从编号为account1的账户向编号为account2的账户转帐money美元。如果交易成功，返回true，否则，返回falsebooleandeposit(intaccount,longmoney)向编号为account的账户存款money美元。如果交易成功，返回true；否则，返回falsebooleanwithdraw(intaccount,longmoney)从编号为account的账户取款money美元。如果交易成功，返回true；否则，返回falsen==balance.length1<=n,account,account1,account2<=100<=balance[i],money<=10transferdepositwithdraw三个函数，最多调用",1,4
1648,112,3,32,题库,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个整数数组，请你找出子集可能得到的，并返回按位或能得到最大值的。如果数组可以由数组删除一些元素（或不删除）得到，则认为数组是数组的一个。如果选中的元素下标位置不一样，则认为两个子集。对数组执行，结果等于（下标从开始）。,1<=nums.length<=161<=nums[i]<=10,1,3
1649,230,2,185,题库,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,城市用一个图表示，图中有个节点，从到编号（包含和）。图中的边用一个二维整数数组表示，其中每个表示一条节点和节点之间的双向连通边。每组节点对由边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是分钟。每个节点都有一个交通信号灯，每分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都改变。你可以在进入某个节点，但是在节点才能离开。如果信号灯是，你在节点等待，必须离开。是最小值的所有值中最小的值。给你、、和，返回从节点到节点需要的。    ,"例如，[2,3,4]中第二小的值是，而[2,2,4]中第二小的值是你可以任意次穿过任意顶点，和你可以假设在启程时，所有信号灯刚刚变成2<=n<=10n-1<=edges.length<=min(2*10,n*(n-1)/2)edges[i].length==21<=u,v<=n!=v不含重复边每个节点都可以从其他节点直接或者间接到达1<=time,change<=10",1,3
1650,148,3,199,题库,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,句子仅由小写字母（到）、数字（到）、连字符（）、标点符号（、和）以及空格（）组成。每个句子可以根据空格分解成，这些token之间由一个或者多个空格分隔。如果一个token同时满足下述条件，则认为这个token是一个有效单词：这里给出几个有效单词的例子：、、、和。给你一个字符串，请你找出并返回中。,"仅由小写字母、连字符和/或标点（不含数字）组成。至多一个连字符'-'。如果存在，连字符两侧应当都存在小写字母（""a-b""是一个有效单词，但""-ab""和""ab-""不是有效单词）。至多一个标点符号。如果存在，标点符号应当位于token的1<=sentence.length<=1000sentence由小写英文字母、数字（0-9）、以及字符（'''-''!''.'和','）组成句子中至少有个token",1,1
1651,46,3,8,题库,1,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果整数满足：对于每个数位，这个数位在中出现次。那么整数就是一个。给你一个整数，请你返回的。,0<=n<=10,1,3
1652,159,2,80,题库,1,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一棵根节点为的，它总共有个节点，节点编号为到。同时给你一个下标从开始的整数数组表示这棵树，其中是节点的父节点。由于节点是根，所以。一个子树的为这个子树内节点的数目。每个节点都有一个与之关联的。求出某个节点分数的方法是，将这个节点和与它相连的边全部，剩余部分是若干个子树，这个节点的为所有这些子树。请你返回有节点的。,n==parents.length2<=n<=10parents[0]==-1对于i!=0，有0<=parents[i]<=n-1parents表示一棵二叉树。,1,4
1653,169,2,239,题库,1,1,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，表示有节课，课程编号从到。同时给你一个二维整数数组，其中，表示课程必须在课程完成（先修课的关系）。同时给你一个下标从开始的整数数组，其中表示完成第门课程需要花费的数。请你根据以下规则算出完成所有课程所需要的月份数：请你返回完成所有课程所需要的月份数。测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。,"如果一门课的所有先修课都已经完成，你可以在时间开始这门课程。你可以上任意门课程1<=n<=5*100<=relations.length<=min(n*(n-1)/2,5*10relations[j].length==21<=prevCourse,nextCourse<=nprevCourse!=nextCourse所有的先修课程对[prevCourse,nextCourse都是互不相同的。time.length==n1<=time[i]<=10先修课程图是一个有向无环图。",1,4
1654,84,3,57,题库,2,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,指的是在一个数组中只出现过的字符串。给你一个字符串数组和一个整数，请你返回中第个。如果个独一无二的字符串，那么返回。注意，按照字符串在原数组中的找到第个独一无二字符串。,1<=k<=arr.length<=10001<=arr[i].length<=5arr[i]只包含小写英文字母。,1,4
1655,182,3,76,题库,2,2,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的二维整数数组，其中。第个活动开始于，结束于，如果你参加这个活动，那么你可以得到价值。你可以参加活动，使得它们的价值之和。请你返回价值之和的。注意，活动的开始时间和结束时间是在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为，那么下一个活动必须在或之后的时间开始。,2<=events.length<=10events[i].length==31<=startTime<=endTime<=101<=value<=10,1,5
1656,151,2,177,题库,2,1,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从开始的字符串，它只包含字符和，其中表示一个，表示一支。同时给你一个下标从开始的二维整数数组，其中表示（）。对于每个查询，你需要找到在的盘子的。如果一个盘子在左边和右边至少有一支蜡烛，那么这个盘子满足在。请你返回一个整数数组，其中是第个查询的答案。,"比方说，s=""||**||**|*""，查询[3,8]，表示的是子字符串""*||。子字符串中在两支蜡烛之间的盘子数目为，子字符串中右边两个盘子在它们左边和右边至少有一支蜡烛。3<=s.length<=10只包含字符'*'和'|'1<=queries.length<=10queries[i].length==20<=left<=right<s.length",1,4
1657,280,5,394,题库,3,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一个的棋盘，它包含个棋子（棋子包括车，后和象三种）。给你一个长度为的字符串数组，其中表示第个棋子的类型（车，后或象）。除此以外，还给你一个长度为的二维整数数组，其中表示第个棋子现在在棋盘上的位置为，棋盘下标从开始。棋盘上每个棋子都可以移动。每个棋子的移动中，首先选择移动的，然后选择，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：包含所有棋子的。每一秒，每个棋子都沿着它们选择的方向往前移动，直到它们到达目标位置。所有棋子从时刻开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合。请你返回移动组合的数目。,"车可以水平或者竖直从(r,c)沿着方向(r+1,c)(r-1,c)(r,c+1)或者(r,c-1)移动。后可以水平竖直或者斜对角从(r,c)沿着方向(r+1,c)(r-1,c)(r,c+1)(r,c-1)(r+1,c+1)(r+1,c-1)(r-1,c+1)(r-1,c-1)移动。象可以斜对角从(r,c)沿着方向(r+1,c+1)(r+1,c-1)(r-1,c+1)(r-1,c-1)移动。初始时，不会有两个棋子在同一个位置。有可能在一个移动组合中，有棋子不移动。如果两个棋子直接相邻且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内交换位置n==pieces.lengthn==positions.length1<=n<=4pieces只包含字符串""rook""""queen""和""bishop""棋盘上总共最多只有一个后。1<=x,y<=8每一个positions[i]互不相同。",1,4
1658,47,4,32,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从0开始的整数数组，返回中满足的最小下标；如果不存在这样的下标，返回。表示除以的。,1<=nums.length<=1000<=nums[i]<=9,1,1
1659,177,4,31,题库,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,链表中的定义为一个如果当前节点的值前一个节点和后一个节点，那么这个节点就是一个。如果当前节点的值前一个节点和后一个节点，那么这个节点就是一个。注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个。给你一个链表，返回一个长度为2的数组，其中是任意两个不同临界点之间的最小距离，是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回。,"链表中节点的数量在范围[2,101<=Node.val<=10",1,1
1660,181,3,116,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，该数组由的数字组成。另给你两个整数和。整数的值最开始设为，你打算执行一些运算使转化为。你可以对数字重复执行下述运算：如果，那么，对于数组中的任一下标（），可以将设为下述任一值：注意，你可以按任意顺序使用每个任意次。使越过范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。返回将转化为的最小操作数；如果无法完成转化，则返回。,"x+nums[i]x-nums[i]x^nums[i]（按位异或XOR）1<=nums.length<=1000-10<=nums[i],goal<=100<=start<=1000start!=goalnums中的所有整数互不相同",1,2
1661,111,5,265,题库,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,原字符串由小写字母组成，可以按下述步骤编码：例如，编码的一种方法可以描述为：给你两个编码后的字符串和，由小写英文字母和数字组成。如果存在能够同时编码得到和原字符串，返回；否则，返回。生成的测试用例满足和中连续数字数不超过。,"任意将其为由若干子字符串组成的一个任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。重新顺次连接序列，得到编码后的字符串。将原字符串分割得到一个序列：[""ab"",""cdefghijklmn"",""o"",""p""]选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为[""ab"",""12"",""1"",""p""]重新顺次连接序列中的元素，得到编码后的字符串：""ab121p""1<=s1.length,s2.length<=40和仅由数字1-9和小写英文字母组成和中连续数字数不超过",1,2
1662,63,4,33,题库,1,0,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,是字符串中的一个连续（非空）的字符序列。是由元音（、、、和）组成的一个子字符串，且必须包含元音。给你一个字符串，统计并返回中。,1<=word.length<=100word仅由小写英文字母组成,1,2
1663,82,4,31,题库,1,1,0,0,0,2,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，返回的所有子字符串中，元音是指、和是字符串中一个连续（非空）的字符序列。由于对长度的限制比较宽松，答案可能超过有符号32位整数的范围。计算时需当心。,1<=word.length<=10word由小写英文字母组成,1,4
1664,89,3,159,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，表示有间零售商店。总共有种产品，每种产品的数目用一个下标从开始的整数数组表示，其中表示第种商品的数目。你需要将分配到零售商店，并遵守这些规则：请你返回最小的可能的。,一间商店只能有一种商品，但一间商店拥有的商品数目可以为件。分配后，每间商店都会被分配一定数目的商品（可能为件）。用表示所有商店中分配商品数目的最大值，你希望越小越好。也就是说，你想最小化分配给任意商店商品数目的最大值m==quantities.length1<=m<=n<=101<=quantities[i]<=10,1,2
1665,210,4,140,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一张图，图中有个节点，节点编号从到（）。同时给你一个下标从开始的整数数组，其中是第个节点的。同时给你一个下标从开始的二维整数数组，其中表示节点和之间有一条需要秒才能通过的无向边。最后，给你一个整数。指的是图中任意一条从节点开始，最终回到节点，且花费的总时间秒的一条路径。你可以访问一个节点任意次。一条合法路径的定义为路径中的价值（每个节点的价值算入价值总和中一次）。请你返回一条合法路径的价值。每个节点有边与之相连。,"n==values.length1<=n<=10000<=values[i]<=100<=edges.length<=2000edges[j].length==30<=u<v<=n-110<=time,maxTime<=100,v所有节点对互不相同每个节点至多有四条图可能不连通。",1,3
1666,87,3,60,题库,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果两个字符串和中从到每一个字母出现频率之差都，那么我们称这两个字符串和。给你两个长度都为的字符串和，如果和，请你返回，否则返回。一个字母的出现指的是它在字符串中出现的次数。,n==word1.length==word2.length1<=n<=100word1和word2都只包含小写英文字母。,1,3
1667,130,1,258,题库,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个在XY平面上的的网格图，的格子为，的格子为。网格图中相邻格子为四个基本方向之一（，，和）。一个机器人在格子，方向为。机器人可以根据指令移动指定的。每一步，它可以执行以下操作。如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。请你实现类：,"Robot(intwidth,intheight)初始化一个widthxheight的网格图，机器人初始在(0,0)，方向朝""East""voidstep(intnum)给机器人下达前进num步的指令。int[]getPos()返回机器人当前所处的格子位置，用一个长度为2的数组[x,y]表示。StringgetDir()返回当前机器人的朝向，为""North""""East""""South""或者""West""2<=width,height<=1001<=num<=10stepgetPos和getDir总共调用次数不超过次。",0,2
1668,116,3,82,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中分别表示每一个物品的和。同时给你一个下标从开始的整数数组。对于每个查询，你想求出价格小于等于的物品中，是多少。如果不存在符合条件的物品，那么查询的结果为。请你返回一个长度与相同的数组，其中是第个查询的答案。,"1<=items.length,queries.length<=10items[i].length==21<=price,beauty,queries[j]<=10",1,3
1669,209,4,90,题库,2,2,2,0,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你个任务和个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从开始的整数数组中，第个任务需要的力量才能完成。每个工人的力量值保存在下标从开始的整数数组中，第个工人的力量值为。每个工人只能完成任务，且力量值需要该任务的力量要求值（即）。除此以外，你还有个神奇药丸，可以给增加。你可以决定给哪些工人使用药丸，但每个工人只能使用药丸。给你下标从开始的整数数组和以及两个整数和，请你返回有多少个任务可以被完成。,"n==tasks.lengthm==workers.length1<=n,m<=5*100<=pills<=m0<=tasks[i],workers[j],strength<=10",1,6
1670,158,2,50,题库,2,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有个人前来排队买票，其中第人站在队伍，第人站在队伍。给你一个下标从开始的整数数组，数组长度为，其中第人想要购买的票数为。每个人买票都需要用掉。一个人，如果需要购买更多票，他必须走到重新排队（发生，不计时间）。如果一个人没有剩下需要买的票，那他将会队伍。返回位于位置（下标从开始）的人完成买票需要的时间（以秒为单位）。,n==tickets.length1<=n<=1001<=tickets[i]<=1000<=k<n,1,3
1671,108,3,61,题库,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表的头节点。链表中的节点划分成若干组，这些非空组的长度构成一个自然数序列（）。一个组的就是组中分配到的节点数目。换句话说：注意，最后一组的长度可能小于或者等于。每个长度组中的节点，并返回修改后链表的头节点。,"节点分配给第一组节点和分配给第二组节点和分配给第三组，以此类推链表中节点数目范围是[1,100<=Node.val<=10",1,1
1672,296,4,130,题库,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,字符串使用，经由为的矩阵辅助，加密得到一个字符串。先按从左上到右下的方式放置到矩阵中。先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用进行填充。矩阵的列数需满足：用填充之后，最右侧列。接着按行将字符附加到矩阵中，构造。先把蓝色单元格中的字符附加到中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。例如，如果且，那么我们可以按下述方法将其编码：蓝色箭头标识是如何放入矩阵中的，红色箭头标识形成的顺序。在上述例子中，。给你编码后的字符串和矩阵的行数，返回源字符串。含任何尾随空格。生成的测试用例满足可能的。,0<=encodedText.length<=10encodedText仅由小写英文字母和''组成encodedText是对某个尾随空格的originalText的一个有效编码1<=rows<=1000生成的测试用例满足仅存在一个可能的originalText,1,2
1673,263,3,136,题库,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，表示网络上的用户数目。每个用户按从到进行编号。给你一个下标从开始的二维整数数组，其中意味着用户和用户成为，不管是还是通过其他用户。最初，用户里没有人是其他用户的朋友。给你一个下标从开始的二维整数数组表示好友请求的列表，其中是用户和用户之间的一条好友请求。如果和可以成为，那么好友请求将会。每个好友请求都会按列表中给出的顺序进行处理（即，会在前）。一旦请求成功，那么对所有未来的好友请求而言，和将会返回一个，其中元素遵循此规则：如果第个好友请求，那么就是；否则，为。如果和已经是直接朋友，那么他们之间的请求将仍然。,"2<=n<=10000<=restrictions.length<=1000restrictions[i].length==20<=x,y<=n-1!=y1<=requests.length<=1000requests[j].length==20<=u,v<=n-1!=v",1,2
1674,96,3,64,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,街上有栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从开始且长度为的整数数组，其中表示第栋房子的颜色。返回颜色房子之间的距离。第栋房子和第栋房子之间的距离是，其中是的绝对值。,n==colors.length2<=n<=1000<=colors[i]<=100生成的测试数据满足至少存在2栋颜色不同的房子,1,2
1675,193,3,139,题库,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你打算用一个水罐给花园里的株植物浇水。植物排成一行，从左到右进行标记，编号从到。其中，第株植物的位置是。处有一条河，你可以在那里重新灌满你的水罐。每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：最初，你在河边（也就是，），在x轴上每移动都需要。给你一个下标从开始的整数数组，数组由个整数组成。其中，为第株植物需要的水量。另有一个整数表示水罐的容量，返回浇灌所有植物需要的。,按从左到右的顺序给植物浇水。在给当前植物浇完水之后，如果你没有足够的水浇灌下一株植物，那么你就需要返回河边重新装满水罐。提前重新灌满水罐。n==plants.length1<=n<=10001<=plants[i]<=10max(plants[i])<=capacity<=10,1,1
1676,95,1,184,题库,1,1,1,1,0,0,1,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你设计一个数据结构，它能求出给定子数组内一个给定值的。子数组中一个值的指的是这个子数组中这个值的出现次数。请你实现类：一个指的是数组中一段连续的元素。指的是中包含下标和的中间一段连续元素。,"RangeFreqQuery(int[]arr)用下标从开始的整数数组arr构造一个类的实例。intquery(intleft,intright,intvalue)返回子数组arr[left...right]中value的1<=arr.length<=101<=arr[i],value<=100<=left<=right<arr.length调用query不超过次。",1,5
1677,59,2,100,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,一个指的是一个在十进制和k进制下从前往后读和从后往前读都一样的的整数。给你进制和一个数字，请你返回k镜像数字中的个数。,比方说，是一个2镜像数字。在十进制下为，二进制下为1001，两者从前往后读和从后往前读都一样。相反地，不是一个2镜像数字。在二进制下为100，从前往后和从后往前读不相同。2<=k<=91<=n<=30,1,2
1678,29,1,0,题库,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表：查询订单的金额的客户的数量。返回结果格式如下示例所示：,,1,1
1679,32,3,106,题库,2,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串数组和，请你返回在两个字符串数组中的字符串的数目。,"1<=words1.length,words2.length<=10001<=words1[i].length,words2[j].length<=30words1[i]和words2[j]都只包含小写英文字母。",1,4
1680,144,5,42,题库,1,2,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串。中每个字符要么是表示房屋的，要么是表示空位的。你可以在放置水桶，从相邻的房屋收集雨水。位置在的水桶可以收集位置为处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集房屋的雨水。在确保房屋旁边都有一个水桶的前提下，请你返回需要的水桶数。如果无解请返回。,1<=street.length<=10street[i]要么是'H'，要么是'.',1,3
1681,164,2,219,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的网格图，其中是最左上角的格子，是最右下角的格子。给你一个整数数组，表示有一个在格子处。同时给你一个整数数组，表示机器人的在格子处。机器人需要回家。每一步它可以往四个方向移动：，，，，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从开始的额整数数组：长度为的数组和长度为的数组。请你返回机器人回家需要的。,"如果机器人往或者往移动到第的格子，那么代价为rowCosts[r]如果机器人往或者往移动到第的格子，那么代价为colCosts[c]m==rowCosts.lengthn==colCosts.length1<=m,n<=100<=rowCosts[r],colCosts[c]<=10startPos.length==2homePos.length==20<=startrow,homerow<m0<=startcol,homecol<n",1,3
1682,156,4,70,题库,2,1,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一个状的农场，划分为行列的单元格。每个格子要么是（用表示），要么是的（用表示）。网格图以外的所有与格子都视为贫瘠的。农场中的区域定义如下：一个类似定义如下：下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。给你一个下标从开始且大小为的二进制矩阵，它表示农场，请你返回中金字塔和倒金字塔的。,"m==grid.lengthn==grid[i].length1<=m,n<=10001<=m*n<=10grid[i][j]要么是，要么是",1,3
1683,84,4,41,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组以及一个目标元素。是一个满足的下标。将按顺序排序后，返回由中目标下标组成的列表。如果不存在目标下标，返回一个列表。返回的列表必须按顺序排列。,"1<=nums.length<=1001<=nums[i],target<=100",1,3
1684,158,3,78,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，数组中有个整数，另给你一个整数。是指：中一个以下标为且为的子数组中所有元素的平均值，即下标在和范围（和）内所有元素的平均值。如果在下标前或后不足个元素，那么是。构建并返回一个长度为的数组，其中是以下标为中心的子数组的。个元素的是个元素相加之和除以，此时使用截断式，即需要去掉结果的小数部分。,"例如，四个元素和的平均值是(2+3+1+5)/4=11/4=2.75，截断后得到n==nums.length1<=n<=100<=nums[i],k<=10",1,2
1685,121,3,46,题库,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，数组由若干的整数组成。中有一个值最小的元素和一个值最大的元素。分别称为和。你的目标是从数组中移除这两个元素。一次操作定义为从数组的移除一个元素或从数组的移除一个元素。返回将数组中最小值和最大值移除需要的最小删除次数。,1<=nums.length<=10-10<=nums[i]<=10nums中的整数互不相同,1,2
1686,265,3,95,题库,1,2,1,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，表示有个专家从到编号。另外给你一个下标从0开始的二维整数数组，其中表示专家和专家在时间要开一场会。一个专家可以同时参加。最后，给你一个整数。专家有一个，最初，他在时间将这个秘密分享给了专家。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家在时间时知晓这个秘密，那么他将会与专家分享这个秘密，反之亦然。秘密共享是的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按返回答案。,"2<=n<=101<=meetings.length<=10meetings[i].length==30<=x,y<=n-1!=y1<=time<=101<=firstPerson<=n-1",1,5
1687,99,3,76,题库,3,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，其中每个元素是一个数字（）。数组中可能存在重复元素。你需要找出满足下述条件且的整数：例如，给定的是，整数和满足上面列出的全部条件。将找出的所有互不相同的整数按排列，并以数组形式返回,该整数由digits中的三个元素按顺序依次连接组成。该整数不含前导零该整数是一个3<=digits.length<=1000<=digits[i]<=9,1,4
1688,71,3,50,题库,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表的头节点。链表的，并返回修改后的链表的头节点。长度为链表的中间节点是从头数起第个节点（下标从开始），其中表示小于或等于的最大整数。,"对于=和的情况，中间节点的下标分别是和链表中节点的数目在范围[1,101<=Node.val<=10",1,2
1689,135,2,145,题库,1,1,2,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵的根节点，这棵二叉树总共有个节点。每个节点的值为到中的一个整数，且互不相同。给你一个整数，表示起点节点的值，和另一个不同的整数，表示终点节点的值。请找到从节点到节点的，并以字符串的形式返回每一步的方向。每一步用字母，和分别表示一种方向：请你返回从到每一步的方向。,"'L'表示从一个节点前往它的左孩子节点。'R'表示从一个节点前往它的右孩子节点。'U'表示从一个节点前往它的节点。树中节点数目为2<=n<=101<=Node.val<=n树中所有节点的值互不相同1<=startValue,destValue<=nstartValue!=destValue",1,4
1690,91,3,97,题库,0,1,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的二维整数数组，其中。如果的一个重新排列，满足对每一个下标（）都有，那么我们就认为这个重新排列是的一个。请你返回的合法重新排列。数据保证至少存在一个的合法重新排列。,"1<=pairs.length<=10pairs[i].length==20<=start,end<=10start!=endpairs中不存在一模一样的数对。至少一个合法的pairs重新排列。",1,3
1691,82,3,53,题库,2,0,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个整数数组和一个整数。你需要找到中长度为的，且这个子序列的。请你返回一个长度为的整数子序列。定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。,1<=nums.length<=1000-10<=nums[i]<=101<=k<=nums.length,1,4
1692,153,3,101,题库,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你和一群强盗准备打劫银行。给你一个下标从开始的整数数组，其中是第天执勤警卫的数量。日子从开始编号。同时给你一个整数。如果第天满足以下所有条件，我们称它为一个适合打劫银行的日子：更正式的，第天是一个合适打劫银行的日子当且仅当：.请你返回一个数组，包含适合打劫银行的日子（下标从开始）。返回的日子可以顺序排列。,"天前和后都分别至少有time天。天前连续time天警卫数目都是非递增的。天后连续time天警卫数目都是非递减的。1<=security.length<=100<=security[i],time<=10",1,3
1693,161,3,50,题库,1,2,1,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个炸弹列表。一个炸弹的定义为以炸弹为圆心的一个圆。炸弹用一个下标从开始的二维整数数组表示，其中。和表示第个炸弹的X和Y坐标，表示爆炸范围的。你需要选择引爆炸弹。当这个炸弹被引爆时，在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。给你数组，请你返回在引爆炸弹的前提下，能引爆的炸弹数目。,"1<=bombs.length<=100bombs[i].length==31<=x,y,r<=10",1,6
1694,153,1,274,题库,0,0,2,0,0,0,2,0,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个观光景点由它的名字和景点评分组成，其中是所有观光景点中的字符串，是一个整数。景点按照最好到最坏排序。景点评分，这个景点越好。如果有两个景点的评分一样，那么的景点更好。你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：注意，测试数据保证，查询次数都系统中景点的数目。请你实现类：,"景点，每次添加景点。查询已经添加景点中第的景点，其中比方说，如果系统正在进行第次查询，那么需要返回所有已经添加景点中第好的。SORTracker()初始化系统。voidadd(stringname,intscore)向系统中添加一个名为name评分为score的景点。stringget()查询第好的景点，其中是目前系统查询的次数（包括当前这次查询）。name只包含小写英文字母，且每个景点名字互不相同。1<=name.length<=101<=score<=10任意时刻，调用get的次数都不超过调用add的次数。调用add和get不超过4*10",1,4
1695,154,3,154,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,总计有个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在10根编号为到的杆上。给你一个长度为的字符串，表示这个环在杆上的分布。中每两个字符形成一个，用于描述每个环：例如，表示：共有个环，红色的环在编号为3的杆上，绿色的环在编号为2的杆上，蓝色的环在编号为1的杆上。找出所有集齐环的杆，并返回这种杆的数量。,对中的第一个字符表示第个环的'R''G''B'对中的第二个字符表示第个环的，也就是位于哪根杆上（'0'到'9'rings.length==2*n1<=n<=100是，则rings[i]的值可以取'R''G'或'B'（下标从开始计数）是，则rings[i]的值可以取'0'到'9'中的一个数字（下标从开始计数）,1,2
1696,79,3,36,题库,1,0,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。中，子数组的是子数组中最大元素和最小元素的差值。返回中子数组范围的子数组是数组中一个连续的元素序列。你可以设计一种时间复杂度为的解决方案吗？,1<=nums.length<=1000-10<=nums[i]<=10,1,3
1697,188,3,288,题库,2,0,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,Alice和Bob打算给花园里的株植物浇水。植物排成一行，从左到右进行标记，编号从到。其中，第株植物的位置是。每一株植物都需要浇特定量的水。Alice和Bob每人有一个水罐，。他们按下面描述的方式完成浇水：给你一个下标从开始的整数数组，数组由个整数组成。其中，为第株植物需要的水量。另有两个整数和分别表示Alice和Bob水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的。,"Alice按从左到右的顺序给植物浇水，从植物开始。Bob按从右到左的顺序给植物浇水，从植物n-1开始。他们给植物浇水。如果没有足够的水浇灌下一株植物，他/她会立即重新灌满浇水罐。不管植物需要多少水，浇水所耗费的时间都是一样的。提前重新灌满水罐。每株植物都可以由Alice或者Bob来浇水。如果Alice和Bob到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么Alice会给这株植物浇水。n==plants.length1<=n<=101<=plants[i]<=10max(plants[i])<=capacityA,capacityB<=10",1,3
1698,155,3,127,题库,1,1,0,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在一个无限的x坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组，其中表示共有个水果放置在上。已经按，每个。另给你两个整数和。最初，你位于。从任何位置，你可以选择走。在x轴上每移动，就记作。你总共可以走步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。返回你可以摘到水果的。,"1<=fruits.length<=10fruits[i].length==20<=startPos,position<=2*10对于任意i>0positioni-1<position均成立（下标从开始计数）1<=amount<=100<=k<=2*10",1,4
1699,72,3,61,题库,2,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组，找出并返回数组中的。如果不存在满足要求的字符串，返回一个。的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个。,1<=words.length<=1001<=words[i].length<=100words[i]仅由小写英文字母组成,1,3
1700,85,3,183,题库,3,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串，以及一个下标从开始的整数数组。数组描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值。请你添加空格，并返回修改后的字符串,"例如，s=""EnjoyYourCoffee""且spaces=[5,9]，那么我们需要在'Y'和'C'之前添加空格，这两个字符分别位于下标和下标。因此，最终得到""Enjoyouroffee""1<=s.length<=3*10仅由大小写英文字母组成1<=spaces.length<=3*100<=spaces[i]<=s.length-1spaces中的所有值严格递增",1,3
1701,75,3,36,题库,1,1,0,0,0,1,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，表示一支股票的历史每日股价，其中是这支股票第天的价格。一个定义为：对于，每日股价都比，这个阶段第一天的股价没有限制。请你返回的数目。,1<=prices.length<=101<=prices[i]<=10,1,3
1702,89,3,216,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始包含个正整数的数组，和一个正整数。如果对于每个满足的下标，都有，那么我们称是的。每一次中，你可以选择一个下标并将正整数。请你返回对于给定的，使数组变成K递增的。,"比方说，arr=[4,1,5,2,6,2]对于k=2arr[0]<=arr[2](4<=5)arr[1]<=arr[3](1<=2)arr[2]<=arr[4](5<=6)arr[3]<=arr[5](2<=2)但是，相同的数组arr对于k=1不是K递增的（因为arr[0]>arr[1]），对于k=3也不是K递增的（因为arr[0]>arr[3]）。1<=arr.length<=101<=arr[i],k<=arr.length",1,2
1703,62,2,124,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,EASY,一个由一些以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。给你一个字符串数组，其中表示单个。请你返回单个句子里。,1<=sentences.length<=1001<=sentences[i].length<=100sentences[i]只包含小写英文字母和''sentences[i]的开头和结尾都没有空格。sentences[i]中所有单词由单个空格隔开。,1,2
1704,169,4,259,题库,2,0,3,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有道不同菜的信息。给你一个字符串数组和一个二维字符串数组。第道菜的名字为，如果你有它的原材料，那么你可以这道菜。一道菜的原材料可能是菜，也就是说可能包含中另一个字符串。同时给你一个字符串数组，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。请你返回你可以做出的所有菜。你可以以返回它们。注意两道菜在它们的原材料中可能互相包含。,"n==recipes.length==ingredients.length1<=n<=1001<=ingredients[i].length,supplies.length<=1001<=recipes[i].length,ingredients[i][j].length,supplies[k].length<=10recipes[i],ingredients[i][j]和supplies[k]只包含小写英文字母。所有recipes和supplies中的值互不相同。ingredients[i]中的字符串互不相同。",1,5
1705,113,3,177,题库,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个括号字符串是只由和组成的字符串。如果一个字符串满足下面一个条件，那么它就是有效的：给你一个括号字符串和一个字符串，两者长度都为。是一个二进制字符串，只包含和。对于中下标：如果你可以将变为有效括号字符串，请你返回，否则返回。,字符串为它可以表示为与连接），其中和都是有效括号字符串。它可以表示为(A)，其中是一个有效括号字符串。如果locked[i]是'1'，你改变s[i]如果locked[i]是'0'，你将s[i]变为'('或者')'n==s.length==locked.length1<=n<=10s[i]要么是'('要么是')'locked[i]要么是'0'要么是'1',1,3
1706,64,3,143,题库,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个正整数和，满足。请你计算中所有整数的。由于乘积可能非常大，你需要将它按照以下步骤：请你返回一个字符串，表示中所有整数的。,"比方说，1000中有个后缀0，546中没有后缀0。比方说，我们将1234567654321表示为12345...54321，但是1234567仍然表示为1234567比方说，12345678987600000被表示为""12345...89876e5""1<=left<=right<=10",1,1
1707,42,3,44,题库,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个整数意味着倒置它的所有位。给你一个整数，得到，得到。如果等于，返回；否则，返回。,例如，反转2021得到1202。反转12300得到321不保留前导零0<=num<=10,1,1
1708,203,3,106,题库,2,0,0,0,0,0,0,1,1,0,1,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,现有一个大小的网格，左上角单元格坐标，右下角单元格坐标。给你整数和一个整数数组，其中表示机器人最开始在坐标为的单元格上。另给你一个长度为、下标从开始的字符串，其中是对机器人的第条指令：（向左移动），（向右移动），（向上移动）和（向下移动）。机器人可以从中的任一第条指令开始执行。它将会逐条执行指令直到的末尾，但在满足下述条件之一时，机器人将会停止：返回一个长度为的数组，其中是机器人从第条指令，可以执行的。,"下一条指令将会导致机器人移动到网格外。没有指令可以执行。m==s.length1<=n,m<=500startPos.length==20<=startrow,startcol<n由'L''R''U'和'D'组成",1,2
1709,86,2,34,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、由个整数组成的数组。中两个元素的定义为它们下标之间的。更正式地，和之间的间隔是。返回一个长度为的数组，其中是和中每个相同元素（与的值相同）的是的绝对值。,n==arr.length1<=n<=101<=arr[i]<=10,1,3
1710,201,3,62,题库,3,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Alice有一个下标从开始的数组，由个正整数组成。她会选择一个任意的并按下述方式创建两个下标从开始的新整数数组和：不幸地是，Alice丢失了全部三个数组。但是，她记住了在数组和中出现的整数，但不知道每个整数属于哪个数组。请你帮助Alice还原原数组。给你一个由2n个整数组成的整数数组，其中个整数出现在，剩下的出现在，还原并返回。如果出现答案不唯一的情况，返回有效数组。生成的测试用例保证存在有效数组。,2*n==nums.length1<=n<=10001<=nums[i]<=10生成的测试用例保证存在至少一个有效数组arr,1,4
1711,37,3,28,题库,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由字符和组成的字符串。如果字符串中都出现在之前，返回；否则，返回。,1<=s.length<=100s[i]为'a'或'b',1,1
1712,190,2,94,题库,3,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,银行内部的防盗安全装置已经激活。给你一个下标从开始的二进制字符串数组，表示银行的平面图，这是一个大小为的二维矩阵。表示第行的设备分布，由若干和若干组成。表示单元格是空的，而表示单元格有一个安全设备。对任意两个安全设备而言，满足下面两个条件，则二者之间存在激光束：激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。返回银行中激光束的总数量。,"两个设备位于两个不同行和，其中<r满足<i<r的所有，都没有安全设备m==bank.lengthn==bank[i].length1<=m,n<=500bank[i][j]为'0'或'1'",1,4
1713,139,2,53,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个整数，它表示一颗行星的初始质量。再给你一个整数数组，其中是第颗小行星的质量。你可以按重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量小行星的质量，那么小行星被，并且行星会这颗小行星的质量。否则，行星将被摧毁。如果所有小行星能被摧毁，请返回，否则返回。,1<=mass<=101<=asteroids.length<=101<=asteroids[i]<=10,1,3
1714,139,3,59,题库,0,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个公司准备组织一场会议，邀请名单上有位员工。公司准备了一张的桌子，可以坐下的员工。员工编号为到。每位员工都有一位的员工，每位员工他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工是他自己。给你一个下标从开始的整数数组，其中表示第位员工喜欢的员工。请你返回参加会议的。,n==favorite.length2<=n<=100<=favorite[i]<=n-1favorite[i]!=i,1,3
1715,62,2,115,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母：请你返回的。,如果单词的长度为或者，所有字母变成小写。否则，将单词首字母大写，剩余字母变成小写。1<=title.length<=100title由单个空格隔开的单词组成，且不含有任何前导或后缀空格。每个单词由大写和小写英文字母组成，且都是的。,1,1
1716,83,3,81,题库,0,0,2,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个大小为且为的链表中，对于的，第个节点（下标从开始）的孪生节点为第个节点。定义为一个节点和它孪生节点两者值之和。给你一个长度为偶数的链表的头节点，请你返回链表的。,"比方说，n=4那么节点是节点的孪生节点，节点是节点的孪生节点。这是长度为n=4的链表中所有的孪生节点。链表的节点数目是[2,10中的1<=Node.val<=10",1,3
1717,121,3,55,题库,2,1,1,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个字符串数组。中每个元素都是一个包含小写英文字母的单词。请你从中选择一些元素并按连接它们，并得到一个。每个元素只能使用一次。请你返回你能得到的最长回文串的。如果没办法得到任何一个回文串，请你返回。指的是从前往后和从后往前读一样的字符串。,1<=words.length<=10words[i].length==2words[i]仅包含小写英文字母。,1,5
1718,91,2,99,题库,2,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的二进制矩阵，每个格子要么为（空）要么为（被占据）。给你邮票的尺寸为。我们想将邮票贴进二进制矩阵中，且满足以下和：如果在满足上述要求的前提下，可以放入邮票，请返回，否则返回。,"m==grid.lengthn==grid[r].length1<=m,n<=101<=m*n<=2*10grid[r][c]要么是，要么是1<=stampHeight,stampWidth<=10",1,4
1719,89,2,61,题库,2,0,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,对一个大小为的矩阵而言，如果其每一行和每一列都包含从到的整数（含和），则认为该矩阵是一个矩阵。给你一个大小为的整数矩阵，请你判断矩阵是否为一个有效矩阵：如果是，返回；否则，返回。,n==matrix.length==matrix[i].length1<=n<=1001<=matrix[i][j]<=n,1,3
1720,74,3,28,题库,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,定义为选中一个数组中的两个的位置并交换二者的值。数组是一个数组，可以认为元素和元素。给你一个数组，返回在将数组中的所有聚集在一起需要的最少交换次数。,1<=nums.length<=10nums[i]为或者,1,2
1721,163,2,304,题库,3,0,1,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个下标从开始的字符串数组和。每个字符串都仅由组成。对于中的每个字符串，检查是否能够从中选出一个字符串，执行一次，得到的结果与当前字符串相等。如下面两步所述：找出中有多少字符串能够由中的字符串执行上述转换操作获得。返回中这类。你仅能验证中的字符串是否可以由中的某个字符串经执行操作获得。中的字符串在这一过程中发生实际变更。,"例如，如果字符串为""abc""，那么字母'd''e'或'y'都可以加到该字符串末尾，但'a'就不行。如果追加的是'd'，那么结果字符串为""abcd""例如，""abcd""可以重排为""acbd""""bacd""""cbda""，以此类推。注意，它也可以重排为""abcd""自身。1<=startWords.length,targetWords.length<=5*101<=startWords[i].length,targetWords[j].length<=26startWords和targetWords中的每个字符串都仅由小写英文字母组成startWords或targetWords的任一字符串中，每个字母至多出现一次",1,5
1722,104,3,216,题库,2,1,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从开始的整数数组和，每个数组的长度都是：从第开始，你可以按顺序播种种子。返回所有种子都开花的一天是第几天。,"plantTime[i]是第枚种子所需的完整天数。每天，你只能为播种某一枚种子而劳作。连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到plantTime[i]之后才算完成。growTime[i]是第枚种子完全种下后生长所需的完整天数。在它生长的最后一天，将会开花并且永远n==plantTime.length==growTime.length1<=n<=101<=plantTime[i],growTime[i]<=10",1,3
1723,123,2,139,题库,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,字符串可以按下述步骤划分为若干长度为的组：注意，在去除最后一个组的填充字符（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是。给你一个字符串，以及每组的长度和一个用于填充的字符，按上述步骤处理之后，返回一个字符串数组，该数组表示分组后。,第一组由字符串中的前个字符组成，第二组由接下来的个字符串组成，依此类推。每个字符都能够成为某一个组的一部分。对于最后一组，如果字符串剩下的字符个，需使用字符fill来补全这一组字符。1<=s.length<=100仅由小写英文字母组成1<=k<=100fill是一个小写英文字母,1,2
1724,99,3,67,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你正在玩一个整数游戏。从整数开始，期望得到整数。在一次行动中，你可以做下述两种操作之一：在整个游戏过程中，你可以使用操作次数。但是只能使用操作次。给你两个整数和，返回从1开始得到需要的最少行动次数。,，将当前整数的值加1（即，x=x+1，使当前整数的值翻倍（即，x=2*x1<=target<=100<=maxDoubles<=100,1,2
1725,151,2,165,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的二维整数数组，其中。这个数组表示一场考试里的一系列题目，你需要（也就是从问题开始依次解决），针对每个问题选择或者操作。解决问题将让你的分数，但是你将解决接下来的个问题（即只能跳过接下来的个问题）。如果你跳过问题，你可以对下一个问题决定使用哪种操作。请你返回这场考试里你能获得的分数。,"比方说，给你questions=[[3,2],[4,3],[4,4],[2,5]]如果问题被解决了，那么你可以获得分，但你不能解决问题和如果你跳过问题，且解决问题，你将获得分但是不能解决问题和1<=questions.length<=10questions[i].length==21<=points,brainpower<=10",1,2
1726,201,2,45,题库,2,2,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有台电脑。给你整数和一个下标从开始的整数数组，其中第个电池可以让一台电脑分钟。你想使用这些电池让台电脑运行。一开始，你可以给每台电脑连接。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。注意，你不能给电池充电。请你返回你可以让台电脑同时运行的分钟数。,1<=n<=batteries.length<=101<=batteries[i]<=10,1,4
1727,102,3,94,题库,2,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,一家商店正在打折销售糖果。每购买糖果，商店会送一个糖果。免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的。给你一个下标从开始的整数数组，其中表示第个糖果的价格，请你返回获得糖果的总开销。,比方说，总共有个糖果，价格分别为和，一位顾客买了价格为和的糖果，那么他可以免费获得价格为的糖果，但不能获得价格为的糖果。1<=cost.length<=1001<=cost[i]<=100,1,3
1728,122,3,220,题库,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始且长度为的整数数组，它表示一个长度为的数组元素之间的。更正式的表述为：我们将隐藏数组记作，那么。同时给你两个整数和，它们表示隐藏数组中所有数字的值都在区间之间。请你返回要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回。,"比方说，differences=[1,-3,4]lower=1upper=6，那么隐藏数组是一个长度为且所有值都在和[3,4,1,5]和[4,5,2,6]都是符合要求的隐藏数组。[5,6,3,7]不符合要求，因为它包含大于的元素。[1,2,3,4]不符合要求，因为相邻元素的差值不符合给定数据。n==differences.length1<=n<=10-10<=differences[i]<=10-10<=lower<=upper<=10",1,2
1729,212,3,223,题库,3,1,1,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的二维整数数组，它的大小为，表示一个商店中物品的分布图。数组中的整数含义为：从一个格子走到上下左右相邻格子花费步。同时给你一个整数数组和，其中且，表示你开始位置为，同时你只对物品价格在之内的物品感兴趣。同时给你一个整数。你想知道给定范围且的件物品的。排名按照优先级从高到低的以下规则制定：请你返回给定价格内排名最高的件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于件物品，那么请将它们的坐标返回。,"表示无法穿越的一堵墙。表示可以自由通过的一个空格子。所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。m==grid.lengthn==grid[i].length1<=m,n<=101<=m*n<=100<=grid[i][j]<=10pricing.length==22<=low<=high<=10start.length==20<=row<=m-10<=col<=n-1grid[row][col]>01<=k<=m*n",1,5
1730,248,3,50,题库,1,1,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从开始，长度为的字符串，它包含字母和，其中每个表示一个座位，每个表示一株植物。在下标的左边和下标的右边分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置和之间（），至多能放一个屏风。请你将走廊用屏风划分为若干段，且每一段内都，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为方案。请你返回划分走廊的方案数。由于答案可能很大，请你返回它对的结果。如果没有任何方案，请返回。,n==corridor.length1<=n<=10corridor[i]要么是'S'，要么是'P',1,3
1731,45,2,35,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，统计并返回在中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。,1<=nums.length<=100-10<=nums[i]<=10,1,2
1732,80,2,65,题库,2,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，数组长度为，由数目相等的正整数和负整数组成。你需要中的元素，使修改后的数组满足下述条件：重排元素满足上述条件后，返回修改后的数组。,2<=nums.length<=2*10nums.length是1<=|nums[i]|<=10nums由数量的正整数和负整数组成,1,3
1733,63,2,32,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。如果数字在数组中仅出现，且没有数字（即，和）出现在数组中，则认为数字是。返回中的孤独数字。你可以按返回答案。,1<=nums.length<=100<=nums[i]<=10,1,3
1734,106,2,141,题库,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,游戏中存在两种角色：给你一个下标从开始的二维整数数组，大小为，表示个玩家对彼此角色的陈述。具体来说，可以是下述值之一：另外，玩家不会对自己进行陈述。形式上，对所有，都有。根据这个玩家的陈述，返回可以认为是的数目。,：该角色只说真话。：该角色可能说真话，也可能说假话。表示的陈述认为是表示的陈述认为是表示没有对作出陈述。n==statements.length==statements[i].length2<=n<=15statements[i][j]的值为或statements[i][i]==2,1,4
1735,52,2,45,题库,3,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，另给你一个整数，这是需要在中搜索的第一个数字。接下来，你需要按下述步骤操作：返回的值。,"1<=nums.length<=10001<=nums[i],original<=1000",1,4
1736,73,3,183,题库,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的二进制数组，数组长度为。可以按下标（）拆分成两个数组（可能为空）：和。下标的为中的个数和中的个数之。返回的。你可以按返回答案。,numsleft包含nums中从下标到i-1的所有元素（包括和i-1，而numsright包含nums中从下标到n-1的所有元素（包括和n-1）。如果i==0numsleft为，而numsright将包含nums中的所有元素。如果i==nnumsleft将包含nums中的所有元素，而numsright为n==nums.length1<=n<=10nums[i]为或,1,1
1737,116,2,146,题库,1,0,0,0,3,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定整数和，一个长度为且下标从开始的字符串的哈希值按照如下函数计算：其中表示在字母表中的下标，从到。给你一个字符串和整数，，和。请你返回中长度为的，满足。测试数据保证一定至少一个这样的子串。定义为一个字符串中连续非空字符组成的序列。,"hash(s,p,m)=(val(s[0])*p+val(s[1])*p+...+val(s[k-1])*pk-1)modm1<=k<=s.length<=2*101<=power,modulo<=100<=hashValue<modulo只包含小写英文字母。测试数据保证一定满足条件的子串。",1,4
1738,206,2,185,题库,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的字符串数组。每个字符串都只包含。中任意一个子串中，每个字母都至多只出现一次。如果通过以下操作之一，我们可以从的字母集合得到的字母集合，那么我们称这两个字符串为：数组可以分为一个或者多个无交集的。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。请你返回一个长度为的数组：,的字母集合中添加一个字母。的字母集合中删去一个字母。中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。ans[0]是words分组后的总组数ans[1]是字符串数目最多的组所包含的字符串数目。1<=words.length<=2*101<=words[i].length<=26words[i]只包含小写英文字母。words[i]中每个字母最多只出现一次。,1,3
1739,56,2,96,题库,1,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个四位整数。请你使用中的，将拆成两个新的整数和。和中可以有，且中数位都必须使用。请你返回可以得到的和的和。,"比方说，给你num=2932，你拥有的数位包括：两个，一个和一个。一些可能的[new1,new2]数对为[22,93][23,92][223,9]和[2,329]1000<=num<=9999",1,3
1740,55,2,291,题库,2,0,0,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个整数。请你将重新排列，使得以下条件均成立：请你返回重新排列数组后的结果数组。,所有小于pivot的元素都出现在所有大于pivot的元素所有等于pivot的元素都出现在小于和大于pivot的元素小于pivot的元素之间和大于pivot的元素之间的相对顺序更正式的，考虑每一对是初始时位置元素的新位置，是初始时位置元素的新位置。对于小于pivot的元素，如果i<j且nums[i]<pivot和nums[j]<pivot都成立，那么<p也成立。类似的，对于大于pivot的元素，如果i<j且nums[i]>pivot和nums[j]>pivot都成立，那么<p1<=nums.length<=10-10<=nums[i]<=10pivot等于nums中的一个元素。,1,3
1741,267,2,131,题库,1,0,0,0,0,1,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,常见的微波炉可以设置加热时间，且加热时间满足以下条件：你可以输入来设置加热时间。如果你输入的位数不足4位，微波炉会自动加来补足4位。微波炉会将设置好的四位数中，两位当作分钟数，两位当作秒数。它们所表示的总时间就是加热时间。比方说：给你整数，，和。，你的手指在数字处。将手指移到，需要花费的单位代价。输入你手指所在位置的数字一次，需要花费的单位代价。要设置秒的加热时间，可能会有多种设置方法。你想要知道这些方法中，总代价最小为多少。请你能返回设置秒钟加热时间需要花费的最少代价。请记住，虽然微波炉的秒数最多可以设置到秒，但一分钟等于秒。,"至少为秒钟。至多为分秒。你输入（三个数字），被自动补足为0954，并表示分秒。你输入（四个数字），表示分秒。你输入，表示分秒。你输入，表示分秒。0<=startAt<=91<=moveCost,pushCost<=101<=targetSeconds<=6039",1,2
1742,81,2,157,题库,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的整数数组，它包含个元素。你可以从中删除个元素，剩下的个元素将会被分成两个的部分。两部分和的记为。请你返回删除个元素之后，剩下两部分和的是多少。,前面个元素属于第一部分，它们的和记为sumfirst后面个元素属于第二部分，它们的和记为sumsecond比方说，sumfirst=3且sumsecond=2，它们的差值为再比方，sumfirst=2且sumsecond=3，它们的差值为nums.length==3*n1<=n<=101<=nums[i]<=10,1,3
1743,41,2,151,题库,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组。根据下述规则重排中的值：返回重排的值之后形成的数组。,"举个例子，如果排序前nums=[4,,2,，对奇数下标的值排序后变为[4,,2,。奇数下标和的值按照非递增顺序重排。举个例子，如果排序前nums=[,1,,3]，对偶数下标的值排序后变为,1,,3]。偶数下标和的值按照非递减顺序重排。1<=nums.length<=1001<=nums[i]<=100",1,2
1744,60,2,12,题库,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数。中的各位数字，使其值且不含前导零。返回不含前导零且值最小的重排数字。注意，重排各位数字后，的符号不会改变。,-10<=num<=10,1,2
1745,24,1,491,题库,1,0,1,0,0,0,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是一种能以紧凑形式存储位的数据结构。请你实现类。,Bitset(intsize)用size个位初始化Bitset，所有位都是voidfix(intidx)将下标为idx的位上的值更新为。如果值已经是，则不会发生任何改变。voidunfix(intidx)将下标为idx的位上的值更新为。如果值已经是，则不会发生任何改变。voidflip()翻转Bitset中每一位上的值。换句话说，所有值为的位将会变成，反之亦然。booleanall()检查Bitset中每一位的值是否都是。如果满足此条件，返回true；否则，返回falsebooleanone()检查Bitset中是否至少一位的值是。如果满足此条件，返回true；否则，返回falseintcount()返回Bitset中值为1的位的StringtoString()返回Bitset的当前组成情况。注意，在结果字符串中，第个下标处的字符应该与Bitset中的第位一致。1<=size<=100<=idx<=size-1至多调用fixunfixflipallonecount和toString方法至少调用allonecount或toString方法一次至多调用toString方法,1,3
1746,146,2,29,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的二进制字符串，表示一个列车车厢序列。表示第节车厢含违禁货物，而表示第节车厢含违禁货物。作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：返回移除所有载有违禁货物车厢所需要的单位时间数。注意，空的列车车厢序列视为没有车厢含违禁货物。,1<=s.length<=2*10s[i]为'0'或'1',1,2
1747,37,2,104,题库,1,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数和。每一步中，如果，你必须用减；否则，你必须用减。返回使或的。,"例如，num1=5且num2=4，应该用num1减num2，因此，得到num1=1和num2=4。然而，如果num1=4num2=5，一步操作后，得到num1=4和num2=10<=num1,num2<=10",1,2
1748,72,2,92,题库,1,1,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，该数组由个正整数组成。如果满足下述条件，则数组是一个：在一步中，你可以选择下标并将为正整数。返回使数组变成交替数组的。,nums[i-2]==nums[i]，其中2<=i<=n-1nums[i-1]!=nums[i]，其中1<=i<=n-11<=nums.length<=101<=nums[i]<=10,1,4
1749,117,2,34,题库,2,0,0,0,1,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个整数数组，其中每个整数表示一个袋子里装的魔法豆的数目。请你从每个袋子中一些豆子（也可以），使得剩下的袋子中（即还有魔法豆的袋子）魔法豆的数目。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。请你返回你需要拿出魔法豆的。,1<=beans.length<=101<=beans[i]<=10,1,3
1750,109,2,132,题库,1,1,0,0,2,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的整数数组和一个整数，满足。总共有个篮子，编号为到。你需要把所有个整数分到这些篮子中，且每个篮子有2个整数。一种分配方案的定义为每个数与它所在篮子编号的结果之和。请你返回将中所有数放入个篮子中的最大与和。,"比方说，将数字[1,3]放入篮子中，[4,6]放入篮子中，这个方案的与和为(1AND)+(3AND)+(4AND)+(6AND)=1+1+0+2=4n==nums.length1<=numSlots<=91<=n<=2*numSlots1<=nums[i]<=15",1,4
1751,40,2,36,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始长度为的整数数组和一个整数，请你返回满足，且能被整除的数对的。,"1<=nums.length<=1001<=nums[i],k<=100",1,1
1752,50,2,10,题库,1,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，请你返回三个连续的整数，它们的为。如果无法被表示成三个连续整数的和，请你返回一个数组。,0<=num<=10,1,2
1753,98,3,147,题库,0,2,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数。请你将它拆分成若干个的正偶数之和，且拆分出来的正偶数数目。请你返回一个整数数组，表示将整数拆分成数目的正偶数数组。如果没有办法将进行拆分，请你返回一个数组。你可以按顺序返回这些整数。,比方说，给你finalSum=12，那么这些拆分是符合要求的（互不相同的正偶数且和为finalSum(2+10)(2+4+6)和(4+8)。它们中，(2+4+6)包含最多数目的整数。注意finalSum不能拆分成(2+2+4+4)，因为拆分出来的整数必须互不相同。1<=finalSum<=10,1,3
1754,108,2,91,题库,1,3,1,2,0,0,0,1,0,0,0,0,0,1,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个下标从开始且长度为的整数数组和，两者都是的。指的是个的值，且它们在数组和中出现顺序保持一致。换句话说，如果我们将记为值在中出现的位置，为值在中的位置，那么一个好三元组定义为，且和都成立的。请你返回好三元组的。,"n==nums1.length==nums2.length3<=n<=100<=nums1[i],nums2[i]<=n-1nums1和nums2是[0,1,...,n-1]的排列。",1,7
1755,52,2,12,题库,1,0,0,0,0,1,0,0,0,1,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数，请你统计并返回且各位数字之和为的正整数的数目。正整数的是其所有位上的对应数字相加的结果。,1<=num<=1000,1,2
1756,116,2,75,题库,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表的头节点，该链表包含由分隔开的一连串整数。链表的和的节点都满足。对于每两个相邻的，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有移除，修改后的链表不应该含有任何。返回修改后链表的头节点。,"列表中的节点数目在范围[3,2*100<=Node.val<=1000存在连续两个Node.val==0的节点链表的和节点都满足Node.val==0",1,2
1757,140,2,37,题库,1,1,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串和一个整数，用中的字符构造一个新字符串，使任何字母出现的次数都不超过次。你不必使用中的全部字符。返回。如果在字符串和不同的第一个位置，字符串中的字母在字母表中出现时间比字符串对应的字母晚，则认为字符串比字符串。如果字符串中前个字符都相同，那么较长的字符串字典序更大。,1<=repeatLimit<=s.length<=10由小写英文字母组成,1,4
1758,40,2,65,题库,1,0,0,0,0,2,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始、长度为的整数数组和一个整数，返回满足下述条件的下标对的数目：,"0<=i<j<=n-1nums[i]*nums[j]能被整除。1<=nums.length<=101<=nums[i],k<=10",1,3
1759,47,2,77,题库,2,0,0,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组和一个字符串。返回中以作为的字符串的数目。字符串的就是的任一前导连续字符串。,"1<=words.length<=1001<=words[i].length,pref.length<=100words[i]和pref由小写英文字母组成",1,2
1760,61,2,36,题库,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串和。在一步操作中，你可以给或者追加。返回使和互为所需的最少步骤数指字母相同但是顺序不同（或者相同）的字符串。,"1<=s.length,t.length<=2*10和由小写英文字符组成",1,3
1761,139,2,43,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，其中表示第辆公交车完成所需要花费的时间。每辆公交车可以完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以下一趟旅途。每辆公交车运行，也就是说可以同时有多辆公交车在运行且互不影响。给你一个整数，表示所有公交车需要完成的旅途数目。请你返回完成趟旅途需要花费的时间。,"1<=time.length<=101<=time[i],totalTrips<=10",1,2
1762,135,2,155,题库,1,1,0,0,0,0,0,0,0,1,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的二维整数数组，其中表示第种轮胎如果连续使用，第圈需要耗时秒。同时给你一个整数和一个整数。比赛总共包含圈，你可以选择一种轮胎开始比赛。每一种轮胎都有。每一圈后，你可以选择耗费秒任意一种轮胎（也可以换成当前种类的新轮胎）。请你返回完成比赛需要耗费的时间。,"比方说，如果=3且=2，且一直使用这种类型的同一条轮胎，那么该轮胎完成第圈赛道耗时秒，完成第圈耗时3*2=6秒，完成第圈耗时3*2=12秒，依次类推。1<=tires.length<=10tires[i].length==21<=f,changeTime<=102<=r<=101<=numLaps<=1000",1,2
1763,101,2,87,题库,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组，同时给你一个整数，它在出现过。在数组中紧跟着后面出现的不同整数的出现次数。换言之，的出现次数为满足以下条件的的数目：请你返回出现次数的。测试数据保证出现次数最多的是唯一的。,0<=i<=n-2nums[i]==keynums[i+1]==target2<=nums.length<=10001<=nums[i]<=1000测试数据保证答案是唯一的。,1,3
1764,108,2,164,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，它表示一个十进制数的映射规则，表示这个规则下将数位映射为数位。一个整数为将原数字每一个数位（）映射为。另外给你一个整数数组，请你将数组中每个数按照它们映射后对应数字非递减顺序排序后返回。,如果两个数字映射后对应的数字大小相同，则将它们按照输入中的相对顺序排序。nums中的元素只有在排序的时候需要按照映射后的值进行比较，返回的值应该是输入的元素本身。mapping.length==100<=mapping[i]<=9mapping[i]的值互不相同1<=nums.length<=3*100<=nums[i]<10,1,2
1765,116,2,100,题库,0,2,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数，它表示一个中节点的数目，节点编号为到（包括两者）。给你一个二维整数数组，其中表示图中一条从到的单向边。请你返回一个数组，其中是第个节点的所有，这些祖先节点排序。如果通过一系列边，能够到达，那么我们称节点是节点的节点。,"1<=n<=10000<=edges.length<=min(2000,n*(n-1)/2)edges[i].length==20<=from,to<=n-1from!=to图中不会有重边。图是且的。",1,4
1766,72,2,44,题库,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个只包含小写英文字母的字符串。每一次，你可以选择中两个的字符，并将它们交换。请你返回将变成回文串的。，输入数据会确保一定能变成一个回文串。,1<=s.length<=2000只包含小写英文字母。可以通过有限次操作得到一个回文串。,1,4
1767,120,2,144,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,Excel表中的一个单元格会以字符串的形式进行表示，其中：给你一个格式为的字符串，其中表示列，表示行，表示列，表示行，并满足且。找出所有满足且的单元格，并以列表形式返回。单元格应该按前面描述的格式用表示，并以顺序排列（先按列排，再按行排）。,<col>即单元格的列号。用英文字母表中的例如，第列用'A'表示，第列用'B'表示，第列用'C'表示，以此类推。<row>即单元格的行号。第行就用标识。s.length==5'A'<=s[0]<=s[3]<='Z''1'<=s[1]<=s[4]<='9'由大写英文字母、数字、和':'组成,1,1
1768,55,2,34,题库,2,1,0,0,0,1,0,1,1,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。请你向中追加个出现在中的、的整数，并使结果数组的元素和。返回追加到中的个整数之和。,"1<=nums.length<=101<=nums[i],k<=10",1,4
1769,68,2,175,题库,1,2,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中表示是在中的，二叉树中各节点的值。此外：请你根据的描述来构造二叉树并返回其。测试用例会保证可以构造出的二叉树。,"如果isLeft==1，那么child就是parent的左子节点。如果isLeft==0，那么child就是parent的右子节点。1<=descriptions.length<=10descriptions[i].length==31<=parent,child<=100<=isLeft<=1descriptions所描述的二叉树是一棵有效二叉树",1,6
1770,100,2,56,题库,1,0,1,0,0,2,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组。请你对数组执行下述操作：返回修改后得到的数组。可以证明的是，以顺序替换相邻的非互质数都可以得到相同的结果。生成的测试用例可以保证最终数组中的值。两个数字和满足的条件是：，其中是和的。,1<=nums.length<=101<=nums[i]<=10生成的测试用例可以保证最终数组中的值小于或者等于,1,4
1771,63,2,69,题库,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组和两个整数和。是中的一个下标，并满足至少存在一个下标使得且。以列表形式返回按排序的所有K近邻下标。,1<=nums.length<=10001<=nums[i]<=1000key是数组nums中的一个整数1<=k<=nums.length,1,1
1772,215,2,225,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,存在一个大小、下标从开始的网格，网格中埋着一些工件。给你一个整数和一个下标从开始的二维整数数组，描述了矩形工件的位置，其中表示第个工件在子网格中的填埋情况：你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。给你一个下标从开始的二维整数数组，其中表示你将会挖掘单元格，返回你可以提取的工件数目。生成的测试用例满足：,"(r1,c1是第个工件单元格的坐标，且(r2,c2是第个工件单元格的坐标。不存在重叠的两个工件。每个工件最多只覆盖个单元格。dig中的元素互不相同。1<=n<=10001<=artifacts.length,dig.length<=min(n,10artifacts[i].length==4dig[i].length==20<=r1,c1,r2,c2,r,c<=n-1<=r2<=c2不存在重叠的两个工件每个工件只覆盖个单元格dig中的元素互不相同",1,3
1773,112,2,97,题库,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个下标从开始的整数数组，它表示一个，其中是栈顶的元素。每一次操作中，你可以执行以下操作：同时给你一个整数，它表示你总共需要执行操作的次数。请你返回执行次操作以后，栈顶元素的。如果执行完次操作以后，栈一定为空，请你返回。,"如果栈非空，那么栈顶端的元素。如果存在1个或者多个被删除的元素，你可以从它们中选择任何一个，回栈顶，这个元素成为新的栈顶元素。1<=nums.length<=100<=nums[i],k<=10",1,2
1774,164,2,117,题库,0,0,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，它表示一个图的节点数，节点编号为到。同时给你一个二维整数数组，其中，表示从到有一条边权为的边。最后，给你三个的整数，和，表示图中三个不同的点。请你从图中选出一个的子图，使得从和出发，在这个子图中，都到达。如果这样的子图不存在，请返回。中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。,"3<=n<=100<=edges.length<=10edges[i].length==30<=from,to,src1,src2,dest<=n-1from!=tosrc1src2和dest两两不同。1<=weight[i]<=10",1,2
1775,52,2,60,题库,1,0,1,0,2,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个整数数组，它包含个整数。你需要将划分成个数对，满足：如果可以将划分成个数对，请你返回，否则返回。,每个元素只属于一个数对。同一数对中的元素nums.length==2*n1<=n<=5001<=nums[i]<=500,1,4
1776,158,2,58,题库,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串和另一个下标从开始且长度为的字符串，两者都只包含小写英文字母。你可以在中任意位置插入字符，这个插入的字符必须是。注意，这个字符可以插入在开头或者结尾的位置。请你返回插入一个字符后，中最多包含多少个等于的。指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。,1<=text.length<=10pattern.length==2text和pattern都只包含小写英文字母。,1,3
1777,79,2,32,题库,1,1,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个正整数数组。每一次操作中，你可以从中选择一个数并将它减小到一半。（注意，在后续操作中你可以对减半过的数继续执行操作）请你返回将数组和减少一半的操作数。,1<=nums.length<=101<=nums[i]<=10,1,3
1778,110,2,122,题库,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的字符串，它表示地板上砖块的颜色。同时给你和。你有条的地毯，每一条的地毯长度都为块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余砖块的数目。地毯相互之间可以覆盖。请你返回没被覆盖的白色砖块的数目。,floor[i]='0'表示地板上第块砖块的颜色是floor[i]='1'表示地板上第块砖块的颜色是1<=carpetLen<=floor.length<=1000floor[i]要么是'0'，要么是'1'1<=numCarpets<=1000,1,3
1779,154,2,34,题库,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组。如果两侧距最近的不相等邻居的值均小于，则下标是中，某个峰的一部分。类似地，如果两侧距最近的不相等邻居的值均大于，则下标是中某个谷的一部分。对于相邻下标和，如果，则认为这两下标属于峰或谷。注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须存在不相等邻居。返回中峰和谷的数量。,3<=nums.length<=1001<=nums[i]<=100,1,1
1780,169,2,91,题库,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一条无限长的公路上有辆汽车正在行驶。汽车按从左到右的顺序按从到编号，每辆车都在一个位置。给你一个下标从开始的字符串，长度为。可以是、或分别表示第辆车是向、向或者在当前位置。每辆车移动时。碰撞次数可以按下述方式计算：碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。返回在这条道路上发生的。,当两辆移动方向的车相撞时，碰撞次数加当一辆移动的车和一辆静止的车相撞时，碰撞次数加1<=directions.length<=10directions[i]的值为'L''R'或'S',1,2
1781,225,2,201,题库,2,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Alice和Bob是一场射箭比赛中的对手。比赛规则如下：例如，Alice和Bob都向计分为的区域射支箭，那么Alice得分。如果Alice向计分为的区域射支箭，但Bob向同一个区域射支箭，那么Bob得分。给你整数和一个长度为的整数数组，该数组表示Alice射中到每个计分区域的箭数量。现在，Bob想要尽可能他所能获得的总分。返回数组，该数组表示Bob射中到计分区域的箭数量。且的总和应当等于。如果存在多种方法都可以使Bob获得最大总分，返回其中即可。,"例如，Alice和Bob都向计分为的区域射支箭，那么Alice得分。如果Alice向计分为的区域射支箭，但Bob向同一个区域射支箭，那么Bob得分。1<=numArrows<=10aliceArrows.length==bobArrows.length==120<=aliceArrows[i],bobArrows[i]<=numArrowssum(aliceArrows[i])==numArrows",1,4
1782,109,2,129,题库,2,0,1,1,0,0,0,0,0,0,1,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的字符串。另给你一个下标从开始、长度为的字符串，一个下标从开始、长度也是的整数数组，这两个都用来描述个查询。第个查询会将中位于下标的字符更新为。返回一个长度为的数组，其中是在执行第个查询中仅由组成的的,1<=s.length<=10由小写英文字母组成k==queryCharacters.length==queryIndices.length1<=k<=10queryCharacters由小写英文字母组成0<=queryIndices[i]<s.length,1,4
1783,46,2,138,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个下标从开始的整数数组和，请你返回一个长度为的列表，其中：列表中的整数可以按顺序返回。,"answer[0]是nums1中所有不存在于nums2中的整数组成的列表。answer[1]是nums2中所有不存在于nums1中的整数组成的列表。1<=nums1.length,nums2.length<=1000-1000<=nums1[i],nums2[i]<=1000",1,2
1784,131,2,81,题库,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，如果满足下述条件，则认为数组是一个：注意，空数组同样认为是美丽数组。你可以从中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持。返回使变为美丽数组所需删除的元素数目,nums.length为偶数对所有满足i%2==0的下标nums[i]!=nums[i+1]均成立1<=nums.length<=100<=nums[i]<=10,1,3
1785,83,2,56,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你返回一个数组，其中是长度为的中第小的数字，如果不存在这样的回文数，则为。指的是从前往后和从后往前读一模一样的数字。回文数不能有前导0。,1<=queries.length<=5*101<=queries[i]<=101<=intLength<=15,1,2
1786,131,2,75,题库,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一张桌子上总共有个硬币。每个栈有个带面值的硬币。每一次操作中，你可以从任意一个栈的取出1个硬币，从栈中移除它，并放入你的钱包里。给你一个列表，其中是一个整数数组，分别表示第个栈里的硬币面值。同时给你一个正整数，请你返回在进行次操作的前提下，你钱包里硬币面值之和。,n==piles.length1<=n<=10001<=piles[i][j]<=101<=k<=sum(piles[i].length)<=2000,1,3
1787,52,2,129,题库,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一次定义为将数字二进制中的一个位进行操作，即将变成，或者将变成。给你两个整数和，请你返回将转变成的次数。,"比方说，x=7，二进制表示为111，我们可以选择任意一个位（包含没有显示的前导0）并进行翻转。比方说我们可以翻转最右边一位得到110，或者翻转右边起第二位得到101，或者翻转右边起第五位（这一位是前导0）得到10111等等。0<=start,goal<=10",1,1
1788,62,2,33,题库,2,0,0,0,0,2,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，其中是到之间（两者都包含）的一个数字。的是执行以下操作以后最后剩下元素的值：请你返回的三角和。,1<=nums.length<=10000<=nums[i]<=9,1,4
1789,97,2,124,题库,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的二进制字符串，它表示一条街沿途的建筑类型，其中：作为市政厅的官员，你需要随机3栋建筑。然而，为了确保多样性，选出来的3栋建筑的两栋不能是同一类型。请你返回可以选择3栋建筑的。,"s[i]='0'表示第栋建筑是一栋办公楼，s[i]='1'表示第栋建筑是一间餐厅。比方说，给你s=""0，我们不能选择第和栋建筑，因为得到的子序列是，有相邻两栋建筑是同一类型，所以题意。3<=s.length<=10s[i]要么是'0'，要么是'1'",1,3
1790,100,2,61,题库,2,1,0,1,2,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你需要从空字符串开始一个长度为的字符串，构造的过程为每次给当前字符串添加字符。构造过程中得到的所有字符串编号为到，其中长度为的字符串编号为。的为和的的长度（注意）。给你最终的字符串，请你返回每一个的。,"比方说，s=""abaca""==""a""==""ca""==""aca""依次类推。1<=s.length<=10只包含小写英文字母。",1,6
1791,96,2,43,题库,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串和，表示两个。按进行格式化，其中在和之间，而在和之间。最早的24小时制时间为，最晚的是。在一步操作中，你可以将这个时间增加、、或分钟。你可以执行这一操作次数。返回将转化为需要的。,"current和correct都符合""HH:MM""格式current<=correct",1,2
1792,50,2,172,题库,2,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组其中表示在一场比赛中击败了。返回一个长度为2的列表：两个列表中的值都应该按顺序返回。,"answer[0]是所有输掉任何比赛的玩家列表。answer[1]是所有恰好输掉比赛的玩家列表。只考虑那些参与至少一场比赛的玩家。生成的测试用例保证不存在两场比赛结果1<=matches.length<=10matches[i].length==21<=winner,loser<=10winner!=loser所有matches[i]互不相同",1,4
1793,127,2,46,题库,1,1,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的整数数组。数组中的每个元素表示大小为的一堆糖果。你可以将每堆糖果分成任意数量的，但再将两堆合并到一起。另给你一个整数。你需要将这些糖果分配给个小孩，使每个小孩分到数量的糖果。每个小孩可以拿走糖果，有些糖果可能会不被分配。返回每个小孩可以拿走的。,1<=candies.length<=101<=candies[i]<=101<=k<=10,1,2
1794,123,1,482,题库,2,0,1,1,0,0,1,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符数组，由若干的字符组成。还有一个字符串数组，内含若干长度为2的字符串。另给你一个字符串数组，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从开始字符串的数据结构。字符串按下述步骤进行：字符串按下述步骤进行：实现类：,"Encrypter(char[]keys,String[]values,String[]dictionary)用keysvalues和dictionary初始化Encrypter类。Stringencrypt(Stringword1)按上述加密过程完成对word1的加密，并返回加密后的字符串。intdecrypt(Stringword2)统计并返回可以由word2解密得到且出现在dictionary中的字符串数目。1<=keys.length==values.length<=26values[i].length==21<=dictionary.length<=1001<=dictionary[i].length<=100所有keys[i]和dictionary[i]互不相同1<=word1.length<=20001<=word2.length<=200所有word1[i]都出现在keysword2.length是偶数keysvalues[i]dictionary[i]word1和word2只含小写英文字母至多调用encrypt和decrypt200",1,5
1795,47,2,10,题库,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数。你可以交换中相同的任意两位数字（即，都是奇数或者偶数）。返回交换次之后的可能值,1<=num<=10,1,2
1796,195,3,147,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串，格式为，其中和表示正整数。请你向中添加一对括号，使得在添加之后，仍然是一个有效的数学表达式，并且计算后可以得到可能值。左括号添加在的左侧，而右括号必须添加在的右侧。返回添加一对括号后形成的表达式，且满足计算得到可能值如果存在多个答案都能产生相同结果，返回任意一个答案。生成的输入满足：的原始值和添加满足要求的任一对括号之后的值，都符合32-bit带符号整数范围。,3<=expression.length<=10expression仅由数字'1'到'9'和'+'组成expression由数字开始和结束expression恰好仅含有一个'+'expression的原始值和添加满足要求的任一对括号之后expression的值，都符合32-bit带符号整数范围,1,2
1797,69,2,34,题库,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个非负整数数组和一个整数。每次操作，你可以选择中元素并将它。请你返回次操作后，能得到的的。由于答案可能很大，请你将答案对取余后返回。,"1<=nums.length,k<=100<=nums[i]<=10",1,3
1798,165,2,135,题库,2,2,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Alice是个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。给你一个下标从开始大小为的整数数组，其中是第个花园里已经种的花的数目。已经种了的花移走。同时给你，表示Alice额外可以种花的。同时给你的还有整数，和。如果一个花园有朵花，那么这个花园称为，花园的为以下分数之：请你返回Alice种最多朵花以后，能得到的总美丽值。,"花园数目乘以full剩余不完善花园里，花的最少数目乘以partial。如果没有不完善花园，那么这一部分的值为1<=flowers.length<=101<=flowers[i],target<=101<=newFlowers<=101<=full,partial<=10",1,5
1799,20,2,20,题库,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你两个整数和，返回这两个整数的和。
","-100<=num1,num2<=100",1,1
1800,61,2,36,题库,0,0,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个的根结点，该二叉树由恰好个结点组成：根结点、左子结点和右子结点。如果根结点值等于两个子结点值之和，返回，否则返回。,树只包含根结点、左子结点和右子结点-100<=Node.val<=100,1,2
1801,40,2,26,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个长度为的整数数组，请你返回中最的数字。如果有多个答案，请你返回它们中的。,1<=n<=1000-10<=nums[i]<=10,1,1
1802,83,2,24,题库,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，表示你拥有的总钱数。同时给你两个整数和，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。请你返回购买钢笔和铅笔的。,"1<=total,cost1,cost2<=10",1,2
1803,77,1,476,题库,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个ATM机器，存有种面值的钞票：，，，和美元。初始时，ATM机是空的。用户可以用它存或者取任意数目的钱。取款时，机器会优先取数额的钱。请你实现ATM类：,比方说，你想取$300，并且机器里有张$50的钞票，张$100的钞票和张$200的钞票，那么机器会取出$100和$200的钞票。但是，如果你想取$600，机器里有张$200的钞票和张$500的钞票，那么取款请求会被拒绝，因为机器会先取出$500的钞票，然后无法取出剩余的$100。注意，因为有$500钞票的存在，机器取$200的钞票。ATM()初始化ATM对象。voiddeposit(int[]banknotesCount)分别存入$20$50$100$200和$500钞票的数目。int[]withdraw(intamount)返回一个长度为的数组，分别表示$20$50$100$200和$500钞票的数目，并且更新ATM机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回[-1]（这种情况下取出任何钞票）。banknotesCount.length==50<=banknotesCount[i]<=101<=amount<=10最多有5000次withdraw和deposit的调用。函数withdraw和deposit至少各有一次调用。,1,3
1804,151,2,128,题库,3,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个节点的，节点编号为到。给你一个下标从开始的整数数组，其中是第个节点的分数。同时给你一个二维整数数组，其中，表示节点和之间有一条边。一个合法的节点序列如果满足以下条件，我们称它是：节点序列的分数定义为序列中节点分数之。请你返回一个长度为的合法节点序列的最大分数。如果不存在这样的序列，请你返回。,"序列中每节点之间有边相连。序列中没有节点出现超过一次。n==scores.length4<=n<=5*101<=scores[i]<=100<=edges.length<=5*10edges[i].length==20<=a,b<=n-1!=b不会有重边。",1,4
1805,72,2,35,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由若干数字（-）组成的字符串，和一个整数。如果的长度大于，则可以执行一轮操作。在一轮操作中，需要完成以下工作：返回在完成所有轮操作后的。,1<=s.length<=1002<=k<=100仅由数字（-）组成。,1,2
1806,76,2,34,题库,1,1,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，其中表示任务的难度级别。在每一轮中，你可以完成2个或者3个的任务。返回完成所有任务需要的轮数，如果无法完成所有任务，返回。,1<=tasks.length<=101<=tasks[i]<=10,1,4
1807,217,2,94,题库,2,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，大小为，其中每个单元格都含一个正整数。定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全或者移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。一条路径的定义为：路径上所有值的乘积。请你从中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。注意：,"移动是指向左或右移动。竖直移动是指向上或下移动。m==grid.lengthn==grid[i].length1<=m,n<=101<=m*n<=101<=grid[i][j]<=1000",1,3
1808,147,2,98,题库,2,1,3,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一棵（即一个连通、无向、无环图），根节点是节点，这棵树由编号从到的个节点组成。用下标从开始、长度为的数组来表示这棵树，其中是节点的父节点，由于节点是根节点，所以。另给你一个字符串，长度也是，其中表示分配给节点的字符。请你找出路径上任意一对相邻节点都没有分配到相同字符的，并返回该路径的长度。,n==parent.length==s.length1<=n<=10对所有i>=10<=parent[i]<=n-1均成立parent[0]==-1parent表示一棵有效的树仅由小写英文字母组成,1,6
1809,51,2,83,题库,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个二维整数数组，其中是由正整数组成的一个非空数组，按返回一个数组，数组中的每个元素在中都出现过。,1<=nums.length<=10001<=sum(nums[i].length)<=10001<=nums[i][j]<=1000nums[i]中的所有值互不相同,1,3
1810,39,2,94,题库,2,0,1,0,0,2,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中表示网格上圆心为且半径为的第个圆，返回出现在圆内的。,"是指整数坐标对应的点。圆周上的点也被视为出现在圆内的点。1<=circles.length<=200circles[i].length==31<=x,y<=1001<=r<=min(x,y",1,5
1811,127,2,130,题库,2,1,0,1,0,0,0,0,1,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中表示第个矩形长为高为。给你一个二维整数数组，其中是坐标为的一个点。第个矩形的在处，在。请你返回一个整数数组，长度为，其中是第个点的矩形数目。如果且，那么我们说第个矩形包含第个点。如果一个点刚好在矩形的，这个点也被视为被矩形包含。,"1<=rectangles.length,points.length<=5*10rectangles[i].length==points[j].length==21<=l,x<=101<=h,y<=100所有rectangles互不相同所有points互不相同",1,4
1812,93,2,100,题库,2,1,2,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的二维整数数组，其中表示第朵花的从到（都）。同时给你一个下标从开始大小为的整数数组，是第个人来看花的时间。请你返回一个大小为的整数数组，其中是第个人到达时在花期内花的。,1<=flowers.length<=5*10flowers[i].length==21<=start<=end<=101<=persons.length<=5*101<=persons[i]<=10,1,6
1813,72,2,70,题库,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个字符串数组和一个字符串，其中和只包含。请你返回中是字符串的。一个字符串的是出现在字符串开头的子字符串。是一个字符串中的连续一段字符序列。,"1<=words.length<=10001<=words[i].length,s.length<=10words[i]和包含小写英文字母。",1,2
1814,91,2,77,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始长度为的整数数组。下标处的指的是中个元素平均值和个元素平均值的。两个平均值都需要到最近的整数。请你返回产生的下标。如果有多个下标最小平均差相等，请你返回的一个下标。,两个数的绝对差是两者差的绝对值。个元素的平均值是个元素之除以（整数除法）个元素的平均值视为1<=nums.length<=100<=nums[i]<=10,1,2
1815,150,2,170,题库,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和表示一个下标从开始的网格图。同时给你两个二维整数数组和，其中且，分别表示第个警卫和第座墙所在的位置。一个警卫能看到4个坐标轴方向（即东、南、西、北）的格子，除非他们被一座墙或者另外一个警卫了视线。如果一个格子能被一个警卫看到，那么我们说这个格子被了。请你返回空格子中，有多少个格子是的。,"1<=m,n<=102<=m*n<=101<=guards.length,walls.length<=5*102<=guards.length+walls.length<=m*nguards[i].length==walls[j].length==20<=row,row<m0<=col,col<nguards和walls中所有位置互不相同",1,3
1816,246,3,128,题库,2,2,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始大小为的二维整数数组，它表示一个网格图。每个格子为下面3个值之一：一开始你在最左上角的格子，你想要到达最右下角的安全屋格子。每一分钟，你可以移动到的草地格子。每次你移动，着火的格子会扩散到所有不是墙的格子。请你返回你在初始位置可以停留的分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回。如果不管你在初始位置停留多久，你能到达安全屋，请你返回。注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。如果两个格子有共同边，那么它们为格子。,"表示草地。表示着火的格子。表示一座墙，你跟火都不能通过这个格子。m==grid.lengthn==grid[i].length2<=m,n<=3004<=m*n<=2*10grid[i][j]是或者grid[0][0]==grid[m-1][n-1]==0",1,4
1817,65,3,77,题库,2,1,0,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个表示某个正整数的字符串和一个字符。从中移除等于的字符后，找出并返回按表示的结果字符串。生成的测试用例满足在中出现至少一次。,2<=number.length<=100number由数字'1'到'9'组成digit是'1'到'9'中的一个数字digit在number中出现至少一次,1,3
1818,90,2,34,题库,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中表示第张卡牌的。如果两张卡牌的值相同，则认为这一对卡牌。返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回。,1<=cards.length<=100<=cards[i]<=10,1,3
1819,115,2,89,题库,2,0,1,1,2,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和两个整数和，找出并返回满足要求的不同的子数组数，要求子数组中最多个可被整除的元素。如果满足下述条件之一，则认为数组和是数组：定义为：数组中的连续元素组成的一个序列。你可以设计并实现时间复杂度为的算法解决此问题吗？,"两数组长度，或者存在至少一个下标满足nums1[i]!=nums2[i]1<=nums.length<=2001<=nums[i],p<=2001<=k<=nums.length",1,6
1820,46,2,59,题库,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,字符串的定义为：字符串中字符的数量。给你一个字符串，返回定义为：字符串中的一个连续字符序列。,"例如，""abbca""的引力为，因为其中有个不同字符'a''b'和'c'1<=s.length<=10由小写英文字母组成",1,3
1821,73,3,100,题库,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个：以字符串形式返回。如果不存在满足要求的整数，则返回一个空字符串。,该整数是num的一个长度为的子字符串该整数由唯一一个数字重复次组成。子字符串是字符串中的一个连续字符序列。num或优质整数中可能存在前导零3<=num.length<=1000num仅由数字（-）组成,0,1
1822,39,2,85,题库,0,1,2,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，找出并返回满足要求的节点数，要求节点的值等于其中值的。,"个元素的平均值可以由个元素然后再除以，并向下舍入到最近的整数。root的由root和它的所有后代组成。树中节点数目在范围[1,1000]0<=Node.val<=1000",1,3
1823,147,2,172,题库,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Alice在给Bob用手机打字。数字到字母的如下图所示。为了一个字母，Alice需要对应字母次，是该字母在这个按键上所处的位置。但是，由于传输的错误，Bob没有收到Alice打字的字母信息，反而收到了。给你一个字符串，表示Bob收到的字符串，请你返回Alice。由于答案可能很大，将它对后返回。,"比方说，为了按出字母's'，Alice需要按'7'四次。类似的，Alice需要按'5'两次得到字母'k'注意，数字'0'和'1'不映射到任何字母，所以Alice使用它们。比方说，Alice发出的信息为""bob""，Bob将收到字符串""2266622""1<=pressedKeys.length<=10pressedKeys只包含数字'2'到'9'",1,4
1824,94,2,178,题库,2,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个括号字符串是一个且只包含和的字符串。如果下面条件为，那么这个括号字符串就是。给你一个的括号网格图矩阵。网格图中一个是满足以下所有条件的一条路径：如果网格图中存在一条，请返回，否则返回。,"字符串是字符串可以表示为连接和都是合法括号序列。字符串可以表示为(A)，其中是合法括号序列。路径开始于左上角格子(0,0)路径结束于右下角格子(m-1,n-1)路径每次只会向或者向移动。路径经过的格子组成的括号字符串是合法的。m==grid.lengthn==grid[i].length1<=m,n<=100grid[i][j]要么是'('，要么是')'",1,3
1825,60,2,65,题库,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,一个整数的美丽值定义为中符合以下条件的数目：给你整数和，请你返回的k美丽值。注意：一个是一个字符串里的连续一段字符序列。,子字符串长度为子字符串能整除num允许有不能整除任何值。1<=num<=101<=k<=num.length（将num视为字符串）,1,3
1826,38,2,89,题库,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,"给你一个下标从开始长度为的整数数组。
在下标处有一个：请你返回中的方案数。",i+1个元素的和大于等于剩下的n-i-1个元素的和。下标的右边至少有一个元素，也就是说下标满足0<=i<n-12<=nums.length<=10-10<=nums[i]<=10,1,2
1827,78,2,77,题库,2,2,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中，表示所有在之间的每个瓷砖位置都被涂成了白色。同时给你一个整数，表示可以放在的一块毯子。请你返回使用这块毯子，可以盖住多少块瓷砖。,1<=tiles.length<=5*10tiles[i].length==21<=l<=r<=101<=carpetLen<=10tiles互相不会重叠,1,5
1828,78,2,25,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,字符串的定义为子字符串中出现次数的字符次数与出现次数的字符次数之差。给你一个字符串，它只包含小写英文字母。请你返回里所有值。是一个字符串的一段连续字符序列。,1<=s.length<=10只包含小写英文字母。,1,2
1829,179,2,59,题库,3,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串，其中由小写英文字符组成。在一步操作中，需要选出任一下标，从中。其中下标需要同时满足下述两个条件：只要可以选出满足条件的下标，就一直执行这个操作。在执行所有操作后，返回。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，是的一个字母异位词。,1<=words.length<=1001<=words[i].length<=10words[i]由小写英文字母组成,1,4
1830,129,2,67,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,Alice管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice决定将一些楼层作为，仅用于放松。给你两个整数和，表示Alice租用了从到（含和在内）的所有楼层。另给你一个整数数组，其中表示Alice指定用于放松的特殊楼层。返回不含特殊楼层的连续楼层数。,1<=special.length<=101<=bottom<=special[i]<=top<=10special中的所有值互不相同,1,2
1831,77,2,95,题库,1,0,1,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,对数组执行相当于对数组中的所有整数执行。给你一个正整数数组。计算中的数字每种组合下的结果。中的每个数字在每种组合中只能使用。返回按位与结果大于的组合的长度,"例如，对nums=[1,5,3]来说，按位与等于1&5&3=1同样，对nums=[7]而言，按位与等于1<=candidates.length<=101<=candidates[i]<=10",1,4
1832,40,1,190,题库,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你区间的集，请你设计并实现满足要求的数据结构：实现类：区间表示满足的所有整数。,"新增：添加一个区间到这个区间集合中。统计：计算出现在至少一个区间中的整数个数。CountIntervals()使用区间的空集初始化对象voidadd(intleft,intright)添加区间[left,right]到区间集合之中。intcount()返回出现在至少一个区间中的整数个数。1<=left<=right<=10最多调用add和count方法调用count方法至少一次",1,3
1833,38,2,40,题库,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串和一个字符，返回在中等于字符所占的，向下取整到最接近的百分比。,1<=s.length<=100由小写英文字母组成letter是一个小写英文字母,1,1
1834,92,2,106,题库,2,1,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现有编号从到的个背包。给你两个下标从开始的整数数组和。第个背包最大可以装块石头，当前已经装了块石头。另给你一个整数，表示请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的数量,n==capacity.length==rocks.length1<=n<=5*101<=capacity[i]<=100<=rocks[i]<=capacity[i]1<=additionalRocks<=10,1,3
1835,98,2,74,题库,2,0,0,0,0,3,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中表示股票在的价格为。是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：请你返回要表示一个折线图所需要的。,"1<=stockPrices.length<=10stockPrices[i].length==21<=day,price<=10所有day互不相同",1,5
1836,128,2,60,题库,1,0,2,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,作为国王的统治者，你有一支巫师军队听你指挥。给你一个下标从开始的整数数组，其中表示第位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是的），定义为以下两个值的：请你返回巫师组的力量之和。由于答案可能很大，请将答案对后返回。是一个数组里连续子序列。,巫师中的能力值。组中所有巫师的个人力量值1<=strength.length<=101<=strength[i]<=10,1,4
1837,56,2,30,题库,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始长度为的字符串，它只包含数字。如果对于的下标，都满足数位在中出现了次，那么请你返回，否则返回。,n==num.length1<=n<=10num只包含数字。,1,3
1838,143,2,229,题库,2,0,1,0,1,0,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个聊天记录，共包含条信息。给你两个字符串数组和，其中是发出的一条。一条是若干用单个空格连接的，信息开头和结尾不会有多余空格。发件人的是这个发件人总共发出的。注意，一个发件人可能会发出多于一条信息。请你返回发出单词数的发件人名字。如果有多个发件人发出最多单词数，请你返回最大的名字。,"字典序里，大写字母小于小写字母。""Alice""和""alice""是不同的名字。n==messages.length==senders.length1<=n<=101<=messages[i].length<=1001<=senders[i].length<=10messages[i]包含大写字母、小写字母和''messages[i]中所有单词都由单个空格隔开。messages[i]不包含前导和后缀空格。senders[i]只包含大写英文字母和小写英文字母。",1,4
1839,121,2,70,题库,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，表示一个国家里的城市数目。城市编号为到。给你一个二维整数数组，其中表示城市和之间有一条道路。你需要给每个城市安排一个从到之间的整数值，且每个值只能被使用。道路的定义为这条道路连接的两座城市数值。请你返回在最优安排下，之和为多少。,"2<=n<=5*101<=roads.length<=5*10roads[i].length==20<=a,b<=n-1!=b没有重复道路。",0,4
1840,73,1,504,题库,0,1,0,2,0,0,1,0,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个音乐会总共有排座位，编号从到，每一排有个座椅，编号为到。你需要设计一个买票系统，针对以下情况进行座位安排：由于观众非常挑剔，所以：请你实现类：,"同一组的位观众坐在同一排座位，且座位连续位观众中每一位都有座位坐，但他们不一定坐在一起。只有当一个组里所有成员座位的排数都小于等于maxRow，这个组才能订座位。每一组的maxRow可能如果有多排座位可以选择，优先选择的排数。如果同一排中有多个座位可以坐，优先选择号码的。BookMyShow(intn,intm)，初始化对象，是排数，是每一排的座位数。int[]gather(intk,intmaxRow)返回长度为的数组，表示个成员中第一个座位的排数和座位编号，这位成员必须坐在同一排座位，且座位连续。换言之，返回最小可能的和满足第排中[c,c+k-1]的座位都是空的，且r<=maxRow。如果安排座位，返回booleanscatter(intk,intmaxRow)如果组里所有个成员不一定要坐在一起的前提下，都能在第排到第maxRow排之间找到座位，那么请返回true。这种情况下，每个成员都优先找排数，然后是座位编号最小的座位。如果不能安排所有个成员的座位，请返回false1<=n<=5*101<=m,k<=100<=maxRow<=n-1gather和scatter调用次数不超过5*10次。",1,4
1841,64,3,52,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个下标从开始的字符串和。你可以从取出一些字符并将其重排，得到若干新的字符串。从中取出字符并重新排列，返回可以形成的副本数。,1<=s.length<=1001<=target.length<=10和target由小写英文字母组成,1,3
1842,180,2,166,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个。给你一个字符串表示一个句子和一个整数。对于每个表示价格的单词，都在价格的基础上减免，并该单词到句子中。所有更新后的价格应该表示为一个的数字。返回表示修改后句子的字符串。注意：所有价格为位数字。,"例如""$100""""$23""和""$6""表示价格，而""100""""$""和""$1e5不是。1<=sentence.length<=10sentence由小写英文字母、数字、''和'$'组成sentence不含前导和尾随空格sentence的所有单词都用单个空格分隔所有价格都是整数且不含前导零所有价格为位数字0<=discount<=100",1,1
1843,58,2,32,题库,1,0,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个下标从开始的整数数组。在一步操作中，移除所有满足的，其中。重复执行步骤，直到变为数组，返回所需执行的操作数。,1<=nums.length<=101<=nums[i]<=10,1,4
1844,98,2,111,题库,2,1,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的二维整数数组，数组大小为。每个单元格都是两个值之一：你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。现在你需要从左上角移动到右下角，返回需要移除的障碍物的数目。,"表示一个单元格，表示一个可以移除的障碍物m==grid.lengthn==grid[i].length1<=m,n<=102<=m*n<=10grid[i][j]为grid[0][0]==grid[m-1][n-1]==0",1,6
1845,47,2,48,题库,2,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组，其长度是的幂。对执行下述算法：执行算法后，返回中剩下的那个数字。,1<=nums.length<=10241<=nums[i]<=10nums.length是的幂,1,2
1846,133,3,40,题库,2,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。你可以将划分成一个或多个，使中的每个元素都出现在一个子序列中。在满足每个子序列中最大值和最小值之间的差值最多为的前提下，返回需要划分的子序列数目。本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。,1<=nums.length<=100<=nums[i]<=100<=k<=10,1,3
1847,79,2,248,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，它包含个的正整数。请你对这个数组执行个操作，在第个操作中，你需要将数字替换成。题目保证在第个操作中：请你返回执行完所有操作后的数组。,"operations[i][0]在nums中存在。operations[i][1]在nums中不存在。n==nums.lengthm==operations.length1<=n,m<=10nums中所有数字互不相同operations[i].length==21<=nums[i],operations[i][0],operations[i][1]<=10在执行第个操作时，operations[i][0]在nums中存在。在执行第个操作时，operations[i][1]在nums中不存在。",1,3
1848,100,1,399,题库,2,0,3,0,0,0,1,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,请你设计一个带光标的文本编辑器，它可以实现以下功能：当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候都成立。请你实现类：你能设计并实现一个每次调用时间复杂度为的解决方案吗？,"添加：在光标所在处添加文本。删除：在光标所在处删除文本（模拟键盘的删除键）。移动：将光标往左或者往右移动。TextEditor()用空文本初始化对象。voidaddText(stringtext)将text添加到光标所在位置。添加完后光标在text的右边。intdeleteText(intk)删除光标左边个字符。返回实际删除的字符数目。stringcursorLeft(intk)将光标向左移动次。返回移动后光标左边min(10,len)个字符，其中len是光标左边的字符数目。stringcursorRight(intk)将光标向右移动次。返回移动后光标左边min(10,len)个字符，其中len是光标左边的字符数目。1<=text.length,k<=40text只含有小写英文字母。调用addTextdeleteTextcursorLeft和cursorRight的次数不超过2*10次。",1,6
1849,50,3,178,题库,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果一个密码满足以下所有条件，我们称它是一个密码：给你一个字符串，如果它是一个密码，返回，否则返回。,"它有至少个字符。至少包含一个小写英文字母。至少包含一个大写英文字母。至少包含一个数字至少包含一个特殊字符。特殊字符为：""!@#$%^&*()-+""中的一个。包含个连续相同的字符（比方说""aab""不符合该条件，但是""aba""符合该条件）。1<=password.length<=100password包含字母，数字和""!@#$%^&*()-+""这些特殊字符。",1,1
1850,112,2,84,题库,2,1,0,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个正整数数组和，长度分别为和，其中表示第个咒语的能量强度，表示第瓶药水的能量强度。同时给你一个整数。一个咒语和药水的能量强度如果，那么它们视为一对的组合。请你返回一个长度为的整数数组，其中是能跟第个咒语成功组合的数目。,"n==spells.lengthm==potions.length1<=n,m<=101<=spells[i],potions[i]<=101<=success<=10",1,4
1851,111,3,124,题库,3,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,给你两个字符串和。同时给你一个二维字符数组，其中表示你可以将中任意数目的字符替换为。中每个字符被替换超过一次。如果使用替换0个或者若干个字符，可以将变成的一个子字符串，请你返回，否则返回。一个是字符串中连续非空的字符序列。,1<=sub.length<=s.length<=50000<=mappings.length<=1000mappings[i].length==2old!=new和sub只包含大写和小写英文字母和数字。old和new是大写、小写字母或者是个数字。,1,4
1852,56,2,75,题库,1,1,0,0,2,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个数组的定义为数组之和数组的长度。给你一个正整数数组和一个整数，请你返回中分数的。是数组中的一个连续元素序列。,"比方说，[1,2,3,4,5]的分数为(1+2+3+4+5)*5=751<=nums.length<=101<=nums[i]<=101<=k<=10",1,4
1853,111,3,195,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的二维整数数组，其中，表示第个税级的上限是，征收的税率为。税级按上限（在满足的前提下，）。税款计算方式如下：给你一个整数表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超的结果将被视作正确答案。,不超过upper的收入按税率percent缴纳接着upper-upper的部分按税率percent缴纳然后upper-upper的部分按税率percent缴纳以此类推1<=brackets.length<=1001<=upper<=10000<=percent<=1000<=income<=1000upper按递增顺序排列upper中的所有值互不相同最后一个税级的上限大于等于income,1,2
1854,251,2,123,题库,2,1,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,"给你一个下标从开始的整数矩阵，矩阵大小为，由从到的不同整数组成。你可以在此矩阵中，从一个单元格移动到的任何其他单元格。如果你位于单元格，且满足，你可以移动到,,...,中的任何一个单元格。在最后一行中的单元格不能触发移动。每次可能的移动都需要付出对应的代价，代价用一个下标从开始的二维数组表示，该数组大小为，其中是从值为的单元格移动到下一行第列单元格的代价。从最后一行的单元格移动的代价可以忽略。一条路径的代价是：所有路径经过的单元格的加上所有移动的。从任意单元格出发，返回到达任意单元格的最小路径代价","m==grid.lengthn==grid[i].length2<=m,n<=50grid由从到m*n-1的不同整数组成moveCost.length==m*nmoveCost[i].length==n1<=moveCost[i][j]<=100",1,3
1855,130,2,57,题库,1,2,0,0,2,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，其中表示在第个零食包中的饼干数量。另给你一个整数表示等待分发零食包的孩子数量，零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。分发的定义为单个孩子在分发过程中能够获得饼干的最大总数。返回所有分发的最小不公平程度。,2<=cookies.length<=81<=cookies[i]<=102<=k<=cookies.length,1,5
1856,50,2,76,题库,3,0,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串数组表示在公司命名过程中使用的名字列表。公司命名流程如下：返回且有效的公司名字的数目。,2<=ideas.length<=5*101<=ideas[i].length<=10ideas[i]由小写英文字母组成ideas中的所有字符串互不相同,1,5
1857,114,3,29,题库,2,0,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由英文字母组成的字符串，请你找出并返回中的英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。英文字母的大写和小写形式必须在中出现。英文字母比另一个英文字母的前提是：英文字母表中，在之出现。,1<=s.length<=1000由小写和大写英文字母组成,1,3
1858,54,3,84,题库,1,2,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和，考虑具有以下属性的正整数多重集：返回该多重集的最小大小，如果不存在这样的多重集，返回。注意：,每个整数个位数字都是所有整数之和是num多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为个位数字是数字最右边的数位。0<=num<=30000<=k<=9,1,4
1859,44,2,96,题库,1,3,0,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二进制字符串和一个正整数。请你返回的子序列，且该子序列对应的数字小于等于。注意：,子序列可以有前导0空字符串视为子序列是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。1<=s.length<=1000s[i]要么是'0'，要么是'1'1<=k<=10,1,4
1860,200,2,112,题库,1,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个整数和，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组，其中表示你可以以元的价格卖一块高为宽为的矩形木块。每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：在将一块木块切成若干小木块后，你可以根据卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你旋转切好后木块的高和宽。请你返回切割一块大小为的木块后，能得到的钱数。注意你可以切割木块任意次。,"沿垂直方向按高度切割木块，或沿水平方向按宽度切割木块1<=m,n<=2001<=prices.length<=2*10prices[i].length==31<=h<=m1<=w<=n1<=price<=10所有,w互不相同",1,3
1861,74,3,46,题库,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串，每连续竖线为。换言之，第一个和第二个为一对，第三个和第四个为一对，以此类推。请你返回竖线对之间，中的数目。，每个竖线都会属于一个对。,1<=s.length<=1000只包含小写英文字母，竖线'|'和星号'*'包含个竖线'|',1,1
1862,57,2,65,题库,0,2,1,1,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，表示一张中有个节点，编号为到。同时给你一个二维整数数组，其中表示节点和之间有一条边。请你返回的不同。,"1<=n<=100<=edges.length<=2*10edges[i].length==20<=a,b<n!=b不会有重复边。",1,4
1863,76,2,32,题库,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。一次操作中，选择非负整数和一个下标，为。注意，是逐位与运算，是逐位异或运算。请你执行更新操作，并返回中所有元素逐位异或和。,1<=nums.length<=100<=nums[i]<=10,0,3
1864,103,2,8,题库,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数。你需要掷一个6面的骰子次。请你在满足以下要求的前提下，求出骰子序列的数目：请你返回不同序列的。由于答案可能很大，请你将答案对后返回。如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。,1<=n<=10,1,2
1865,63,2,56,题库,2,0,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,如果一个正方形矩阵满足下述条件，则称之为一个：给你一个大小为的二维整数数组，表示一个正方形矩阵。如果是一个，返回；否则，返回。,n==grid.length==grid[i].length3<=n<=1000<=grid[i][j]<=10,1,2
1866,148,2,8,题库,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一条街道上共有个，街道的两侧各有个地块。每一边的地块都按从到编号。每个地块上都可以放置一所房子。现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对取余后再返回。注意，如果一所房子放置在这条街某一侧上的第个地块，不影响在另一侧的第个地块放置房子。,1<=n<=10,1,1
1867,129,3,166,题库,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个下标从开始的整数数组和，长度都是。你可以选择两个整数和，其中，接着两个子数组和。你可以选择执行上述操作或不执行任何操作。数组的取和中的最大值，其中是数组中所有元素之和。返回。是数组中连续的一个元素序列。表示子数组包含中下标和之间的元素下标和对应元素。,"例如，设nums1=[1,2,3,4,5]和nums2=[11,12,13,14,15]，整数选择left=1和right=2，那么nums1会变为[1,,4,5]而nums2会变为[11,2,3,14,15]n==nums1.length==nums2.length1<=n<=101<=nums1[i],nums2[i]<=10",1,2
1868,156,2,181,题库,1,1,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,存在一棵无向连通树，树中有编号从到的个节点，以及条边。给你一个下标从开始的整数数组，长度为，其中表示第个节点的值。另给你一个二维整数数组，长度为，其中表示树中存在一条位于节点和之间的边。删除树中两条的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：返回在给定树上执行任意删除边方案可能的分数。,"例如，三个组件的节点值分别是：[4,5,7][1,9]和[3,3,3]。三个异或值分别是4^5^7=1^9=和3^3^3=。最大异或值是，最小异或值是，分数是8-3=5n==nums.length3<=n<=10001<=nums[i]<=10edges.length==n-1edges[i].length==20<=a,b<n!=bedges表示一棵有效的树",1,4
1869,42,2,201,题库,1,0,1,0,0,0,0,1,0,0,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你字符串和，分别表示一个加密密钥和一段加密消息。解密的步骤如下：返回解密后的消息。,"例如，key=""hap（实际的加密密钥会包含字母表中每个字母至少一次），据此，可以得到部分对照表（'h'->'a''a'->'b''p'->'c''y'->'d''b'->'e''o'->'f'26<=key.length<=2000key由小写英文字母及''组成key包含英文字母表中每个字符（'a'到'z'至少一次1<=message.length<=2000message由小写英文字母和''组成",1,2
1870,101,2,54,题库,3,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数：和，表示矩阵的维数。另给你一个整数链表的头节点。请你生成一个大小为的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵开始、按顺序填充。如果还存在剩余的空格，则用填充。返回生成的矩阵。,"1<=m,n<=101<=m*n<=10链表中节点数目在范围[1,m*n]0<=Node.val<=1000",1,4
1871,146,2,28,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,在第天，有一个人发现了一个秘密。给你一个整数，表示每个人会在发现秘密后的天之后，给一个新的人秘密。同时给你一个整数，表示每个人在发现秘密天之后会这个秘密。一个人在忘记秘密那一天及之后的日子里分享秘密。给你一个整数，请你返回在第天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对后返回。,2<=n<=10001<=delay<forget<=n,1,3
1872,123,2,70,题库,2,4,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的整数网格图，你可以从一个格子移动到个方向相邻的任意一个格子。请你返回在网格图中从格子出发，达到格子，且路径中的数字是的路径数目。由于答案可能会很大，请将结果对后返回。如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。,"m==grid.lengthn==grid[i].length1<=m,n<=10001<=m*n<=101<=grid[i][j]<=10",1,8
1873,65,2,179,题库,0,1,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一棵的根，这棵树有以下特征：一个节点的值方式如下：返回根节点的布尔运算值。是每个节点有个或者个孩子的二叉树。是没有孩子的节点。,"叶子节点要么值为要么值为，其中表示False表示True非叶子节点要么值为要么值为，其中表示逻辑或表示逻辑与AND如果节点是个叶子节点，那么节点的为它本身，即True或者False否则，两个孩子的节点值，然后将该节点的运算符对两个孩子值进行树中节点数目在[1,1000]之间。0<=Node.val<=3每个节点的孩子数为或叶子节点的值为或非叶子节点的值为或",1,3
1874,232,2,114,题库,2,1,0,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始长度为的整数数组，其中表示第辆公交车的出发时间。同时给你一个下标从开始长度为的整数数组，其中表示第位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。给你一个整数，表示每辆公交车能容纳的乘客数目。每位乘客都会搭乘下一辆有座位的公交车。如果你在时刻到达，公交在时刻出发，满足且公交没有满，那么你可以搭乘这一辆公交。到达的乘客优先上车。返回你可以搭乘公交车的最晚到达公交站时间。你跟别的乘客同时刻到达。数组和不一定是有序的。,"n==buses.lengthm==passengers.length1<=n,m,capacity<=102<=buses[i],passengers[i]<=10buses中的元素互不相同passengers中的元素互不相同",1,4
1875,121,2,73,题库,2,0,1,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个下标从开始的整数数组和，长度为。数组和的定义为所有满足的之和。同时给你两个正整数和。你可以将中的任意元素或者至多次。类似的，你可以将中的任意元素或者至多次。请你返回修改数组至多次且修改数组至多次后的最小。你可以将数组中的元素变成整数。,"n==nums1.length==nums2.length1<=n<=100<=nums1[i],nums2[i]<=100<=k1,k2<=10",1,4
1876,77,2,42,题库,1,0,2,1,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数。找到长度为的子数组，满足数组中元素都。请你返回满足要求的子数组的。如果没有这样的子数组，返回。是数组中一段连续非空的元素序列。,"1<=nums.length<=101<=nums[i],threshold<=10",1,4
1877,103,3,33,题库,2,1,1,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满杯类型的水或者杯任意类型的水。给你一个下标从开始、长度为的整数数组，其中、和分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的秒数。,amount.length==30<=amount[i]<=100,1,4
1878,19,1,172,题库,0,0,2,0,0,0,1,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现有一个包含所有正整数的集合。实现类：,SmallestInfiniteSet()初始化SmallestInfiniteSet对象以包含正整数。intpopSmallest()并返回该无限集中的最小整数。voidaddBack(intnum)如果正整数num存在于无限集中，则将一个num到该无限集中。1<=num<=1000最多调用popSmallest和addBack方法1000,1,3
1879,64,3,155,题库,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串和，长度均为。每个字符串由字符、和组成，其中：如果在移动字符串中的片段任意次之后可以得到字符串，返回；否则，返回。,字符'L'和'R'表示片段，其中片段'L'只有在其左侧直接存在一个时才能向移动，而片段'R'只有在其右侧直接存在一个时才能向移动。字符'_'表示可以被'L'或'R'片段占据的空位。n==start.length==target.length1<=n<=10start和target由字符'L''R'和'_'组成,1,2
1880,83,2,89,题库,0,1,0,0,0,3,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个整数和，用于描述一个。对于下标从开始、长度为的整数数组，如果满足以下条件，则认为该数组是一个：返回长度为的理想数组的数目。由于答案可能很大，返回对取余的结果。,每个arr[i]都是从到maxValue范围内的一个值，其中0<=i<n每个arr[i]都可以被arr[i-1]整除，其中0<i<n2<=n<=101<=maxValue<=10,1,4
1881,106,3,62,题库,1,0,1,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组。在一步操作中，你可以执行以下步骤：请你在上多次执行此操作直到无法继续执行。返回一个下标从开始、长度为的整数数组作为答案，其中是形成的数对数目，是对尽可能执行上述操作后剩下的整数数目。,nums选出相等的整数nums中移除这两个整数，形成一个1<=nums.length<=1000<=nums[i]<=100,1,3
1882,74,2,32,题库,2,0,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，数组中的元素都是整数。请你选出两个下标和（），且的数位和与的数位和相等。请你找出所有满足条件的下标和，找出并返回可以得到的,1<=nums.length<=101<=nums[i]<=10,1,4
1883,110,2,300,题库,4,2,1,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串数组，其中每个字符串且只包含数字。再给你一个下标从开始的二维整数数组，其中。对于每个，你需要：请你返回一个长度与相等的数组，其中是第次查询的结果。你能使用解决此问题吗？这种解法的复杂度又是多少？,nums中每个数字到剩下最右边trim个数位。在裁剪过后的数字中，找到nums中第小数字对应的。如果两个裁剪后数字一样大，那么下标的数字视为更小的数字。nums中每个数字恢复到原本字符串。裁剪到剩下最右边个数位的意思是不断删除最左边的数位，直到剩下个数位。nums中的字符串可能会有前导0。1<=nums.length<=1001<=nums[i].length<=100nums[i]只包含数字。所有nums[i].length的长度1<=queries.length<=100queries[i].length==21<=k<=nums.length1<=trim<=nums[0].length,1,7
1884,77,2,64,题库,2,0,1,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个正整数数组和。你可以从中删除任意数目的元素。请你返回使中元素可以整除中所有元素的删除次数。如果无法得到这样的元素，返回。如果，那么我们说整数整除。,"1<=nums.length,numsDivide.length<=101<=nums[i],numsDivide[i]<=10",1,5
1885,89,3,83,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组和一个字符数组。你有张扑克牌，第张牌大小为，花色为。下述是从好到坏你可能持有的：请你返回一个字符串，表示给定的5张牌中，你能组成的。返回的字符串需与题目描述相同。,ranks.length==suits.length==51<=ranks[i]<=13'a'<=suits[i]<='d'任意两张扑克牌不会同时有相同的大小和花色。,1,3
1886,38,3,34,题库,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，返回全部为的数目。是一个数组中一段连续非空元素组成的序列。,1<=nums.length<=10-10<=nums[i]<=10,1,2
1887,28,1,237,题库,0,0,3,0,0,0,1,0,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个数字容器系统，可以实现以下功能：请你实现一个类：,"在系统中给定下标处或者一个数字。系统中给定数字的最小下标。NumberContainers()初始化数字容器系统。voidchange(intindex,intnumber)在下标index处填入number。如果该下标index处已经有数字了，那么用number替换该数字。intfind(intnumber)返回给定数字number在系统中的最小下标。如果系统中没有number，那么返回1<=index,number<=10调用change和find的总次数不超过次。",1,4
1888,112,3,41,题库,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的整数数组和一个整数。你扔一个面的骰子次，骰子的每个面分别是到，其中第次扔得到的数字是。请你返回从中得到的骰子子序列的长度。扔一个面的骰子次得到的是一个长度为的。，子序列只需要保持在原数组中的顺序，不需要连续。,n==rolls.length1<=n<=101<=rolls[i]<=k<=10,1,3
1889,34,2,91,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由小写英文字母组成的字符串，请你找出并返回第一个出现的字母。,如果的第二次出现比的第二次出现在字符串中的位置更靠前，则认为字母在字母之前出现两次。包含至少一个出现两次的字母。2<=s.length<=100由小写英文字母组成包含至少一个重复字母,1,3
1890,72,2,56,题库,3,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、大小为的整数矩阵，返回满足行和列相等的行列对的数目如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。,n==grid.length==grid[i].length1<=n<=2001<=grid[i][j]<=10,1,4
1891,95,1,595,题库,0,0,3,0,0,0,1,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个支持下述操作的食物评分系统：实现类：注意，字符串的字典序比字符串更小的前提是：在字典中出现的位置在之前，也就是说，要么是的前缀，或者在满足的第一个位置处，在字母表中出现的位置在之前。,"系统中列出的某种食物的评分。返回系统中某一类烹饪方式下评分最高的食物。FoodRatings(String[]foods,String[]cuisines,int[]ratings)初始化系统。食物由foodscuisines和ratings描述，长度均为foods[i]是第种食物的名字。cuisines[i]是第种食物的烹饪方式。ratings[i]是第种食物的最初评分。voidchangeRating(Stringfood,intnewRating)修改名字为food的食物的评分。StringhighestRated(Stringcuisine)返回指定烹饪方式cuisine下评分最高的食物的名字。如果存在并列，返回字典序较小的名字。1<=n<=2*10n==foods.length==cuisines.length==ratings.length1<=foods[i].length,cuisines[i].length<=10foods[i]cuisines[i]由小写英文字母组成1<=ratings[i]<=10foods中的所有字符串互不相同在对changeRating的所有调用中，food是系统中食物的名字。在对highestRated的所有调用中，cuisine是系统中至少一种食物的烹饪方式。最多调用changeRating和highestRated2*10",1,4
1892,97,2,119,题库,1,1,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的正整数数组和一个正整数。如果满足下述条件，则数对是：返回优质数对的数目。如果或者，则认为和是不同的两个数对。例如，和不同。如果在数组中至少出现，则满足的数对也可以是优质数对。,num1和num2在数组nums中存在。num1ORnum2和num1ANDnum2的二进制表示中值为的位数之和大于等于，其中是按位操作，而AND是按位操作。1<=nums.length<=101<=nums[i]<=101<=k<=60,1,4
1893,41,1,0,题库,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,表:查询每位老师在大学里教授的科目种类的数量。以返回结果表。查询结果格式示例如下。,,0,1
1894,40,2,71,题库,3,1,2,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个非负整数数组。在一步操作中，你必须：返回使中所有元素都等于需要的操作数。,选出一个正整数需要小于或等于nums中的元素。nums中的每个正整数都减去1<=nums.length<=1000<=nums[i]<=100,1,6
1895,66,2,120,题库,1,2,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，表示大学中一些学生的成绩。你打算将学生分为一些的非空分组，其中分组间的顺序满足以下全部条件：返回可以形成的组数。,个分组中的学生总成绩第(i+1)个分组中的学生总成绩，对所有组均成立（除了最后一组）。个分组中的学生总数第(i+1)个分组中的学生总数，对所有组均成立（除了最后一组）。1<=grades.length<=101<=grades[i]<=10,1,4
1896,148,2,64,题库,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个个节点的，节点编号为到，每个节点有一条出边。有向图用大小为下标从开始的数组表示，表示节点有一条有向边指向。如果节点没有出边，那么。同时给你两个节点和。请你返回一个从和都能到达节点的编号，使节点和节点到这个节点的距离。如果有多个答案，请返回的节点编号。如果答案不存在，返回。注意可能包含环。,"n==edges.length2<=n<=10-1<=edges[i]<nedges[i]!=i0<=node1,node2<n",1,2
1897,111,2,48,题库,0,1,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个节点的，节点编号为到，其中每个节点有一条出边。图用一个大小为下标从开始的数组表示，节点到节点之间有一条有向边。如果节点没有出边，那么。请你返回图中的环，如果没有任何环，请返回。一个环指的是起点和终点是节点的路径。,n==edges.length2<=n<=10-1<=edges[i]<nedges[i]!=i,1,3
1898,66,3,199,题库,2,0,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个二维整数数组和，表示两个物品集合。每个数组有以下特质：请你返回一个二维数组，其中，是所有价值为物品的。应该按价值排序后返回。,"items[i]=[value,weight其中value表示第件物品的weight表示第件物品的items中每件物品的价值都是唯一的1<=items1.length,items2.length<=1000items1[i].length==items2[i].length==21<=value,weight<=1000items1中每个value都是唯一的items2中每个value都是唯一的",1,4
1899,38,2,32,题库,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。如果且，那么我们称是一个。请你返回中的总数目。,1<=nums.length<=101<=nums[i]<=10,1,2
1900,119,2,74,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的正整数数组，表示需要完成的任务，其中表示第件任务的。同时给你一个正整数，表示一个任务完成，另一个类型任务完成前需要间隔的天数。在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：请你返回完成所有任务所需的天数。,完成tasks中的下一个任务休息一天1<=tasks.length<=101<=tasks[i]<=101<=space<=tasks.length,1,3
1901,84,2,89,题库,1,1,0,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下表从开始的整数数组。每次操作中，你可以将数组中任何一个元素替换为和为该元素的数字。请你执行上述操作，将数组变成元素按顺序排列的数组，并返回所需的最少操作次数。,"比方说，nums=[5,6,7]。一次操作中，我们可以将nums[1]替换成和，将nums转变成[5,2,4,7]1<=nums.length<=101<=nums[i]<=10",1,3
1902,49,2,98,题库,2,0,1,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始、的整数数组和一个正整数。如果满足下述全部条件，则三元组就是一个：返回不同的数目,i<j<knums[j]-nums[i]==diffnums[k]-nums[j]==diff3<=nums.length<=2000<=nums[i]<=2001<=diff<=50nums递增,1,4
1903,115,2,126,题库,1,2,3,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现有一棵由个节点组成的无向树，节点编号从到，共有条边。给你一个二维整数数组，长度为，其中表示树中节点和之间存在一条边。另给你一个整数数组表示节点。在不访问受限节点的前提下，返回你可以从节点到达的节点数目注意，节点会标记为受限节点。,"2<=n<=10edges.length==n-1edges[i].length==20<=a,b<n!=bedges表示一棵有效的树1<=restricted.length<n1<=restricted[i]<nrestricted中的所有值互不相同",1,6
1904,91,2,32,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，你必须将数组划分为一个或多个子数组。如果获得的这些子数组中每个都能满足下述条件，则可以称其为数组的一种划分：如果数组存在一种有效划分，返回，否则，返回。,2<=nums.length<=101<=nums[i]<=10,1,2
1905,147,2,66,题库,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由小写字母组成的字符串，和一个整数。如果满足下述条件，则可以将字符串视作是：返回理想字符串的长度。字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。字母表顺序不会循环。例如，和在字母表中位次的绝对差值是，而不是。,是字符串的一个子序列。中每两个字母在字母表中位次的绝对差值小于或等于1<=s.length<=100<=k<=25由小写英文字母组成,1,3
1906,60,2,102,题库,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个大小为的整数矩阵。生成一个大小为的整数矩阵，并满足：换句话说，我们希望找出中每个矩阵中的最大值。返回生成的矩阵。,maxLocal[i][j]等于grid中以i+1行和j+1列为中心的3x3矩阵中的最大值n==grid.length==grid[i].length3<=n<=1001<=grid[i][j]<=100,1,2
1907,122,2,47,题库,0,0,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个有向图，图中有个节点，节点编号从到，其中每个节点都出边。图由一个下标从开始、长度为的整数数组表示，其中表示存在一条从节点到节点的边。节点的定义为：所有存在一条指向节点的边的节点的总和。返回最高的节点。如果多个节点的相同，返回编号的那个。,n==edges.length2<=n<=100<=edges[i]<nedges[i]!=i,1,2
1908,78,2,135,题库,1,2,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你下标从开始、长度为的字符串，它包含两种字符，表示，表示。你需要构造一个下标从开始长度为的字符串，且它要满足以下条件：请你返回满足上述条件字典序的字符串。,num包含数字'1'到'9'，其中每个数字使用一次。如果pattern[i]=='I'，那么num[i]<num[i+1]如果pattern[i]=='D'，那么num[i]>num[i+1]1<=pattern.length<=8pattern只包含字符'I'和'D',1,4
1909,45,3,10,题库,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,如果一个正整数每一个数位都是的，我们称它是。给你一个整数，请你返回区间之间特殊整数的数目。,1<=n<=2*10,1,2
1910,106,2,54,题库,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个长度为下标从开始的字符串，要么是要么是，表示第块的颜色。字符和分别表示白色和黑色。给你一个整数，表示想要黑色块的数目。每一次操作中，你可以选择一个白色块将它黑色块。请你返回至少出现连续个黑色块的操作次数。,n==blocks.length1<=n<=100blocks[i]要么是'W'，要么是'B'1<=k<=n,1,2
1911,78,2,34,题库,2,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个二进制字符串。在一秒之中，子字符串被替换成。这个过程持续进行到没有存在。请你返回完成这个过程所需要的秒数。你能以O(n)的时间复杂度解决这个问题吗？,1<=s.length<=1000s[i]要么是'0'，要么是'1',1,3
1912,190,2,97,题库,2,0,0,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个小写英文字母组成的字符串和一个二维整数数组，其中。对于每个，将中从下标到下标（两者都包含）所有字符都进行移位运算，如果将字符向后移位，如果将字符向前移位。将一个字符移位的意思是将这个字符用字母表中字母替换（字母表视为环绕的，所以变成）。类似的，将一个字符移位的意思是将这个字符用字母表中字母替换（字母表是环绕的，所以变成）。请你返回对进行所有移位操作以后得到的最终字符串。,"1<=s.length,shifts.length<=5*10shifts[i].length==30<=start<=end<s.length0<=direction<=1只包含小写英文字母。",1,3
1913,123,2,101,题库,1,0,1,1,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个下标从开始的整数数组和，两者长度都为。对于第个查询，中位于下标处的元素被删除，将分割成更小的子段。一个是中连续整数形成的序列。是子段中所有元素的和。请你返回一个长度为的整数数组，其中是第次删除操作以后的子段和。一个下标至多只会被删除一次。,n==nums.length==removeQueries.length1<=n<=101<=nums[i]<=100<=removeQueries[i]<nremoveQueries中所有数字互不相同,1,4
1914,214,2,107,题库,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,你正在参加一场比赛，给你两个整数和分别表示你的初始精力和初始经验。另给你两个下标从开始的整数数组和，长度均为。你将会对上个对手。第个对手的精力和经验分别用和表示。当你对上对手时，需要在经验和精力上都超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。击败第个对手会使你的经验，但会将你的精力。在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加1将精力增加1。返回击败全部个对手需要训练的小时数目。,"n==energy.length==experience.length1<=n<=1001<=initialEnergy,initialExperience,energy[i],experience[i]<=100",1,2
1915,50,2,62,题库,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个仅由数字（）组成的字符串。请你找出能够使用中数字形成的整数，并以字符串形式返回。该整数不含。,使用num中的所有数字，但你必须使用一个数字。数字可以重新排序。1<=num.length<=10num由数字（0-9）组成,1,3
1916,83,2,79,题库,0,2,2,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，二叉树中节点的值。另给你一个整数。在第分钟，将会从值为的节点开始爆发。每分钟，如果节点满足以下全部条件，就会被感染：返回感染整棵树需要的分钟数,"节点此前还没有感染。节点与一个已感染节点相邻。树中节点的数目在范围[1,101<=Node.val<=10每个节点的值互不相同树中必定存在值为start的节点",1,4
1917,127,2,54,题库,2,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,给你一个整数数组和一个整数。你可以选择数组的任一并且对其全部元素求和。数组的定义为：可以获得的第个子序列和（子序列和允许出现重复）返回数组的。子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。空子序列的和视作。,"n==nums.length1<=n<=10-10<=nums[i]<=101<=k<=min(2000,2",1,3
1918,91,2,68,题库,2,2,0,0,1,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个长度为的整数数组，和一个长度为的整数数组。返回一个长度为的数组，其中是中元素之和小于等于的的长度。是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。,"n==nums.lengthm==queries.length1<=n,m<=10001<=nums[i],queries[i]<=10",1,5
1919,38,2,104,题库,2,0,1,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个包含若干星号的字符串。在一步操作中，你可以：返回移除星号之后的字符串,选中中的一个星号。移除星号最近的那个非星号字符，并移除该星号自身。生成的输入保证总是可以执行题面中描述的操作。可以证明结果字符串是唯一的。1<=s.length<=10由小写英文字母和星号组成可以执行上述操作,1,3
1920,249,2,118,题库,2,0,0,0,1,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串数组，其中表示第个房子的垃圾集合。只包含字符，和，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾单位的任何一种垃圾都需要花费分钟。同时给你一个下标从开始的整数数组，其中是垃圾车从房子行驶到房子需要的分钟数。城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子出发，到达每一栋房子。但它们到达所有的房子。任何时刻只有垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车做任何事情。请你返回收拾完所有垃圾需要花费的总分钟数。,2<=garbage.length<=10garbage[i]只包含字母'M''P'和'G'1<=garbage[i].length<=10travel.length==garbage.length-11<=travel[i]<=100,1,3
1921,97,2,353,题库,2,0,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，同时给你：两个数组里的整数都是到之间的数字。你需要构造一个的矩阵，到每个数字需要。剩余的数字都是。矩阵还需要满足以下条件：返回满足上述要求的矩阵。如果不存在答案，返回一个空的矩阵。,"一个大小为的二维整数数组rowConditions，其中rowConditions[i]=[above,below一个大小为的二维整数数组colConditions，其中colConditions[i]=[left,right对于所有到n-1之间的下标，数字above所在的必须在数字below所在行的上面。对于所有到m-1之间的下标，数字left所在的必须在数字right所在列的左边。2<=k<=4001<=rowConditions.length,colConditions.length<=10rowConditions[i].length==colConditions[i].length==21<=above,below,left,right<=kabove!=belowleft!=right",1,4
1922,95,3,36,题库,1,0,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组，判断是否存在长度为的子数组且它们的相等。注意，这两个子数组起始位置的下标必须。如果这样的子数组存在，请返回，否则返回。是一个数组中一段连续非空的元素组成的序列。,2<=nums.length<=1000-10<=nums[i]<=10,1,2
1923,94,2,8,题库,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果一个整数在进制下（为到之间的所有整数）对应的字符串都是，那么我们称这个数是的。给你一个整数，如果是的，请返回，否则返回。如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是。,4<=n<=10,1,3
1924,82,2,64,题库,3,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的二进制矩阵和一个整数，表示你需要选出的列数。如果一行中，所有的都被你选中的列所覆盖，那么我们称这一行了。请你返回在选择列的情况下，的行数为多少。,"m==mat.lengthn==mat[i].length1<=m,n<=12mat[i][j]要么是要么是1<=cols<=n",1,5
1925,125,2,102,题库,1,1,2,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有个机器人，给你两个下标从开始的整数数组和，两者长度都为。第个机器人充电时间为单位时间，花费单位时间运行。再给你一个整数。运行个机器人是，其中是这个机器人中最大充电时间，是这个机器人的运行时间之和。请你返回在的前提下，你可以运行的机器人数目为多少。,"chargeTimes.length==runningCosts.length==n1<=n<=5*101<=chargeTimes[i],runningCosts[i]<=101<=budget<=10",1,6
1926,150,2,74,题库,2,0,1,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你一个下标从开始的字符串，该字符串仅由小写英文字母组成，中的每个字母都出现。另给你一个下标从开始、长度为的的整数数组。字母表中的每个字母按从到依次编号（即，,,,...,）。在一个字符串中，第个字母的两次出现之间的字母数量是。如果第个字母没有在中出现，那么可以。如果是一个字符串，返回；否则，返回。",2<=s.length<=52仅由小写英文字母组成中的每个字母恰好出现两次distance.length==260<=distance[i]<=50,1,3
1927,120,2,26,题库,0,1,0,0,0,2,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和。最初，你站在数轴上位置处。在一步移动中，你可以向左或者向右移动一个位置。给你一个正整数，返回从出发、移动步并到达的方法数目。由于答案可能会很大，返回对的结果。如果所执行移动的顺序不完全相同，则认为两种方法不同。数轴包含负整数,"1<=startPos,endPos,k<=1000",1,3
1928,89,2,32,题库,1,0,0,0,2,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由整数组成的数组。如果的子数组中位于位置的每对元素按位运算的结果等于，则称该子数组为子数组。返回的优雅子数组的长度。是数组中的一个部分。长度为的子数组始终视作优雅子数组。,1<=nums.length<=101<=nums[i]<=10,1,3
1929,115,2,83,题库,2,0,1,0,0,0,0,1,0,0,1,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，共有编号从到的个会议室。给你一个二维整数数组，其中表示一场会议将会在时间区间举办。所有的值。会议将会按以下方式分配给会议室：返回举办最多次会议的房间。如果存在多个房间满足此条件，则返回编号的房间。是和之间的区间，但。,1<=n<=1001<=meetings.length<=10meetings[i].length==20<=start<end<=5*10start的所有值互不相同,1,3
1930,59,3,34,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，返回出现最频繁的偶数元素。如果存在多个满足条件的元素，只需要返回的一个。如果不存在这样的元素，返回。,1<=nums.length<=20000<=nums[i]<=10,1,3
1931,122,2,25,题库,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个字符串，请你将该字符串划分成一个或多个，并满足每个子字符串中的字符都是的。也就是说，在单个子字符串中，字母的出现次数都不超过。满足题目要求的情况下，返回需要划分多少个子字符串注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。,1<=s.length<=10仅由小写英文字母组成,1,3
1932,120,2,63,题库,2,1,1,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中表示区间。你需要将划分为一个或者多个区间，每个区间属于一个组，且同一个组中任意两个区间。请你返回需要划分成多少个组。如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是的。比方说区间和相交。,1<=intervals.length<=10intervals[i].length==21<=left<=right<=10,1,6
1933,75,3,55,题库,1,2,2,2,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数。找到中满足以下要求的最长子序列：请你返回满足上述要求的的长度。是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。,"子序列严格递增子序列中相邻元素的差值不超过1<=nums.length<=101<=nums[i],k<=10",1,7
1934,149,2,67,题库,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,Alice和Bob计划分别去罗马开会。给你四个字符串，，和。Alice会在日期到之间在城市里（），而Bob在日期到之间在城市里（）。每个字符串都包含5个字符，格式为，对应着一个日期的月和日。请你返回Alice和Bob同时在罗马的天数。你可以假设所有日期都在自然年，而且闰年。每个月份的天数分别为：。,"所有日期的格式均为""MM-DD""Alice和Bob的到达日期都早于或等于他们的离开日期。题目测试用例所给出的日期均为非闰年的有效日期。",1,2
1935,146,2,66,题库,2,1,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，其中表示第名运动员的值，同时给你一个下标从开始的整数数组，其中表示第名训练师的。如果第名运动员的能力值第名训练师的能力值，那么第名运动员可以第名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。请你返回满足上述要求和的匹配数。,"1<=players.length,trainers.length<=101<=players[i],trainers[j]<=10",1,4
1936,167,2,119,题库,1,1,0,0,2,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为下标从开始的数组，数组中所有数字均为非负整数。对于到之间的每一个下标，你需要找出中一个非空子数组，它的起始位置为（包含这个位置），同时有的。一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。请你返回一个大小为的整数数组，其中是开始位置为，按位或运算结果最大，且子数组的长度。是数组里一段连续非空元素组成的序列。,换言之，令表示子数组nums[i...j]的按位或运算的结果，你需要找到一个起始位置为的最小子数组，这个子数组的按位或运算的结果等于max(B，其中i<=k<=n-1n==nums.length1<=n<=100<=nums[i]<=10,1,4
1937,121,2,71,题库,2,1,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的二维整数数组，其中。数组描述了若干笔交易。其中每笔交易必须以恰好完成一次。在任意一个时刻，你有一定数目的钱，为了完成交易，这个条件必须为真。执行交易后，你的钱数变成。请你返回交易顺序下，你都能完成所有交易的最少钱数是多少。,"1<=transactions.length<=10transactions[i].length==20<=cost,cashback<=10",1,3
1938,25,2,9,题库,0,0,0,0,0,2,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你一个正整数，返回和的最小公倍数（正整数）。
",1<=n<=150,1,2
1939,71,2,58,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,是由字母表中连续字母组成的字符串。换句话说，字符串的任意子字符串都是。给你一个仅由小写英文字母组成的字符串，返回其的字母序连续子字符串的长度。,"例如，""abc""是一个字母序连续字符串，而""acb""和""za""不是。1<=s.length<=10由小写英文字母组成",1,1
1940,95,3,103,题库,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点，请你反转这棵树中每个层的节点值。反转后，返回树的根节点。二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。节点的等于该节点到根节点之间的边数。,"例如，假设第3层的节点值是[2,1,3,4,7,11,29,18]，那么反转后它应该变成[18,29,11,7,4,3,1,2]树中的节点数目在范围[1,20<=Node.val<=10root是一棵二叉树",1,4
1941,75,2,130,题库,2,0,0,1,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的数组，该数组由字符串组成。定义字符串的等于以作为的的数目。返回一个长度为的数组，其中是的每个非空前缀的分数字符串视作它自身的一个前缀。,"例如，如果words=[""a"",""ab"",""abc"",""cab""]，那么""ab""的分数是，因为""ab""是""ab""和""abc""的一个前缀。1<=words.length<=10001<=words[i].length<=1000words[i]由小写英文字母组成",1,4
1942,70,2,112,题库,3,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组，和一个由的正整数组成的数组。两个数组的长度均为。对于每个下标，和表示第个人的名字和身高。请按身高顺序返回对应的名字数组。,n==names.length==heights.length1<=n<=101<=names[i].length<=201<=heights[i]<=10names[i]由大小写英文字母组成heights中的所有值互不相同,1,4
1943,82,2,89,题库,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组。考虑中进行运算得到的值的子数组。返回满足要求的子数组的长度。数组的按位与就是对数组中的所有数字进行按位与运算。是数组中的一个连续元素序列。,换句话说，令是nums子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于的子数组。1<=nums.length<=101<=nums[i]<=10,0,3
1944,64,2,67,题库,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为下标从开始的整数数组和一个正整数。对于之间的一个下标，如果它满足以下条件，我们就称它为一个下标：按返回所有好下标。,下标的个元素是非递增的下标的个元素是非递减的n==nums.length3<=n<=101<=nums[i]<=101<=k<=n/2,1,3
1945,159,3,98,题库,1,0,2,1,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一棵个节点的树（连通无向无环的图），节点编号从到且恰好有条边。给你一个长度为下标从开始的整数数组，分别表示每个节点的值。同时给你一个二维整数数组，其中表示节点和之间有一条边。一条需要满足以下条件：请你返回不同好路径的数目。注意，一条路径和它反向的路径算作路径。比方说，与视为同一条路径。单个节点也视为一条合法路径。,"n==vals.length1<=n<=3*100<=vals[i]<=10edges.length==n-1edges[i].length==20<=a,b<n!=bedges表示一棵合法的树。",1,4
1946,92,2,72,题库,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串，字符串只包含小写英文字母。你需要选择下标并下标处的字符，使得中剩余每个字母出现相同。如果删除一个字母后，中剩余所有字母的出现频率都相同，那么返回，否则返回。,字母的是这个字母在字符串中出现的次数。恰好删除一个字母，不能一个字母都不删除。2<=word.length<=100word只包含小写英文字母。,1,3
1947,124,1,166,题库,0,1,2,3,0,0,1,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个个视频的上传序列，每个视频编号为到之间的数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算。如果到之间的视频全部都已经被上传到服务器，那么我们称是上传前缀。最长上传前缀指的是符合定义的中的。

请你实现类：",LUPrefix(intn)初始化一个个视频的流对象。voidupload(intvideo)上传video到服务器。intlongest()返回上述定义的最长上传前缀的长度。1<=n<=101<=video<=10video中所有值互不相同upload和longest总调用次数至多不超过2*10次。至少会调用longest一次。,1,7
1948,76,2,56,题库,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个下标从开始的数组和，两个数组都只包含非负整数。请你求出另外一个数组，包含和中的异或和（中每个整数都跟中每个整数匹配一次）。请你返回中所有整数的。,"1<=nums1.length,nums2.length<=100<=nums1[i],nums2[j]<=10",1,3
1949,55,2,128,题库,1,3,1,2,0,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个下标从开始的整数数组和，两个数组的大小都为，同时给你一个整数，统计满足以下条件的：请你返回满足条件的。,"0<=i<j<=n-1nums1[i]-nums1[j]<=nums2[i]-nums2[j]+diffn==nums1.length==nums2.length2<=n<=10-10<=nums1[i],nums2[i]<=10-10<=diff<=10",1,7
1950,38,2,12,题库,1,0,0,0,0,2,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你两个正整数和，返回和的因子的数目。如果可以同时整除和，则认为是和的一个。,"1<=a,b<=1000",1,3
1951,60,2,59,题库,2,0,0,0,1,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个大小为的整数矩阵。按以下形式将矩阵的一部分定义为一个：返回沙漏中元素的总和。沙漏无法旋转且必须整个包含在矩阵中。,"m==grid.lengthn==grid[i].length3<=m,n<=1500<=grid[i][j]<=10",1,3
1952,69,2,39,题库,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个正整数和，找出满足下述条件的整数：注意是按位异或运算。返回整数。题目保证，对于生成的测试用例，是的。整数的是其二进制表示中的数目。,"的置位数和num2相同，且xXORnum1的值1<=num1,num2<=10",1,2
1953,93,3,83,题库,2,1,0,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个仅由小写英文字母组成的字符串。在一步操作中，你可以：例如，如果，那么在一步操作中，你可以删除的前两个字母得到，因为的前两个字母和接下来的两个字母都等于。返回删除所需的最大操作数。,删除整个字符串，或者对于满足1<=i<=s.length/2的任意，如果中的个字母和接下来的个字母，删除个字母。1<=s.length<=4000仅由小写英文字母组成,1,5
1954,113,3,151,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,共有位员工，每位员工都有一个从到的唯一id。给你一个二维整数数组，其中：注意，第个任务在第个任务结束后立即开始，且第个任务从时刻开始。返回处理用时最长的那个任务的员工的id。如果存在两个或多个员工同时满足，则返回几人中的id。,是处理第个任务的员工的id，且leaveTime是员工完成第个任务的时刻。所有leaveTime的值都是的。2<=n<=5001<=logs.length<=500logs[i].length==20<=id<=n-11<=leaveTime<=500!=idi+1leaveTime按严格递增顺序排列,1,1
1955,59,2,64,题库,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的数组。找出并返回满足下述条件且长度为的数组：注意表示（bitwise-xor）运算。可以证明答案是的。,pref[i]=arr[0]^arr[1]^...^arr[i]1<=pref.length<=100<=pref[i]<=10,1,2
1956,59,3,97,题库,1,1,2,0,0,0,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串和一个机器人，机器人当前有一个空字符串。执行以下操作之一，直到和请你返回纸上能写出的字典序最小的字符串。,删除字符串的第一个字符，并将该字符给机器人。机器人把这个字符添加到的尾部。删除字符串的最后一个字符，并将该字符给机器人。机器人将该字符写到纸上。1<=s.length<=10只包含小写英文字母。,1,4
1957,80,3,81,题库,2,1,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的整数矩阵和一个整数。你从起点出发，每一步只能往或者往，你想要到达终点。请你返回路径和能被整除的路径数目，由于答案可能很大，返回答案对的结果。,"m==grid.lengthn==grid[i].length1<=m,n<=5*101<=m*n<=5*100<=grid[i][j]<=1001<=k<=50",1,3
1958,116,3,80,题库,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个长度为的字符串，表示一个电子时钟当前的时间，格式为。可能的时间是，可能的时间是。在字符串中，被字符替换掉的数位是，被替换的数字可能是到中的任何一个。请你返回一个整数，将每一个都用到中一个数字替换后，可以得到的有效时间的数目。,"time是一个长度为的有效字符串，格式为""hh:mm""""00""<=hh<=""23""""00""<=mm<=""59""字符串中有的数位是'?'，需要用到之间的数字替换。",1,2
1959,155,2,56,题库,1,0,0,0,2,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个正整数，你需要找到一个下标从开始的数组，它包含数目的的幂，且它们的和为。数组是顺序的。根据前面描述，构造数组的方法是唯一的。同时给你一个下标从开始的二维整数数组，其中，其中表示请你求出满足的所有的乘积。请你返回一个数组，长度与的长度相同，其中是第个查询的答案。由于查询的结果可能非常大，请你将每个都对。,1<=n<=101<=queries.length<=100<=start<=end<powers.length,1,3
1960,63,2,84,题库,1,3,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，它含有个非负整数。每一步操作中，你需要：你可以对数组执行次上述操作，请你返回可以得到的数组中为多少。,选择一个满足1<=i<n的整数，且nums[i]>0nums[i]减1。nums[i-1]加1。n==nums.length2<=n<=100<=nums[i]<=10,1,5
1961,162,2,118,题库,2,1,1,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有一棵个节点的无向树，节点编号为到。给你一个长度为下标从开始的整数数组，其中表示第个节点的值。同时给你一个长度为的二维整数数组，其中表示节点与之间有一条边。你可以一些边，将这棵树分成几个连通块。一个连通块的定义为这个连通块中节点对应的之和。你需要删除一些边，删除后得到的各个连通块的价值都相等。请返回你可以删除的边数为多少。,"1<=n<=2*10nums.length==n1<=nums[i]<=50edges.length==n-1edges[i].length==20<=edges[i][0],edges[i][1]<=n-1edges表示一棵合法的树。",1,5
1962,57,3,50,题库,2,0,1,0,1,0,0,1,0,0,1,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个任何零的整数数组，找出自身与对应的负数都在数组中存在的最大正整数。返回正整数，如果不存在这样的整数，返回。,1<=nums.length<=1000-1000<=nums[i]<=1000nums[i]!=0,1,4
1963,76,2,32,题库,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由整数组成的数组。你必须取出数组中的每个整数，，并将反转后得到的数字添加到数组的末尾。这一操作只针对中原有的整数执行。返回结果数组中整数的数目。,1<=nums.length<=101<=nums[i]<=10,1,3
1964,43,3,10,题库,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数。如果存在某个整数满足，则返回；否则，返回。表示反转每个数位后得到的数字。,0<=num<=10,1,2
1965,62,2,70,题库,1,0,2,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和两个整数以及。的定界子数组是满足下述条件的一个子数组：返回定界子数组的数目。子数组是数组中的一个连续部分。,"子数组中的最小值等于minK子数组中的最大值等于maxK2<=nums.length<=101<=nums[i],minK,maxK<=10",1,4
1966,116,1,174,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个字符串数组和，表示发生在同一天的两个闭区间时间段事件，其中：事件的时间为有效的24小时制且按格式给出。当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现。如果两个事件之间存在冲突，返回；否则，返回。,"event1=[startTime,endTimeevent2=[startTime,endTimeevent1.length==event2.length==2.event1[i].length==event2[i].length==5startTime<=endTimestartTime<=endTime所有事件的时间都按照HH:MM格式给出",1,2
1967,74,2,36,题库,1,0,0,0,0,2,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你统计并返回的子数组中元素的最大公因数等于的子数组数目。是数组中一个连续的非空序列。是能整除数组中所有元素的最大整数。,"1<=nums.length<=10001<=nums[i],k<=10",1,3
1968,64,2,85,题库,2,2,0,0,1,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个下标从开始的数组和，分别包含个整数。你可以执行下面操作次：对第个元素执行一次操作的开销是。请你返回使中所有元素的总开销。,"nums中元素增加或者减小n==nums.length==cost.length1<=n<=101<=nums[i],cost[i]<=10测试用例确保输出不超过2-1。",1,5
1969,107,3,115,题库,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个正整数数组和，两个数组长度相等。在一次操作中，你可以选择两个的下标和，其中，并且：如果两个数组中每个元素出现的频率相等，我们称两个数组是的。请你返回将变得与相似的最少操作次数。测试数据保证一定能变得与相似。,"nums[i]=nums[i]+2nums[j]=nums[j]-2n==nums.length==target.length1<=n<=101<=nums[i],target[i]<=10nums一定可以变得与target相似。",1,3
1970,148,2,100,题库,2,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个字符串数组，每一个字符串长度都相同，令所有字符串的长度都为。每个字符串可以被转化为一个长度为的，其中对于有。注意两个字母的差值定义为它们在字母表中之差，也就是说的位置是，的位置是，的位置是。中所有字符串，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。请你返回中不同的字符串。,"比方说，字符串""acb""的差值整数数组是[2-0,1-2]=[2,-1]3<=words.length<=100n==words[i].length2<=n<=20words[i]只含有小写英文字母。",1,3
1971,148,2,128,题库,2,0,0,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串数组和。数组中所有单词都只包含小写英文字母，且长度都相同。一次中，你可以从中选择一个单词，将任意一个字母修改成任何其他字母。从中找到所有满足以下条件的字符串：两次编辑内，字符串与中某个字符串相同。请你返回中的单词列表，这些单词距离中的单词不超过。单词返回的顺序需要与中原本顺序相同。,"1<=queries.length,dictionary.length<=100n==queries[i].length==dictionary[j].length1<=n<=100所有queries[i]和dictionary[j]都只包含小写英文字母。",1,2
1972,120,3,44,题库,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，它包含若干正整数，表示数轴上你需要摧毁的目标所在的位置。同时给你一个整数。你有一台机器可以摧毁目标。给机器，这台机器会摧毁所有位置在的目标，其中是任意非负整数。你想摧毁中的目标。请你返回在摧毁数目最多的前提下，的。,1<=nums.length<=101<=nums[i]<=101<=space<=10,1,3
1973,95,2,116,题库,2,1,3,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的非负整数数组。对于中每一个整数，你必须找到对应元素的整数。如果满足以下条件，那么我们称它为的整数：如果不存在，那么第二大整数为。请你返回一个整数数组，其中是的第二大整数。,"j>inums[j]>nums[i]恰好存在满足i<k<j且nums[k]>nums[i]比方说，数组[1,2,4,3]中，的第二大整数是的第二大整数是和的第二大整数是1<=nums.length<=100<=nums[i]<=10",1,6
1974,63,2,36,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由正整数组成的整数数组，返回其中可被整除的所有偶数的平均值。注意：个元素的平均值等于个元素再除以，结果到最接近的整数。,1<=nums.length<=10001<=nums[i]<=1000,1,2
1975,143,2,197,题库,3,0,2,0,0,0,0,0,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串数组和，和一个整数数组，所有数组的长度都是。平台上第个视频者是，视频分配的id是，且播放量为。视频创作者的是该创作者的视频的播放量的。请找出流行度创作者以及该创作者播放量的视频的id。返回一个二维字符串数组，其中表示的流行度且其最流行的视频id是，可以按任何顺序返回该结果,"如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的n==creators.length==ids.length==views.length1<=n<=101<=creators[i].length,ids[i].length<=5creators[i]和ids[i]仅由小写英文字母组成0<=views[i]<=10",1,5
1976,77,3,42,题库,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个正整数和。如果某个整数每一位上的数字相加小于或等于，则认为这个整数是一个。找出并返回满足是的最小非负整数。生成的输入保证总可以使变成一个美丽整数。,1<=n<=101<=target<=150生成的输入保证总可以使变成一个美丽整数。,1,2
1977,105,2,213,题库,1,2,2,0,0,0,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一棵的根节点，树中有个节点。每个节点都可以被分配一个从到且互不相同的值。另给你一个长度为的数组。你必须在树上执行个的查询，其中第个查询你需要执行以下操作：返回一个长度为的数组，其中是执行第个查询后树的高度。,"从树中以queries[i]的值作为根节点的子树。题目所用测试用例保证queries[i]等于根节点的值。查询之间是独立的，所以在每个查询执行后，树会回到其状态。树的高度是从根到树中某个节点的最长简单路径中的边数树中节点的数目是2<=n<=101<=Node.val<=n树中的所有值互不相同m==queries.length1<=m<=min(n,101<=queries[i]<=nqueries[i]!=root.val",1,5
1978,107,2,140,题库,2,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的数组，数组大小为，且由整数组成。你需要对数组执行步操作，其中第步操作（从开始计数）要求对中第个元素执行下述指令：在执行完操作后，将所有到数组的。返回结果数组。操作应当执行，而不是一次性全部执行。,"如果nums[i]==nums[i+1]，则nums[i]的值变成原来的倍，nums[i+1]的值变成。否则，跳过这步操作。例如，数组[1,0,2,0,0,1]将所有移动到末尾后变为[1,2,1,0,0,0]2<=nums.length<=20000<=nums[i]<=1000",1,2
1979,90,2,56,题库,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数。请你从中满足下述条件的全部子数组中找出最大子数组和：返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回。是数组中一段连续非空的元素序列。,子数组的长度是子数组中的所有元素各不相同。1<=k<=nums.length<=101<=nums[i]<=10,1,3
1980,69,2,343,题库,2,0,1,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，其中是雇佣第位工人的代价。同时给你两个整数和。我们想根据以下规则恰好雇佣位工人：返回雇佣恰好位工人的总代价。,"总共进行轮雇佣，且每一轮恰好雇佣一位工人。在每一轮雇佣中，从最前面candidates和最后面candidates比方说，costs=[3,2,7,7,1,2]且candidates=2，第一轮雇佣中，我们选择第位工人，因为他的代价最小3,2,7,7,第二轮雇佣，我们选择第位工人，因为他们的代价与第位工人一样都是最小代价，而且下标更小，,7,7,2。注意每一轮雇佣后，剩余工人的下标可能会发生变化。如果剩余员工数目不足candidates人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。一位工人只能被选择一次。1<=costs.length<=101<=costs[i]<=101<=k,candidates<=costs.length",1,4
1981,284,2,247,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,X轴上有一些机器人和工厂。给你一个整数数组，其中是第个机器人的位置。再给你一个二维整数数组，其中，表示第个工厂的位置在，且第个工厂最多可以修理个机器人。每个机器人所在的位置。每个工厂所在的位置也。注意一个机器人可能一开始跟一个工厂在。所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是X轴的正方向，要么是X轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。，你都可以设置机器人的移动方向。你的目标是最小化所有机器人总的移动距离。请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。,"所有机器人移动速度相同。如果两个机器人移动方向相同，它们永远不会碰撞。如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。机器人从位置到位置的移动距离为|y-x|1<=robot.length,factory.length<=100factory[j].length==2-10<=robot[i],position<=100<=limit<=robot.length测试数据保证所有机器人都可以被维修。",1,3
1982,84,2,115,题库,2,0,1,0,1,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始长度为的整数数组。只要空数组，你就重复执行以下步骤：两数和的为。返回上述过程能得到的平均值的数目。，如果最小值或者最大值有重复元素，可以删除任意一个。,找到nums中的最小值，并删除它。找到nums中的最大值，并删除它。计算删除两数的平均值。比方说，和的平均值是(2+3)/2=2.52<=nums.length<=100nums.length是偶数。0<=nums[i]<=100,1,4
1983,131,2,65,题库,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你整数，，和，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：以上操作可以执行任意次。如果通过以上过程得到一个在和之间（包含上下边界）的字符串，那么这个字符串我们称为字符串。请你返回满足以上要求的好字符串数目。由于答案可能很大，请将结果对后返回。,"'0'在字符串末尾添加zero次。'1'在字符串末尾添加one次。1<=low<=high<=101<=zero,one<=low",1,1
1984,123,2,457,题库,1,2,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个个节点的无向树，节点编号为到，树的根结点是号节点。给你一个长度为的二维整数数组，其中，表示节点和在树中有一条边。在每一个节点处有一扇门。同时给你一个都是偶数的数组，其中表示：游戏按照如下规则进行：请你返回Alice朝最优叶子结点移动的净得分。,"如果amount[i]的值是负数，那么它表示打开节点处门扣除的分数。如果amount[i]的值是正数，那么它表示打开节点处门加上的分数。一开始，Alice在节点处，Bob在节点bob处。每一秒钟，Alice和Bob移动到相邻的节点。Alice朝着某个叶子结点移动，Bob朝着节点移动。对于他们之间路径上的每一个如果门已经打开（被另一个人打开），不会有额外加分也不会扣分。如果Alice和Bob到达一个节点，他们会共享这个节点的加分或者扣分。换言之，如果打开这扇门扣分，那么Alice和Bob分别扣c/2分。如果这扇门的加分为，那么他们分别加c/2分。如果Alice到达了一个叶子结点，她会停止移动。类似的，如果Bob到达了节点，他也会停止移动。注意这些事件互相，不会影响另一方移动。2<=n<=10edges.length==n-1edges[i].length==20<=a,b<n!=bedges表示一棵有效的树。1<=bob<namount.length==namount[i]是范围[-10,10之间的一个",1,5
1985,184,2,52,题库,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串和一个正整数。你需要根据将成一个或多个。每个部分的结尾都是，其中用分割出来的总数，用当前部分所在的编号，编号从到依次编号。除此以外，除了最后一部分长度以外，其他每一部分（包括结尾部分）的长度都应该。你需要确保分割后的结果数组，删掉每部分的结尾并连起来后，能够得到。同时，结果数组越短越好。请你返回分割后得到的结果数组。如果无法按要求分割，返回一个空数组。,1<=message.length<=10message只包含小写英文字母和''1<=limit<=10,1,2
1986,83,2,48,题库,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个四舍五入到两位小数的非负浮点数来表示温度，以（）为单位。你需要将摄氏度转换为（）和（），并以数组的形式返回结果。返回数组。与实际答案误差不超过的会视为正确答案,开氏度=摄氏度+273.15华氏度=摄氏度*1.80+32.000<=celsius<=1000,1,1
1987,66,2,38,题库,1,0,0,0,0,2,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你统计并返回的中满足的子数组数目。是数组中一个连续非空的元素序列。是可被所有数组元素整除的最小正整数。,"1<=nums.length<=10001<=nums[i],k<=1000",1,3
1988,81,3,40,题库,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的二叉树的根节点。在一步操作中，你可以选择上任意两个节点，交换这两个节点的值。返回每一层按排序所需的最少操作数目。节点的是该节点和根节点之间的路径的边数。,"树中节点的数目在范围[1,101<=Node.val<=10树中的所有值互不相同",1,3
1989,69,2,52,题库,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串和一个整数。从字符串中选出一组满足下述条件且的子字符串：返回最优方案中能选择的子字符串的数目。是字符串中一个连续的字符序列。,每个子字符串的长度为每个子字符串是一个回文串1<=k<=s.length<=2000仅由小写英文字母组成,1,2
1990,51,2,135,题库,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的正整数数组。请你找出并统计满足下述条件的三元组的数目：返回满足上述条件三元组的数目,0<=i<j<k<nums.lengthnums[i]nums[j]和nums[k]两两不同换句话说：nums[i]!=nums[j]nums[i]!=nums[k]且nums[j]!=nums[k]3<=nums.length<=1001<=nums[i]<=1000,1,2
1991,49,2,154,题库,1,2,2,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个的根节点，和一个由正整数组成、长度为的数组。请你找出一个长度为的答案数组，其中：返回数组。,"min是树中小于等于queries[i]的最大值。如果不存在这样的值，则使用代替。max是树中大于等于queries[i]的最小值。如果不存在这样的值，则使用代替。树中节点的数目在范围[2,101<=Node.val<=10n==queries.length1<=n<=101<=queries[i]<=10",1,5
1992,195,3,80,题库,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从到，且恰好有条路。是首都。给你一个二维整数数组，其中，表示城市和之间有一条。每个城市里有一个代表，他们都要去首都参加一个会议。每座城市里有一辆车。给你一个整数表示每辆车里面座位的数目。城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。请你返回到达首都最少需要多少升汽油。,"1<=n<=10roads.length==n-1roads[i].length==20<=a,b<n!=broads表示一棵合法的树。1<=seats<=10",1,4
1993,99,3,146,题库,1,1,0,0,0,0,0,0,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，每个字符是数字到，再给你两个整数和。如果对的分割满足以下条件，那么我们认为它是一个分割：请你返回的分割数目。由于答案可能很大，请返回答案对后的结果。一个是字符串中一段连续字符串序列。,"被分成段互不相交的子字符串。每个子字符串长度都为minLength每个子字符串的第一个字符都是一个数字，最后一个字符都是一个非质数数字。质数数字为'2''3''5'和'7'，剩下的都是非质数数字。1<=k,minLength<=s.length<=1000每个字符都为数字'1'到'9'之一。",1,2
1994,57,2,52,题库,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,圆内一个，符合以下二者之一：一些有效和无效的切割如下图所示。给你一个整数，请你返回将圆切割成相等的等分的切割次数。,该切割是两个端点在圆上的线段，且该线段经过圆心。该切割是一端在圆心另一端在圆上的线段。1<=n<=100,0,2
1995,49,2,174,题库,3,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的二进制矩阵。我们按照如下过程，定义一个下标从开始的差值矩阵：请你返回差值矩阵。,"令第行一的数目为onesRow令第列一的数目为onesCol令第行零的数目为zerosRow令第列零的数目为zerosColdiff[i][j]=onesRow+onesCol-zerosRow-zerosColm==grid.lengthn==grid[i].length1<=m,n<=101<=m*n<=10grid[i][j]要么是，要么是",1,3
1996,111,3,138,题库,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个顾客访问商店的日志，用一个下标从开始且只包含字符和的字符串表示：如果商店在第小时关门（），代价按如下方式计算：请你返回在确保代价的前提下，商店的关门时间。注意，商店在第小时关门表示在第小时以及之后商店处于关门状态。,如果第个字符是'Y'，它表示第小时有顾客到达。如果第个字符是'N'，它表示第小时没有顾客到达。在开门期间，如果某一个小时没有顾客到达，代价增加在关门期间，如果某一个小时有顾客到达，代价增加1<=customers.length<=10customers只包含字符'Y'和'N',1,2
1997,39,3,90,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,给你数字字符串，请你返回中长度为的数目。由于答案可能很大，请你将答案对后返回。,如果一个字符串从前往后和从后往前读相同，那么它是回文字符串子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。1<=s.length<=10只包含数字字符。,1,2
1998,62,3,32,题库,0,0,0,0,1,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数，找出满足下述条件的：返回中枢整数。如果不存在中枢整数，则返回。题目保证对于给定的输入，至多存在一个中枢整数。,和之间的所有元素之和等于和之间所有元素之和。1<=n<=1000,1,2
1999,99,3,35,题库,1,1,0,0,1,0,0,0,0,0,0,1,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个仅由小写英文字母组成的字符串和。现在需要通过向末尾追加字符的方式使变成的一个，返回需要追加的最少字符数。子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。,"1<=s.length,t.length<=10和仅由小写英文字母组成",1,3
2000,54,2,33,题库,0,1,3,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个链表的头节点。对于列表中的每个节点，如果其右侧存在一个具有值的节点，则移除。返回修改后链表的头节点。,"给定列表中的节点数目在范围[1,101<=Node.val<=10",1,4
2001,51,2,138,题库,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的数组，该数组由从到的整数组成。另给你一个正整数。统计并返回中的等于的非空子数组的数目。,"数组的中位数是按顺序排列后位于的那个元素，如果数组长度为偶数，则中位数是位于中间靠例如，[2,3,1,4]的中位数是[8,4,3,5,1]的中位数是子数组是数组中的一个连续部分。n==nums.length1<=n<=101<=nums[i],k<=nnums中的整数互不相同",1,3
2002,135,3,183,题库,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,是由单个空格分隔的一组单词，且不含前导或尾随空格。单词由大写和小写英文字母组成。且大写和小写字母会视作不同字符。如果句子满足下述全部条件，则认为它是一个：例如，、、都是回环句。然而，、、和都是回环句。给你一个字符串，请你判断它是不是一个回环句。如果是，返回；否则，返回。,"例如，""HelloWorld""""HELLO""""helloworldhelloworld""都是符合要求的句子。单词的最后一个字符和下一个单词的第一个字符相等。最后一个单词的最后一个字符和第一个单词的第一个字符相等。1<=sentence.length<=500sentence仅由大小写英文字母和空格组成sentence中的单词由单个空格进行分隔不含任何前导或尾随空格",0,1
2003,101,3,51,题库,2,0,1,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，数组长度为，其中表示第个玩家的技能点。将所有玩家分成个人团队，使每一个团队的技能点之和。团队的等于团队中玩家的技能点。返回所有团队的之和，如果无法使每个团队的技能点之和相等，则返回。,2<=skill.length<=10skill.length是偶数1<=skill[i]<=1000,1,4
2004,93,2,164,题库,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数，表示总共有个城市，城市从到编号。给你一个二维数组，其中表示城市和之间有一条道路，道路距离为。城市构成的图不一定是连通的。两个城市之间一条路径的定义为这条路径中道路的距离。,"一条路径指的是两个城市之间的道路序列。一条路径可以包含同一条道路，你也可以沿着路径多次到达城市和城市测试数据保证城市和城市之间有一条路径。2<=n<=101<=roads.length<=10roads[i].length==31<=a,b<=n!=b1<=distance<=10不会有重复的边。城市和城市之间至少有一条路径。",0,4
2005,137,2,126,题库,0,1,1,1,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个正整数，表示一个图中的节点数目，节点编号从到。同时给你一个二维整数数组，其中表示节点和之间有一条边。注意给定的图可能是不连通的。请你将图划分为个组（编号从开始），满足以下要求：请你返回最多可以将节点分为多少个组（也就是最大的）。如果没办法在给定条件下分组，请你返回。,"图中每个节点都只属于一个组。图中每条边连接的两个点i,，如果属于编号为的组，属于编号为的组，那么|y-x|=11<=n<=5001<=edges.length<=10edges[i].length==21<=a,b<=n!=b两个点之间至多只有一条边。",1,3
2006,56,2,100,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个由字母和数字组成的字符串的定义如下：给你一个字符串数组，每个字符串都只由字母和数字组成，请你返回中字符串的。,如果字符串包含数字，那么值为该字符串在进制下的所表示的数字。否则，值为字符串的长度1<=strs.length<=1001<=strs[i].length<=9strs[i]只包含小写英文字母和数字。,0,2
2007,198,2,112,题库,2,1,2,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个个点的无向图，节点从到编号。给你一个长度为下标从开始的整数数组，其中表示第个节点的值。同时给你一个二维整数数组，其中表示节点和之间有一条双向边。是给定图中的一个子图，它包含一个中心节点和个或更多个邻居。换言之，星图是给定图中一个边的子集，且这些边都有一个公共节点。下图分别展示了有个和个邻居的星图，蓝色节点为中心节点。定义为星图中所有节点值的和。给你一个整数，请你返回包含条边的星图中的。,"n==vals.length1<=n<=10-10<=vals[i]<=100<=edges.length<=min(n*(n-1)/2,10edges[i].length==20<=a,b<=n-1!=b0<=k<=n-1",1,5
2008,128,2,121,题库,1,2,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，数组中的元素，表示一条河中石头的位置。一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头到达一次跳跃的是青蛙跳跃前和跳跃后所在两块石头之间的距离。一条路径的是这条路径里的。请你返回这只青蛙的。,更正式的，如果青蛙从stones[i]跳到stones[j]，跳跃的长度为|stones[i]-stones[j]|2<=stones.length<=100<=stones[i]<=10stones[0]==0stones中的元素严格递增。,1,3
2009,121,3,60,题库,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个下标从开始的整数数组和，两者长度都为。每次操作中，你可以选择交换中任意两个下标处的值。操作的为两个下标的。你的目标是对于所有的，都满足，你可以进行操作，请你返回达到这个目标的总代价。请你返回让和满足上述条件的，如果无法达成目标，返回。,"n==nums1.length==nums2.length1<=n<=101<=nums1[i],nums2[i]<=n",0,4
2010,67,2,108,题库,3,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个大小的矩阵，由若干正整数组成。执行下述操作，直到变为空矩阵：每执行一次操作，矩阵中列的数据就会减1。返回执行上述操作后的答案。,"从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。将删除元素中的最大值与答案相加。m==grid.lengthn==grid[i].length1<=m,n<=501<=grid[i][j]<=100",1,3
2011,88,2,75,题库,2,2,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。如果的子序列满足下述条件，则认为该子序列是一个：返回中的长度，如果不存在则返回。也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。,子序列的长度至少为，并且将子序列从小到大排序，除第一个元素外，每个元素都是前一个元素的2<=nums.length<=102<=nums[i]<=10,1,5
2012,60,1,265,题库,2,0,1,0,0,0,1,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，表示下标从开始的内存数组的大小。所有内存单元开始都是空闲的。请你设计一个具备以下功能的内存分配器：实现类：,"多个块可以被分配到同一个mID你必须释放mID对应的所有内存单元，即便这些内存单元被分配在不同的块中。Allocator(intn)使用一个大小为的内存数组初始化Allocator对象。intallocate(intsize,intmID)找出大小为size个连续空闲内存单元且位于最左侧的块，分配并赋idmID。返回块的第一个下标。如果不存在这样的块，返回intfree(intmID)释放idmID对应的所有内存单元。返回释放的内存单元数目。1<=n,size,mID<=1000最多调用allocate和free方法1000",1,4
2013,108,2,200,题库,2,1,1,1,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个大小为的整数矩阵和一个大小为的数组。找出一个大小为的数组，且满足对于每个整数，你从矩阵单元格开始，重复以下过程：在过程结束后，是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格。返回结果数组。,"如果queries[i]大于你当前所处位置单元格，如果该单元格是第一次访问，则获得1分，并且你可以移动到所有个方向（上、下、左、右）上任一单元格。否则，你不能获得任何分，并且结束这一过程。m==grid.lengthn==grid[i].length2<=m,n<=10004<=m*n<=10k==queries.length1<=k<=101<=grid[i][j],queries[i]<=10",1,5
2014,72,3,135,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串数组。如果两个字符串由相同的字符组成，则认为这两个字符串。请你找出满足字符串和相似的下标对，并返回下标对的数目，其中。,"例如，""abca""和""cba""相似，因为它们都由字符'a''b''c'组成。然而，""abacba""和""bcfd""不相似，因为它们不是相同字符组成的。1<=words.length<=1001<=words[i].length<=100words[i]仅由小写英文字母组成",1,3
2015,38,2,46,题库,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数。请你将的值替换为的之和，重复这一过程。返回可以取到的最小值。,注意，如果能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。2<=n<=10,0,2
2016,146,3,64,题库,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个有个节点的图，节点编号为到。再给你整数和一个二维整数数组，其中表示节点和之间有一条边。图不一定连通。你可以给图中添加两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回，否则返回。点的度数是连接一个点的边的数目。,"3<=n<=102<=edges.length<=10edges[i].length==21<=a,b<=n!=b图中不会有重边",0,2
2017,119,2,163,题库,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数，表示你有一棵含有个节点的。根节点的编号是，树中编号在之间，编号为的节点都有两个子节点，满足：给你一个长度为的查询数组，它是一个二维整数数组，其中。对于每个查询，求出以下问题的解：请你返回一个长度为的数组，其中是第个查询的结果,"左子节点的编号为2*val右子节点的编号为2*val+1是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。环的长度是环中边的数目。在树中添加额外的边后，两个点之间可能会有多条边。2<=n<=30m==queries.length1<=m<=10queries[i].length==21<=a,b<=2-1!=b",1,2
2018,136,2,141,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个长度为，下标从开始的整数数组，表示一些城堡。可以是，或者，其中：现在，你需要决定，将你的军队从某个你控制的城堡位置移动到一个空的位置，满足：当军队移动时，所有途中经过的敌人城堡都会被。请你返回可以摧毁的敌人城堡数目。如果移动你的军队，或者没有你控制的城堡，请返回。,"表示第个位置城堡。表示第个位置有一个的城堡。表示第个位置有一个你控制的城堡。0<=i,j<=n-1军队经过的位置敌人的城堡。正式的，对于所有min(i,j)<k<max(i,j)的，都满足forts[k]==01<=forts.length<=1000-1<=forts[i]<=1",0,2
2019,196,2,375,题库,3,0,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个字符串数组和，分别包含表示正面的和负面的词汇。有单词同时是正面的和负面的。一开始，每位学生分数为。每个正面的单词会给学生的分数分，每个负面的词会给学生的分数分。给你个学生的评语，用一个下标从开始的字符串数组和一个下标从开始的整数数组表示，其中表示这名学生的ID，这名学生的评语是。每名学生的ID。给你一个整数，请你返回按照得分最顶尖的名学生。如果有多名学生分数相同，ID越小排名越前。,"1<=positive_feedback.length,negative_feedback.length<=101<=positive_feedback[i].length,negative_feedback[j].length<=100positive_feedback[i]和negative_feedback[j]都只包含小写英文字母。positive_feedback和negative_feedback中不会有相同单词。n==report.length==student_id.length1<=n<=10report[i]只包含小写英文字母和空格''report[i]中连续单词之间有单个空格隔开。1<=report[i].length<=1001<=student_id[i]<=10student_id[i]的值互不相同1<=k<=n",1,5
2020,58,3,175,题库,0,1,0,0,0,2,0,0,0,0,0,0,1,0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个数组和，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：给你，，和，请你返回两个数组中的。,"arr1包含uniqueCnt1互不相同的正整数，每个整数都不能divisor1arr2包含uniqueCnt2互不相同的正整数，每个整数都被divisor2arr1和arr2中的元素互不相同2<=divisor1,divisor2<=101<=uniqueCnt1,uniqueCnt2<102<=uniqueCnt1+uniqueCnt2<=10",1,3
2021,107,2,95,题库,1,0,1,0,1,2,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串，它包含一个或者多个单词。单词之间用单个空格隔开。如果字符串中第个单词是中第个单词的一个，那么我们称字符串是字符串的同位异构字符串。请你返回的同位异构字符串的数目，由于答案可能很大，请你将它对后返回。,"比方说，""acbdfe""是""abcdef""的同位异构字符串，但是""defcab""和""adcbef""不是。1<=s.length<=10只包含小写英文字母和空格''相邻单词之间由单个空格隔开。",1,5
2022,87,3,173,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串数组和一个字符串。意味着数组首尾相连。从开始，你一次可以用步移动到下一个或者前一个单词。返回到达目标字符串所需的最短距离。如果中不存在字符串，返回。,形式上，words[i]的下一个元素是words[(i+1)%n]，而words[i]的前一个元素是words[(i-1+n)%n]，其中是words的长度。1<=words.length<=1001<=words[i].length<=100words[i]和target仅由小写英文字母组成0<=startIndex<words.length,1,2
2023,73,2,44,题库,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由字符、、组成的字符串和一个非负整数。每分钟，你可以选择取走还是的那个字符。你必须取走每种字符个，返回需要的分钟数；如果无法取到，则返回。,1<=s.length<=10仅由字母'a''b''c'组成0<=k<=s.length,1,3
2024,75,3,37,题库,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，其中表示第类糖果的价格，另给你一个正整数。商店组合类糖果打包成礼盒出售。礼盒的是礼盒中任意两种糖果绝对差的最小值。返回礼盒的甜蜜度,2<=k<=price.length<=101<=price[i]<=10,1,3
2025,138,3,36,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个正整数数组和一个整数。的定义是：将数组划分成两个有序的，并满足每个元素存在于组中。如果分区中每个组的元素和都大于等于，则认为分区是一个好分区。返回的好分区的数目。由于答案可能很大，请返回对后的结果。如果在两个分区中，存在某个元素被分在不同的组中，则认为这两个分区不同。,"1<=nums.length,k<=10001<=nums[i]<=10",0,2
2026,35,3,19,题库,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，返回中能整除的数位的数目。如果满足，则认为整数可以整除。,1<=num<=10num的数位中不含,1,1
2027,32,2,91,题库,1,0,1,0,0,2,0,0,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组，对所有元素求积之后，找出并返回乘积中的数目。,是指大于且仅能被及自身整除的数字。如果val2/val1是一个整数，则整数val1是另一个整数val2的一个因数。1<=nums.length<=102<=nums[i]<=1000,1,4
2028,90,2,126,题库,1,2,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，它每一位都是到之间的数字组成，同时给你一个整数。如果一个字符串的分割满足以下条件，我们称它是一个分割：请你返回所有的分割中，子字符串的数目。如果不存在的分割，返回。,"中每个数位属于一个子字符串。每个子字符串的值都小于等于一个字符串的是这个字符串对应的整数。比方说，""123""的值为123""1""的值是子字符串是字符串中一段连续的字符序列。1<=s.length<=10s[i]是'1'到'9'之间的数字。1<=k<=10",1,3
2029,108,2,82,题库,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个正整数和，请你找到两个整数和，它们满足：请你返回正整数数组。如果有多个整数对满足上述条件，请你返回最小的质数对。如果不存在符合题意的质数对，请你返回。如果一个整数大于，且只能被和它自己整除，那么它是一个质数。,left<=nums1<nums2<=rightnums1和nums2都是nums2-nums1是满足上述条件的质数对中的最小值1<=left<=right<=10,1,2
2030,65,2,261,题库,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你四个整数，，和，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子的字符串。，箱子的体积等于箱子的长度、宽度和高度的乘积。,"如果满足以下条件，那么箱子是""Bulky""箱子至少有一个维度大于等于或者箱子的大于等于如果箱子的质量大于等于100，那么箱子是""Heavy""的。如果箱子同时是""Bulky""和""Heavy""，那么返回类别为""Both""如果箱子既不是""Bulky""，也不是""Heavy""，那么返回类别为""Neither""如果箱子是""Bulky""但不是""Heavy""，那么返回类别为""Bulky""如果箱子是""Heavy""但不是""Bulky""，那么返回类别为""Heavy""1<=length,width,height<=101<=mass<=10",1,1
2031,44,1,178,题库,0,0,2,0,1,0,2,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数据流，请你实现一个数据结构，检查数据流中最后个整数是否给定值。请你实现类：,"DataStream(intvalue,intk)用两个整数value和初始化一个空的整数数据流。booleanconsec(intnum)将num添加到整数数据流。如果后个整数都等于value，返回true，否则返回false。如果少于个整数，条件不满足，所以也返回false1<=value,num<=101<=k<=10至多调用consec次数为次。",1,5
2032,58,2,80,题库,1,0,0,0,1,1,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。三个下标，和的定义为。一个数组的是数组中所有满足的的异或结果。请你返回的xor美丽值。,val1|val2是val1和val2的按位或。val1&val2是val1和val2的按位与。1<=nums.length<=101<=nums[i]<=10,1,3
2033,229,2,90,题库,1,2,1,0,2,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始长度为的整数数组，其中表示第座城市的供电站数目。每个供电站可以在一定内给所有城市提供电力。换句话说，如果给定的范围是，在城市处的供电站可以给所有满足且的城市供电。一座城市的是所有能给它供电的供电站数目。政府批准了可以额外建造座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。给你两个整数和，如果以最优策略建造额外的发电站，返回所有城市中，最小供电站数目的最大值是多少。这座供电站可以建在多个城市。,|x|表示的绝对值。比方说，|7-5|=2|3-10|=7n==stations.length1<=n<=100<=stations[i]<=100<=r<=n-10<=k<=10,1,6
2034,67,3,105,题库,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个按排列的数组，返回正整数数目和负整数数目中的最大值。既不是正整数也不是负整数。你可以设计并实现时间复杂度为的算法解决此问题吗？,换句话讲，如果nums中正整数的数目是pos，而负整数的数目是neg，返回pos和neg二者中的最大值。1<=nums.length<=2000-2000<=nums[i]<=2000nums按非递减顺序排列。,0,3
2035,71,2,34,题库,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个整数。你的为。在一步中：返回在执行次操作后，你可能获得的最大分数。向上取整函数的结果是大于或等于的最小整数。,"1<=nums.length,k<=101<=nums[i]<=10",1,3
2036,59,3,120,题库,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个下标从开始的字符串和。一次由以下两个步骤组成：如果可以通过移动，使和中不同字符的数目相等，则返回；否则，返回。,"选中两个下标和，分别满足0<=i<word1.length和0<=j<word2.length交换word1[i]和word2[j]1<=word1.length,word2.length<=10word1和word2仅由小写英文字母组成。",1,3
2037,181,2,523,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,共有位工人计划将个箱子从旧仓库移动到新仓库。给你两个整数和，以及一个二维整数数组，数组的大小为，其中。一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有位工人都在桥的左侧等待。为了移动这些箱子，第位工人（下标从开始）可以：如果满足下面任一条件，则认为工人的工人：工人通过桥时需要遵循以下规则：所有个盒子都需要放入新仓库，,"从左岸（新仓库）跨过桥到右岸（旧仓库），用时leftToRight分钟。从旧仓库选择一个箱子，并返回到桥边，用时pickOld分钟。不同工人可以同时搬起所选的箱子。从右岸（旧仓库）跨过桥到左岸（新仓库），用时rightToLeft分钟。将箱子放入新仓库，并返回到桥边，用时putNew分钟。不同工人可以同时放下所选的箱子。leftToRight+rightToLeft>leftToRight+rightToLeftleftToRight+rightToLeft==leftToRight+rightToLeft且i>j如果工人到达桥边时，工人正在过桥，那么工人需要在桥边等待。如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么效率最低的工人会先过桥。如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么效率最低的工人会先过桥。1<=n,k<=10time.length==ktime[i].length==41<=leftToRight,pickOld,rightToLeft,putNew<=1000",1,3
2038,31,2,90,题库,1,0,0,0,0,1,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个正整数数组。返回与的绝对差。两个整数和的绝对差定义为。,元素和是nums中的所有元素相加求和。数字和是nums中每一个元素的每一数位（重复数位需多次求和）相加求和。1<=nums.length<=20001<=nums[i]<=2000,1,2
2039,79,2,154,题库,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数，表示最初有一个、下标从开始的整数矩阵，矩阵中填满了0。另给你一个二维整数数组。针对每个查询，请你执行下述操作：返回执行完所有操作后得到的矩阵。,"找出左上角为(row1,col1且右下角为(row2,col2的子矩阵，将子矩阵中的每个元素加。也就是给所有满足row1<=x<=row2和col1<=y<=col2的mat[x][y]加1<=n<=5001<=queries.length<=100<=row1<=row2<n0<=col1<=col2<n",1,3
2040,67,2,34,题库,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和一个整数，请你返回中子数组的数目。一个子数组如果有对下标满足且，那么称它是一个子数组。是原数组中一段连续的元素序列。,"1<=nums.length<=101<=nums[i],k<=10",1,3
2041,187,2,84,题库,1,2,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个节点的无向无根图，节点编号为到。给你一个整数和一个长度为的二维整数数组，其中表示树中节点和之间有一条边。每个节点都有一个价值。给你一个整数数组，其中是第个节点的价值。一条路径的是这条路径上所有节点的价值之和。你可以选择树中任意一个节点作为根节点。选择为根的是以为起点的所有路径中，最大的一条路径与最小的一条路径的差值。请你返回所有节点作为根节点的选择中，的为多少。,"1<=n<=10edges.length==n-10<=a,b<=n-1edges表示一棵符合题面要求的树。price.length==n1<=price[i]<=10",1,4
2042,76,2,74,题库,1,1,1,0,1,0,0,0,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数数组和，它们已经按非降序排序，请你返回两个数组的。如果两个数组和没有公共整数，请你返回。如果一个整数在两个数组中都，那么这个整数是数组和的。,"1<=nums1.length,nums2.length<=101<=nums1[i],nums2[j]<=10nums1和nums2都是非降序的。",1,4
2043,85,2,144,题库,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数数组和，两个数组长度都是，再给你一个整数。你可以对数组进行以下操作：如果对于所有满足都有，那么我们称。请你返回使等于的操作数。如果没办法让它们相等，请你返回。,"选择两个下标和，将nums1[i]增加，将nums1[j]减少。换言之，nums1[i]=nums1[i]+k且nums1[j]=nums1[j]-kn==nums1.length==nums2.length2<=n<=100<=nums1[i],nums2[j]<=100<=k<=10",1,3
2044,117,2,179,题库,2,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个下标从开始的整数数组和，两者长度都是，再给你一个正整数。你必须从中选一个长度为的对应的下标。对于选择的下标，，...，，你的定义如下：请你返回可能的分数。一个数组的下标是集合中删除若干元素得到的剩余集合，也可以不删除任何元素。,"nums1中下标对应元素求和，乘以nums2中下标对应元素的最小值用公示表示：(nums1[i]+nums1[i]+...+nums1[ik-1])*min(nums2[i],nums2[i],...,nums2[ik-1n==nums1.length==nums2.length1<=n<=100<=nums1[i],nums2[j]<=101<=k<=n",1,4
2045,98,2,50,题库,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个无穷大的网格图。一开始你在，你需要通过有限步移动到达点。，你可以从点移动到以下点之一：给你两个整数和，分别表示你最后需要到达点的X和Y坐标。如果你可以从出发到达这个点，请你返回，否则返回。,"(x,y-x)(x-y,y)(2*x,y)(x,2*y)1<=targetX,targetY<=10",0,2
2046,44,3,42,题库,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数。中的每一位数字都会按下述规则分配一个符号：返回所有数字及其对应符号的和。,最高有效位上的数字分配到号。剩余每位上数字的符号都与其相邻数字相反。1<=n<=10,1,1
2047,121,2,79,题库,3,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,班里有位学生，共计划组织场考试。给你一个下标从开始、大小为的整数矩阵，其中每一行对应一位学生，而表示第位学生在第场考试取得的分数。矩阵包含的整数。另给你一个整数。请你按第场考试分数从高到低完成对这些学生（矩阵中的行）的排序。返回排序后的矩阵。,"m==score.lengthn==score[i].length1<=m,n<=2501<=score[i][j]<=10score由的整数组成0<=k<n",1,3
2048,96,2,110,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个下标从开始的字符串和，两个字符串的长度均为。你可以对执行下述操作次：例如，如果，你可以选择和，然后同时将替换为(==)，并将替换为(==)，最终得到。如果可以使等于，返回，否则，返回。,"选择两个的下标和，其中0<=i,j<n同时，将s[i]替换为(s[i]s[j])，s[j]替换为(s[i]XORs[j])。n==s.length==target.length2<=n<=10和target仅由数字和组成",0,2
2049,114,3,162,题库,1,1,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数数组和一个整数。将数组拆分成一些非空子数组。拆分的是每个子数组中的之和。令作为子数组的一个特征，其中所有仅出现一次的数字将会被移除。子数组的定义为。找出并返回拆分的所有可行方案中的最小代价。是数组的一个连续元素序列。,"例如，trimmed([3,1,2,4,3,4])=[3,4,3,4]例如，如果一个子数组是[1,2,3,3,3,4,4]trimmed([1,2,3,3,3,4,4])=[3,3,3,4,4]。这个子数组的重要性就是k+51<=nums.length<=10000<=nums[i]<nums.length1<=k<=10",1,4
2050,54,2,99,题库,2,0,1,0,0,1,0,1,0,0,0,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数，开始时，它放在桌面上。在天内，每天都要执行下述步骤：返回在天之后，出现在桌面上的整数的数目。,对于出现在桌面上的每个数字，找出符合1<=i<=n且满足x%i==1的所有数字然后，将这些数字放在桌面上。一旦数字放在桌面上，则会一直保留直到结束。表示取余运算。例如，14%3等于1<=n<=100,1,4
2051,166,2,42,题库,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现在有一个正凸多边形，其上共有个顶点。顶点按顺时针方向从到依次编号。每个顶点上。下图中是一个6个顶点的凸多边形。每个猴子同时移动到相邻的顶点。顶点的相邻顶点可以是：如果移动后至少有两只猴子停留在同一个顶点上或者相交在一条边上，则会发生。返回猴子至少发生的移动方法数。由于答案可能非常大，请返回对取余后的结果。，每只猴子只能移动一次。,顺时针方向的顶点(i+1)%n，或逆时针方向的顶点(i-1+n)%n3<=n<=10,1,2
2052,98,2,141,题库,2,1,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,你有个背包。给你一个下标从开始的整数数组，其中是第个珠子的重量。同时给你整数。请你按照如下规则将所有的珠子放进个背包。一个珠子分配方案的是所有个背包的价格之和。请你返回所有分配方案中，与的为多少。,没有背包是空的。如果第个珠子和第个珠子在同一个背包里，那么下标在到之间的所有珠子都必须在这同一个背包中。如果一个背包有下标从到的所有珠子，那么这个背包的价格是weights[i]+weights[j]1<=k<=weights.length<=101<=weights[i]<=10,1,4
2053,64,2,109,题库,2,1,0,1,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为下标从开始的整数数组，它包含到的所有数字，请你返回上升四元组的数目。如果一个四元组满足以下条件，我们称它是上升的：,0<=i<j<k<l<nnums[i]<nums[k]<nums[j]<nums[l]4<=nums.length<=40001<=nums[i]<=nums.lengthnums中所有数字互不相同nums是一个排列。,1,5
2054,86,2,67,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数数组，请你返回一个数组，你需要将中每个整数进行数位分割后，按照中出现的放入答案数组中。对一个整数进行数位分割，指的是将整数各个数位按原本出现的顺序排列成数组。,"比方说，整数10921，分割它的各个数位得到[1,0,9,2,1]1<=nums.length<=10001<=nums[i]<=10",1,2
2055,51,3,105,题库,2,2,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和两个整数和。你需要按照以下规则选择一些整数：请你返回按照上述规则可以选择的整数数目。,"被选择整数的范围是[1,n]每个整数选择被选择整数不能在数组banned中。被选择整数的和不超过maxSum1<=banned.length<=101<=banned[i],n<=101<=maxSum<=10",1,5
2056,160,2,168,题库,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在上有一些奖品。给你一个整数数组，它按照顺序排列，其中是第件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数。你可以选择两个端点为整数的线段。每个线段的长度都必须是。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。请你返回在选择两个最优线段的前提下，可以获得的奖品数目。,"比方说k=2，你可以选择线段[1,3]和[2,4]，你可以获得满足1<=prizePositions[i]<=3或者2<=prizePositions[i]<=4的所有奖品i。1<=prizePositions.length<=101<=prizePositions[i]<=100<=k<=10prizePositions有序非递减。",1,3
2057,127,2,82,题库,2,3,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的矩阵。你可以从一个格子移动到格子或者，前提是前往的格子值为。如果从到没有任何路径，我们称该矩阵是的。你可以翻转格子的值（也可以不翻转）。你格子和。如果可以使矩阵不连通，请你返回，否则返回。，翻转一个格子的值，可以使它的值从变，或从变。,"m==grid.lengthn==grid[i].length1<=m,n<=10001<=m*n<=10grid[0][0]==grid[m-1][n-1]==1",1,5
2058,45,2,112,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个整数数组，表示各堆礼物的数量。每一秒，你需要执行以下操作：返回在秒后剩下的礼物数量,选择礼物数量最多的那一堆。如果不止一堆都符合礼物数量最多，从中选择任一堆即可。选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。1<=gifts.length<=101<=gifts[i]<=101<=k<=10,1,3
2059,108,2,150,题库,2,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串数组以及一个二维整数数组。每个查询会要求我们统计在中下标在到范围内（这两个值）并且以元音开头和结尾的字符串的数目。返回一个整数数组，其中数组的第个元素对应第个查询的答案。元音字母是、、、和。,1<=words.length<=101<=words[i].length<=40words[i]仅由小写英文字母组成sum(words[i].length)<=3*101<=queries.length<=100<=queries[j][0]<=queries[j][1]<words.length,1,3
2060,175,2,55,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。由于相邻的房屋装有相互连通的防盗系统，所以小偷。小偷的定义为他在窃取过程中能从单间房屋中窃取的。给你一个整数数组表示每间房屋存放的现金金额。形式上，从左起第间房屋中放有美元。另给你一个整数，表示窃贼将会窃取的房屋数。小偷总能窃取至少间房屋。返回小偷的窃取能力。,1<=nums.length<=101<=nums[i]<=101<=k<=(nums.length+1)/2,0,2
2061,148,2,137,题库,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有两个果篮，每个果篮中有个水果。给你两个下标从开始的整数数组和，用以表示两个果篮中每个水果的成本。你希望两个果篮相等。为此，可以根据需要多次执行下述操作：根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回。,"选中两个下标和，并交换basket1中的第个水果和basket2中的第个水果。交换的成本是min(basket1,basket2basket1.length==bakste2.length1<=basket1.length<=101<=basket1,basket2<=10",1,3
2062,74,2,165,题库,2,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组。现定义两个数字的是由这两个数值串联起来形成的新数字。的最初等于。执行下述操作直到变为空：返回执行完所有操作后的串联值。,例如，和的串联是1549如果nums中存在不止一个数字，分别选中nums中的第一个元素和最后一个元素，将二者串联得到的值加到nums的串联值上，然后从nums中删除第一个和最后一个元素。如果仅存在一个元素，则将该元素的值加到nums的串联值上，然后删除这个元素。1<=nums.length<=10001<=nums[i]<=10,1,3
2063,48,2,106,题库,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、长度为的整数数组，和两个整数和，返回。如果数对满足以下情况，则认为它是一个：,0<=i<j<nlower<=nums[i]+nums[j]<=upper1<=nums.length<=10nums.length==n-10<=nums[i]<=10-10<=lower<=upper<=10,1,4
2064,140,3,72,题库,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个和一个整数数组，其中。对于第个查询，找到的，它对应的值与得到，换言之，。第个查询的答案是子字符串的两个端点（下标从开始），如果不存在这样的子字符串，则答案为。如果有多个答案，请你选择最小的一个。请你返回一个数组，其中是第个查询的答案。是一个字符串中一段连续非空的字符序列。,"1<=s.length<=10s[i]要么是'0'，要么是'1'1<=queries.length<=100<=first,second<=10",0,4
2065,138,2,69,题库,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个字符串和。你可以从字符串中删除任意数目的字符。如果没有从字符串中删除字符，那么得分为，否则：字符串的得分为。请你返回使成为子序列的最小得分。一个字符串的是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说是的子序列，但是不是）。,"left为删除字符中的最小下标。right为删除字符中的最大下标。1<=s.length,t.length<=10和都只包含小写英文字母。",0,3
2066,69,2,161,题库,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数。你知道DannyMittal会偷偷将到中的一个数字成另一个数字。请你返回将中数字进行替换后，得到的最大值和最小值的差为多少。,当Danny将一个数字替换成另一个数字时，Danny需要将nums中所有都替换成Danny可以将一个数字替换成它自己，也就是说num可以不变。Danny可以将数字分别替换成两个不同的数字分别得到最大值和最小值。替换后得到的数字可以包含前导0。DannyMittal获得周赛326前10名，让我们恭喜他。1<=num<=10,0,2
2067,66,2,151,题库,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。我们的目标是最小化的分数。你可以修改中个元素的值。请你返回修改中元素的值后，可以得到的。表示的绝对值。,nums的得分是满足0<=i<j<nums.length的|nums[i]-nums[j]|的最小值。nums最大得分是满足0<=i<j<nums.length的|nums[i]-nums[j]|的最大值。nums的分数是得分与得分的和。3<=nums.length<=101<=nums[i]<=10,0,3
2068,81,2,32,题库,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。如果存在一些整数满足，得到，那么我们说是。换言之，如果一个整数能由的某个子序列的或运算得到，那么它就是可表达的。请你返回不可表达的。,1<=nums.length<=101<=nums[i]<=10,0,3
2069,63,2,157,题库,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个下标从开始的数组和，和一个二维数组表示一些操作。总共有3种类型的操作：请你返回一个数组，包含所有第三种操作类型的答案。,"1<=nums1.length,nums2.length<=10nums1.length=nums2.length1<=queries.length<=10queries[i].length=30<=l<=r<=nums1.length-10<=p<=100<=nums1[i]<=10<=nums2[i]<=10",1,2
2070,89,2,269,题库,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数数组和每个数组都包含的id，并按id以顺序排列。请你将两个数组合并为一个按id以递增顺序排列的数组，并符合下述条件：返回结果数组。返回的数组需要按id以递增顺序排列。,"nums1[i]=[id,val表示编号为的数字对应的值等于valnums2[i]=[id,val表示编号为的数字对应的值等于val只有在两个数组中至少出现过一次的id才能包含在结果数组内。每个id在结果数组中只能出现一次，并且其对应的值等于两个数组中该id所对应的值求和。如果某个数组中不存在该id，则认为其对应的值等于1<=nums1.length,nums2.length<=200nums1[i].length==nums2[j].length==21<=id,val<=1000数组中的id互不相同数据均按id以严格递增顺序排列",1,3
2071,46,2,16,题库,0,2,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个正整数，你可以执行下述操作次：返回使等于需要执行的操作数。如果且其中，则数字是的幂。,加上或减去的某个1<=n<=10,1,3
2072,152,2,34,题库,1,1,0,0,2,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组。如果数组的子集中的元素乘积是一个，则认为该子集是一个子集。是无法被除之外任何平方数整除的数字。返回数组中且的子集数目。因为答案可能很大，返回对取余的结果。的是可以由删除中一些元素（可以不删除，但不能全部删除）得到的一个数组。如果构成两个子集时选择删除的下标不同，则认为这两个子集不同。,1<=nums.length<=10001<=nums[i]<=30,0,5
2073,182,3,111,题库,1,2,0,1,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,HARD,对任一由个小写英文字母组成的字符串，我们可以定义一个的矩阵，并满足：给你一个的矩阵。返回与对应的、按字典序最小的字符串。如果不存在这样的字符串，则返回空字符串。对于长度相同的两个字符串和，如果在和不同的第一个位置，字符串的字母在字母表中出现的顺序先于中的对应字母，则认为字符串按字典序比字符串小。例如，在字典上小于，因为二者不同的第一位置是第三个字母，而先于出现。,"lcp[i][j]等于子字符串word[i,...,n-1]和word[j,...,n-1]之间的最长公共前缀的长度。1<=n==lcp.length==lcp[i].length<=10000<=lcp[i][j]<=n",0,4
2074,43,2,196,题库,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组，请你找出一个下标从开始的整数数组，其中：其中：返回数组。,answer.length==nums.lengthanswer[i]=|leftSum[i]-rightSum[i]|leftSum[i]是数组nums中下标左侧元素之和。如果不存在对应的元素，leftSum[i]=0rightSum[i]是数组nums中下标右侧元素之和。如果不存在对应的元素，rightSum[i]=01<=nums.length<=10001<=nums[i]<=10,1,2
2075,62,2,83,题库,2,0,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串，长度为，由从到的数字组成。另给你一个正整数。的是一个长度为的整数数组，并满足：返回的可整除数组。,"如果word[0,...,i]所表示的能被整除，div[i]=1否则，div[i]=01<=n<=10word.length==nword由数字到组成1<=m<=10",1,3
2076,70,3,75,题库,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个下标从开始的整数数组。一开始，所有下标都没有被标记。你可以执行以下操作任意次：请你执行上述操作任意次，返回中最多可以标记的下标数目。,选择两个互不相同且未标记的下标和，满足2*nums[i]<=nums[j]，标记下标和1<=nums.length<=101<=nums[i]<=10,0,5
2077,150,2,83,题库,2,1,3,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个的矩阵，每个元素都为整数，其中表示可以访问格子的时间。也就是说当你访问格子时，最少已经经过的时间为。你从出发，出发时刻为，你必须一直移动到上下左右相邻四个格子中的一个格子（即不能停留在格子上）。每次移动都需要花费1单位时间。请你返回到达右下角格子的时间，如果你无法到达右下角的格子，请你返回。,"m==grid.lengthn==grid[i].length2<=m,n<=10004<=m*n<=100<=grid[i][j]<=10grid[0][0]==0",1,6
2078,40,2,129,题库,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数，请你将它分割成两个非负整数和，满足：请你返回和可以得到的和的值。,num1和num2直接连起来，得到num换句话说，num1和num2中所有数字出现的次数之和等于num中所有数字出现的次数。num1和num2可以包含前导0。num保证没有前导0。num1和num2中数位顺序可以与num中数位顺序不同。10<=num<=10,1,3
2079,76,1,48,题库,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一个无穷大的二维网格图，一开始所有格子都未染色。给你一个正整数，表示你需要执行以下步骤分钟：下图分别是1、2、3分钟后的网格图。请你返回分钟之后数目。,第一分钟，将格子染成蓝色。之后的每一分钟，将与蓝色格子相邻的未染色格子染成蓝色。1<=n<=10,0,1
2080,109,2,117,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二维整数数组，其中表示到之间（包括二者）的所有整数都包含在第个区间中。你需要将分成组（可以为空），满足：如果两个区间有至少公共整数，那么这两个区间是的。请你返回将划分成两个组的。由于答案可能很大，将它对后返回。,"每个区间只属于一个组。两个有的区间必须在同一个组内。比方说，区间[1,3]和[2,5]有交集，因为和在两个区间中都被包含。1<=ranges.length<=10ranges[i].length==20<=start<=end<=10",1,2
2081,224,2,168,题库,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,Alice有一棵个节点的树，节点编号为到。树用一个长度为的二维整数数组表示，其中，表示树中节点和之间有一条边。Alice想要Bob找到这棵树的根。她允许Bob对这棵树进行若干次。每一次猜测，Bob做如下事情：Bob的猜测用二维整数数组表示，其中表示Bob猜是的父节点。Alice非常懒，她不想逐个回答Bob的猜测，只告诉Bob这些猜测里面有个猜测的结果为。给你二维整数数组，Bob的所有猜测和整数，请你返回可能成为树根的。如果没有这样的树，则返回。,"选择两个不相等的整数和，且树中必须存在边[u,v]Bob猜测树中是的父节点edges.length==n-12<=n<=101<=guesses.length<=100<=a,b,u,v<=n-1!=b!=vedges表示一棵有效的树。guesses[j]是树中的一条边。guesses是唯一的。0<=k<=guesses.length",0,4
2082,117,2,69,题库,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,个人站成一排，按从到编号。最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。给你两个正整数和，返回秒后拿着枕头的人的编号。,例如，当枕头到达第个人时，TA会将枕头传递给第n-1个人，然后传递给第n-2个人，依此类推。2<=n<=10001<=time<=1000,1,2
2083,86,2,37,题库,0,2,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一棵二叉树的根节点和一个正整数。树中的是指上节点值的总和。返回树中第大的层和（不一定不同）。如果树少于层，则返回。，如果两个节点与根节点的距离相同，则认为它们在同一层。,树中的节点数为2<=n<=101<=Node.val<=101<=k<=n,1,3
2084,118,2,118,题库,1,0,1,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个长度为的整数数组，下标从开始。如果在下标处数组，其中，使前个元素的乘积和剩余元素的乘积互质，则认为该分割。返回可以有效分割数组的最小下标，如果不存在有效分割，则返回。当且仅当成立时，和这两个值才是互质的，其中表示和的最大公约数。,"例如，如果nums=[2,3,3]，那么在下标i=0处的分割有效，因为和互质，而在下标i=1处的分割无效，因为和不互质。在下标i=2处的分割也无效，因为i==n-1n==nums.length1<=n<=101<=nums[i]<=10",0,4
2085,100,3,120,题库,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,考试中有种类型的题目。给你一个整数和一个下标从开始的二维整数数组，其中表示第种类型的题目有道，每道题目对应分。返回你在考试中恰好得到分的方法数。由于答案可能很大，结果需要对取余。，同类型题目无法区分。,"比如说，如果有道同类型题目，那么解答第和第道题目与解答第和第道题目或者第和第道题目是相同的。1<=target<=1000n==types.length1<=n<=50types[i].length==21<=count,marks<=50",1,2
2086,87,2,88,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个下标从开始的字符串数组和两个整数：和。如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个，其中元音字母是、、、、。返回是元音字符串的数目，其中在闭区间内。,1<=words.length<=10001<=words[i].length<=10words[i]仅由小写英文字母组成0<=left<=right<words.length,1,2
2087,101,2,34,题库,2,1,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。你可以将中的元素按重排（包括给定顺序）。令为一个数组，它包含了重新排列后的前缀和。换句话说，是重新排列后下标从到的元素之和。的是数组中正整数的个数。返回可以得到的最大分数。,1<=nums.length<=10-10<=nums[i]<=10,0,4
2088,104,2,124,题库,1,0,1,0,2,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。每次操作中，你可以：如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为的数组，那么我们称它是一个的子数组。请你返回数组中的数目。子数组是一个数组中一段连续的元素序列。,"选择两个满足0<=i,j<nums.length的不同下标和选择一个非负整数，满足nums[i]和nums[j]在二进制下的第位（下标编号从开始）是nums[i]和nums[j]都减去1<=nums.length<=100<=nums[i]<=10",0,4
2089,122,2,81,题库,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有一台电脑，它可以运行无数个任务。给你一个二维整数数组，其中表示第个任务需要在时间段内运行个整数时间点（但不需要连续）。当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。请你返回完成所有任务的情况下，电脑最少需要运行多少秒。,"1<=tasks.length<=2000tasks[i].length==31<=start,end<=20001<=duration<=end-start+1",0,5
2090,98,2,58,题库,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数，表示你总共有的钱数（单位为美元）和另一个整数，表示你要将钱分配给多少个儿童。你需要按照如下规则分配：请你按照上述规则分配金钱，并返回有多少个儿童获得美元。如果没有任何分配方案，返回。,所有的钱都必须被分配。每个儿童至少获得美元。没有人获得美元。1<=money<=2002<=children<=30,0,2
2091,59,2,32,题库,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从0开始的整数数组。你需要将重新排列成一个新的数组。定义的为满足且的下标数目。请你返回重新排列后的伟大值。,1<=nums.length<=100<=nums[i]<=10,1,4
2092,54,2,132,题库,3,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，它包含若干正整数。一开始分数，请你按照下面算法求出最后分数：请你返回执行上述算法后最后的分数。,从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。将选中的整数加到score中。标记被选中元素，如果有相邻元素，则同时标记与它相邻的两个元素重复此过程直到数组中所有元素都被标记。1<=nums.length<=101<=nums[i]<=10,0,4
2093,102,2,46,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，表示一些机械工的。是第位机械工的能力值。能力值为的机械工可以在分钟内修好辆车。同时给你一个整数，表示总共需要修理的汽车数目。请你返回修理所有汽车需要多少时间。所有机械工可以同时修理汽车。,1<=ranks.length<=101<=ranks[i]<=1001<=cars<=10,0,2
2094,75,2,10,题库,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数。用表示在的二进制形式（下标从开始）中值为的偶数下标的个数。用表示在的二进制形式（下标从开始）中值为的奇数下标的个数。返回整数数组，其中。,1<=n<=1000,0,1
2095,193,2,72,题库,3,2,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"骑士在一张的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的出发，并且访问棋盘上的每个格子。给你一个的整数矩阵，由范围内的不同整数组成，其中表示单元格是骑士访问的第个单元格。骑士的行动是从下标开始的。如果表示了骑士的有效巡视方案，返回；否则返回。，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。
",n==grid.length==grid[i].length3<=n<=70<=grid[row][col]<n*ngrid中的所有整数互不相同,1,5
2096,135,2,36,题库,1,2,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由正整数组成的数组和一个整数。如果的子集中，任意两个整数的绝对差均不等于，则认为该子数组是一个子集。返回数组中且的子集数目。的子集定义为：可以经由删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。,"1<=nums.length<=201<=nums[i],k<=1000",1,3
2097,100,2,131,题库,1,1,1,0,0,1,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个整数。在一步操作中，你可以对中的任一元素加上或减去。数组的MEX(minimumexcluded)是指其中数组中缺失的最小非负整数。返回在执行上述操作后，的最大MEX,"例如，如果nums=[1,2,3]且value=2，你可以选择nums[0]减去value，得到nums=[-1,2,3]例如，[-1,2,3]的MEX是，而[1,0,3]的MEX是1<=nums.length,value<=10-10<=nums[i]<=10",1,4
2098,85,2,117,题库,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,袋子中装有一些物品，每个物品上都标记着数字、或。给你四个非负整数、、和。袋子最初包含：现计划从这些物品中恰好选出件物品。返回所有可行方案中，物品上所标记数字之和的最大值。,"numOnes件标记为的物品。numZeroes件标记为的物品。numNegOnes件标记为的物品。0<=numOnes,numZeros,numNegOnes<=500<=k<=numOnes+numZeros+numNegOnes",0,2
2099,82,3,94,题库,1,2,0,0,0,2,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，数组长度为。你可以执行无限次下述运算：如果你能通过上述运算使得成为严格递增数组，则返回；否则返回。中的每个元素都严格大于其前面的元素。,选择一个之前未选过的下标，并选择一个严格小于nums[i]的质数，从nums[i]中减去1<=nums.length<=10001<=nums[i]<=1000nums.length==n,1,5
2100,101,2,76,题库,2,1,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给你一个正整数数组。同时给你一个长度为的整数数组。第个查询中，你需要将中所有元素变成。你可以执行以下操作次：请你返回一个长度为的数组，其中是将中所有元素变成的操作次数。，每次查询后，数组变回最开始的值。,"将数组里一个元素或者n==nums.lengthm==queries.length1<=n,m<=101<=nums[i],queries[i]<=10",0,4
2101,179,2,132,题库,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个节点的无向无根树，节点编号从到。给你整数和一个长度为的二维整数数组，其中表示树中节点和之间有一条边。再给你一个长度为的数组，其中可能为也可能为，表示节点处有一个金币。一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。如果你多次经过一条边，每一次经过都会给答案加一。,"收集距离当前节点距离为以内的所有金币，或者移动到树中一个相邻节点。n==coins.length1<=n<=3*100<=coins[i]<=1edges.length==n-1edges[i].length==20<=a,b<n!=bedges表示一棵合法的树。",0,4
2102,55,2,66,题库,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给你两个只包含1到9之间数字的数组和，每个数组中的元素，请你返回的数字，两个数组都包含这个数字的某个数位。
","1<=nums1.length,nums2.length<=91<=nums1[i],nums2[i]<=9每个数组中，元素互不相同",0,3
2103,84,2,212,题库,2,1,1,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个字符串，一个字符的字符串和一个长度与相同的整数数组。是一个子字符串中所有字符对应价值之和。空字符串的开销是。定义如下：请你返回字符串的所有子字符串中的最大开销。,如果字符不在字符串chars中，那么它的价值是它在字母表中的位置（下标从比方说，'a'的价值为'b'的价值为，以此类推，'z'的价值为否则，如果这个字符在chars中的位置为，那么它的价值就是vals[i]1<=s.length<=10只包含小写英文字母。1<=chars.length<=26chars只包含小写英文字母，且互不相同vals.length==chars.length-1000<=vals[i]<=1000,1,4
2104,145,2,55,题库,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个整数。数组是一个循环数组。换句话说，数组中的最后一个元素的下一个元素是数组中的第一个元素，数组中第一个元素的前一个元素是数组中的最后一个元素。你可以执行下述运算任意次：执行运算使每个长度为的的元素总和都相等，返回所需要的最少运算次数。是数组的一个连续部分。,选中arr中任意一个元素，并使其值加上或减去1<=k<=arr.length<=101<=arr[i]<=10,0,4
2105,126,2,67,题库,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,现有一个含个顶点的图，每个顶点按从到标记。图中的边由二维整数数组表示，其中表示顶点和之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。返回图中环的长度。如果不存在环，则返回。是指以同一节点开始和结束，并且路径中的每条边仅使用一次。,"2<=n<=10001<=edges.length<=1000edges[i].length==20<=u,v<n!=v不存在重复的边",0,2
2106,107,3,29,题库,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个仅由和组成的二进制字符串。如果子字符串中且其中的数量等于的数量，则认为的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。返回中最长的平衡子字符串长度。子字符串是字符串中的一个连续字符序列。,1<=s.length<=50'0'<=s[i]<='1',0,1
2107,78,2,88,题库,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组。请你创建一个满足以下条件的二维数组：返回结果数组。如果存在多种答案，则返回其中任何一种。请注意，二维数组的每一行上可以存在不同数量的元素。,二维数组应该包含数组nums中的元素。二维数组中的每一行都包含的整数。二维数组的行数应尽可能1<=nums.length<=2001<=nums[i]<=nums.length,1,2
2108,100,2,125,题库,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有两只老鼠和块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。下标为处的奶酪被吃掉的得分为：给你一个正整数数组，一个正整数数组，和一个非负整数。请你返回第一只老鼠恰好吃掉块奶酪的情况下，得分为多少。,"如果第一只老鼠吃掉，则得分为reward1[i]如果第二只老鼠吃掉，则得分为reward2[i]1<=n==reward1.length==reward2.length<=101<=reward1[i],reward2[i]<=10000<=k<=n",0,4
2109,211,3,152,题库,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个整数和一个在范围以内的整数，它们表示一个长度为且下标从开始的数组，数组中除了下标为处是以外，其他所有数都是。同时给你一个整数数组，它包含数组中的一些位置。中第个位置表示，题目保证。你可以对进行操作。一次操作中，你选择大小为的一个，并将它。在任何一次翻转操作后，你都需要确保中唯一的不会到达任何中的位置。换句话说，始终。请你返回一个数组，对于之间的任意下标，是将放到位置处的翻转操作次数，如果无法放到位置处，此数为。,子数组指的是一个数组里一段连续的元素序列。对于所有的ans[i]相互之间独立计算。将一个数组中的元素指的是将数组中的值变成相反顺序1<=n<=100<=p<=n-10<=banned.length<=n-10<=banned[i]<=n-11<=k<=nbanned[i]!=pbanned中的值互不相同,1,3
2110,71,2,176,题库,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个下标从开始的二维整数数组。返回位于至少一条上的最大。如果任一对角线上均不存在质数，返回注意：在上图中，一条对角线是，而另一条对角线是。,如果某个整数大于，且不存在除和自身之外的正整数因子，则认为该整数是一个质数。如果存在整数，使得nums[i][i]=val或者nums[i][nums.length-i-1]=val，则认为整数val位于nums的一条对角线上。1<=nums.length<=300nums.length==nums.length1<=nums[i][j]<=4*10,0,4
2111,61,2,32,题库,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。现有一个长度等于的数组。对于满足且的所有，等于所有之和。如果不存在这样的，则令等于。返回数组,1<=nums.length<=100<=nums[i]<=10,0,3
2112,118,2,53,题库,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个整数。请你从中找到个下标对，每个下标对对应数值取差值，你需要使得这个差值的。同时，你需要确保每个下标在这个下标对中最多出现一次。对于一个下标对和，这一对的差值为，其中表示的。请你返回个下标对对应数值的。,1<=nums.length<=100<=nums[i]<=100<=p<=(nums.length)/2,0,3
2113,86,3,155,题库,1,2,1,3,0,0,0,0,1,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的整数矩阵。你一开始的位置在格子。当你在格子的时候，你可以移动到以下格子之一：请你返回到达格子需要经过的最少移动格子数，如果无法到达右下角格子，请你返回。,"满足j<k<=grid[i][j]+j的格子(i,k)（向右移动），或者满足i<k<=grid[i][j]+i的格子(k,j)（向下移动）。m==grid.lengthn==grid[i].length1<=m,n<=101<=m*n<=100<=grid[i][j]<m*ngrid[m-1][n-1]==0",1,7
2114,55,4,0,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你编写一个函数，检查给定的值是否是给定类或超类的实例。可以传递给函数的数据类型没有限制。例如，值或类可能是。,,0,0
2115,74,2,19,题库,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一段代码实现一个数组方法，使任何数组都可以调用方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回。你可以假设数组是的输出结果。,0<=arr.length<=1000,1,0
2116,57,2,35,题库,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"请你编写并返回一个函数，它接收一个整型参数n。这个函数最初返回n，每次调用它时返回前一个值加1的值(,,，等等)。",-1000<=n<=1000最多对counter()进行1000次调用,1,0
2117,44,2,15,题库,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一个异步函数，它接收一个正整数参数，并休眠这么多毫秒。要求此函数可以解析任何值。,1<=millis<=1000,1,0
2118,173,2,52,题库,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,编写一个类，它允许获取和设置键-值对，并且每个键都有一个。该类有三个公共方法：：接收参数为整型键、整型值和以毫秒为单位的持续时间。一旦到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回，否则返回。如果该键已经存在，则它的值和持续时间都应该被覆盖。：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回。：返回未过期键的总数。,0<=key<=100<=value<=100<=duration<=1000方法调用总数不会超过100,1,0
2119,88,3,216,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你编写一个函数，它接收另一个函数作为输入，并返回该函数的后的结果。是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。你可以假设有个可能的输入函数：、和。,"sum接收两个整型参数和，并返回a+bfib接收一个整型参数，如果n<=1则返回，否则返回fib(n-1)+fib(n-2)factorial接收一个整型参数，如果n<=1则返回，否则返回factorial(n-1)*n0<=a,b<=101<=n<=10atmost10functioncallsatmost10attemptstoaccesscallCountinputfunctionissum,fib,orfactorial",0,0
2120,216,3,69,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你编写一段代码为所有数组实现方法，该方法将1D数组转换为以蜗牛排序的模式的2D数组。无效的输入值应该输出一个空数组。当时。这个输入被认为是无效的。蜗牛排序从左上角的单元格开始，从当前数组的第一个值开始。然后，它从上到下遍历第一列，接着移动到右边的下一列，并从下到上遍历它。将这种模式持续下去，每列交替变换遍历方向，直到覆盖整个数组。例如，当给定输入数组，当且时，需要输出矩阵如下图所示。注意，矩阵沿箭头方向对应于原数组中数字的顺序,0<=nums.length<=2501<=nums[i]<=10001<=rowsCount<=2501<=colsCount<=250,0,0
2121,158,3,78,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你编写一个函数，它接收一个和它的深度，并返回该数组的后的结果。是一种包含整数或其他的递归数据结构。数组是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于时，才应该执行扁平化操作。第一层数组中元素的深度被认为是0。请在没有使用内置方法的前提下解决这个问题。,0<=arr的元素个数<=100<=arr的子数组个数<=10maxDepth<=1000-1000<=eachnumber<=10000<=n<=1000,0,0
2122,130,3,49,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一个函数，它的参数为一个整数数组、一个计算函数和初始值。返回一个数组的值。你可以定义一个数组的值，然后应用以下操作：，，，直到数组中的每个元素都被处理完毕。返回的最终值。如果数组的长度为0，它应该返回的值。请你在不使用内置数组方法的前提下解决这个问题。,0<=nums.length<=10000<=nums[i]<=10000<=init<=1000,0,0
2123,267,3,77,题库,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你编写一个函数，接收参数为另一个函数和一个以毫秒为单位的时间，并返回该函数的后的结果。方法是一个函数，它的执行被延迟了毫秒，如果在这个时间窗口内再次调用它，它的执行将被取消。你编写的防抖函数也应该接收传递的参数。例如，假设，函数分别在、和时调用。前两个函数调用将被取消，第三个函数调用将在执行。如果改为，则第一个调用将被取消，第二个调用将在执行，第三个调用将在执行。上图展示了了防抖函数是如何转换事件的。其中，每个矩形表示100ms，反弹时间为400ms。每种颜色代表一组不同的输入。请在不使用lodash的函数的前提下解决该问题。,0<=t<=10001<=calls.length<=100<=calls[i].t<=10000<=calls[i].inputs.length<=10,1,0
2124,88,3,53,题库,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一个函数，它接收一个函数数组，并返回一个新的函数，它是函数数组的。的为。一个空函数列表的是。你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。,-1000<=x<=10000<=functions.length<=1000所有函数都接受并返回一个整型,1,0
2125,121,3,64,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,现给定一个函数，返回该函数的一个版本。一个的函数是一个函数，它不会被相同的输入调用两次。而是会返回一个缓存的值。函数可以是任何函数，对它所接受的值类型没有任何限制。如果两个输入值在JavaScript中使用运算符比较时相等，则它们被视为相同。,1<=inputs.length<=100<=inputs.flat().length<=10inputs[i][j]!=NaN,0,0
2126,176,3,28,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你编写一段可应用于所有数组的代码，使任何数组调用方法时，它返回对该数组的结果。数组是一个对象，其中的每个键都是的输出的一个数组，该数组中含有原数组中具有该键的所有项。提供的回调函数将接受数组中的项并返回一个字符串类型的键。每个值列表的顺序应该与元素在数组中出现的顺序相同。任何顺序的键都是可以接受的。请在不使用lodash的函数的前提下解决这个问题。,0<=array.length<=10fn返回一个字符串,0,0
2127,100,3,58,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数数组和一个过滤函数，并返回一个过滤后的数组。函数接受一个或两个参数：应该只包含使表达式的值为的中的元素。是指返回参数为的值。请在不使用内置的Array.filter方法的情况下解决该问题。,arr[i]-arr中的数字-arr[i]的索引0<=arr.length<=1000-10<=arr[i]<=10,0,0
2128,76,3,41,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写一个函数，这个函数接收一个整数数组和一个映射函数，通过该映射函数返回一个新的数组。返回数组的创建语句应为。请你在不使用内置方法的前提下解决这个问题。,0<=arr.length<=1000-10<=arr[i]<=10fn返回一个数,0,0
2129,73,4,111,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一个函数，它接受一个异步函数和一个以毫秒为单位的时间。它应根据限时函数返回一个有效果的函数。函数接受提供给函数的参数。函数应遵循以下规则：,"如果在毫秒的时间限制内完成，函数应返回结果。如果的执行超过时间限制，限时函数应拒绝并返回字符串""TimeLimitExceeded""0<=inputs.length<=100<=t<=1000fn返回一个Promise对象",0,0
2130,83,2,112,题库,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个下标从开始的整数矩阵。矩阵中某一列的宽度是这一列数字的最大。请你返回一个大小为的整数数组，其中是第列的宽度。一个有个数位的整数，如果是非负数，那么为，否则为。,"比方说，如果grid=[[-10],[3],[12]]，那么唯一一列的宽度是，因为-10的字符串长度为m==grid.lengthn==grid[i].length1<=m,n<=100-10<=grid[r][c]<=10",1,2
2131,69,2,105,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,定义一个数组的为：定义一个数组的为转换数组中所有元素的和。给你一个下标从开始长度为的整数数组，请你返回一个长度为的数组，其中是前缀的分数。,conver[i]=arr[i]+max(arr[0..i])，其中max(arr[0..i])是满足0<=j<=i的所有arr[j]中的最大值。1<=nums.length<=101<=nums[i]<=10,0,2
2132,102,2,30,题库,0,2,3,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一棵二叉树的根，请你将每个节点的值替换成该节点的所有。如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为。请你返回修改值之后，树的根。，一个节点的深度指的是从树根节点到这个节点经过的边数。,"树中节点数目的范围是[1,101<=Node.val<=10",1,5
2133,53,1,384,题库,0,0,3,0,0,0,1,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个有个节点的图，节点编号为到。图中的初始边用数组表示，其中表示从到有一条代价为的边。请你实现一个类：,"Graph(intn,int[][]edges)初始化图有个节点，并输入初始边。addEdge(int[]edge)向边集中添加一条边，其中edge=[from,to,edgeCost]。数据保证添加这条边之前对应的两个节点之间没有有向边。intshortestPath(intnode1,intnode2)返回从节点node1到node2的路径最小代价。如果路径不存在，返回。一条路径的代价是路径中所有边代价之和。1<=n<=1000<=edges.length<=n*(n-1)edges[i].length==edge.length==30<=from,to,from,to,node1,node2<=n-11<=edgeCost,edgeCost<=10图中任何时候都不会有重边和自环。调用addEdge至多100次。调用shortestPath至多100次。",1,4
2134,86,3,51,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个大小为的二进制矩阵，请你找出包含最多的行的下标（从开始）以及这一行中的数目。如果有多行包含最多的1，只需要选择的那一行。返回一个由行下标和该行中1的数量组成的数组。,"m==mat.lengthn==mat[i].length1<=m,n<=100mat[i][j]为或",0,2
2135,65,3,62,题库,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个下标从开始的整数数组和。的等于满足能被整除的下标的数量。返回最大的整数。如果有多个整数具有最大得分，则返回数值最小的一个。,"1<=nums.length,divisors.length<=10001<=nums[i],divisors[i]<=10",1,1
2136,77,3,40,题库,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个字符串，你可以向其中任何位置插入""a""、""b""或""c""任意次，返回使需要插入的最少字母数。如果字符串可以由""abc""串联多次得到，则认为该字符串。","1<=word.length<=50word仅由字母""a""、""b""和""c""组成。",0,4
2137,198,2,131,题库,1,2,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,现有一棵无向、无根的树，树中有个节点，按从到编号。给你一个整数和一个长度为的二维整数数组，其中表示树中节点和之间存在一条边。每个节点都关联一个价格。给你一个整数数组，其中是第个节点的价格。给定路径的是该路径上所有节点的价格之和。另给你一个二维整数数组，其中表示您从节点开始第次旅行，并通过任何你喜欢的路径前往节点。在执行第一次旅行之前，你可以选择一些并将价格减半。返回执行所有旅行的最小价格总和。,"1<=n<=50edges.length==n-10<=a,b<=n-1edges表示一棵有效的树price.length==nprice[i]是一个偶数1<=price[i]<=10001<=trips.length<=1000<=start,end<=n-1",1,5
2138,47,2,16,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一个生成器函数，并返回一个可以生成的生成器对象。的递推公式为。这个数列的前几个数字是。,0<=callCount<=50,0,0
2139,87,2,63,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现给定一个整数的，请你返回一个生成器对象，按照的顺序逐个生成整数。是一个递归数据结构，包含整数和其他。是从左到右遍历每个数组，在遇到任何整数时生成它，遇到任何数组时递归应用。,0<=arr.flat().length<=100<=arr.flat()[i]<=10maxNestingDepth<=10,0,0
2140,412,6,65,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,有时候你会有一个长时间运行的任务，并且你可能希望在它完成之前取消它。为了实现这个目标，请你编写一个名为的函数，它接收一个生成器对象，并返回一个包含两个值的数组：一个和一个对象。你可以假设生成器函数只会生成promise对象。你的函数负责将promise对象解析的值传回生成器。如果promise被拒绝，你的函数应将该错误抛回给生成器。如果在生成器完成之前调用了取消回调函数，则你的函数应该将错误抛回给生成器。该错误应该是字符串（而不是一个对象）。如果错误被捕获，则返回的promise应该解析为下一个生成或返回的值。否则，promise应该被拒绝并抛出该错误。不应执行任何其他代码。当生成器完成时，您的函数返回的promise应该解析为生成器返回的值。但是，如果生成器抛出错误，则返回的promise应该拒绝并抛出该错误。下面是您的代码应如何使用的示例：如果相反，没有被调用或者在之后才被调用，那么Promise应被解析为。,cancelledAt==nullor0<=cancelledAt<=1000generatorFunction返回一个生成器对象,0,0
2141,75,2,35,题库,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数表示列车正点到站的时间（单位：小时），另给你一个正整数表示列车延误的小时数。返回列车实际到站的时间。注意，该问题中的时间采用24小时制。,1<=arrivaltime<241<=delayedTime<=24,0,1
2142,60,3,8,题库,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个正整数，请你计算在范围内能被、、整除的所有整数之和。返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。,1<=n<=10,0,3
2143,124,3,71,题库,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为的整数数组，请你求出每个长度为的子数组的。一个子数组的定义为：如果子数组中第是，那么美丽值为第小的数，否则美丽值为。请你返回一个包含个整数的数组，表示数组中从第一个下标开始，每个长度为的子数组的。子数组指的是数组中一段连续的元素序列。,子数组指的是数组中一段连续的元素序列。n==nums.length1<=n<=101<=k<=n1<=x<=k-50<=nums[i]<=50,0,3
2144,95,2,85,题库,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。你可以对数组执行以下操作次：请你返回使数组中所有元素都等于的操作次数。如果无法让数组全部变成，请你返回。两个正整数的最大公约数指的是能整除这两个数的最大正整数。,选择一个满足0<=i<n-1的下标，将nums[i]或者nums[i+1]两者之一替换成它们的最大公约数。2<=nums.length<=501<=nums[i]<=10,0,3
2145,59,2,43,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组和一个整数。你需要执行以下操作次，最大化你的得分：请你返回执行以上操作恰好次后的最大得分。,1<=nums.length<=1001<=nums[i]<=1001<=k<=100,0,2
2146,90,2,61,题库,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个下标从开始长度为的整数排列和。和的定义为数组，其中是数组和到下标为之前公共元素的数目。请你返回和的。如果一个长度为的数组包含到的元素恰好一次，我们称这个数组是一个长度为的。,"1<=A.length==B.length==n<=501<=A[i],B[i]<=n题目保证和两个数组都是个元素的排列。",0,2
2147,116,2,143,题库,2,2,0,1,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始大小为的二维整数数组，其中下标在处的整数表示：一位渔夫可以从任意格子出发，然后执行以下操作任意次：请你返回渔夫最优策略下，可以捕捞多少条鱼。如果没有水域格子，请你返回。格子的格子为，，和，前提是相邻格子在网格图内。,"如果grid[r][c]=0，那么它是一块如果grid[r][c]>0，那么它是一块，且包含grid[r][c]条鱼。捕捞格子(r,c)处所有的鱼，或者移动到相邻的格子。m==grid.lengthn==grid[i].length1<=m,n<=100<=grid[i][j]<=10",1,5
2148,39,3,87,题库,2,2,1,2,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个包含若干整数的数组，你需要执行以下操作：请你返回需要多少个操作使为空。,如果数组中第一个元素是当前数组中的最小值，则删除它。否则，将第一个元素移动到数组的1<=nums.length<=10-10<=nums[i]<=10nums中的元素互不相同,0,7
2149,91,3,146,题库,2,0,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个下标从开始的整数数组和，分别表示玩家1和玩家2击中的瓶数。保龄球比赛由轮组成，每轮的瓶数恰好为。假设玩家在第轮中击中个瓶子。玩家第轮的价值为：玩家的得分是其轮价值的总和。返回,"如果玩家在该轮的前两轮的任何一轮中击中了个瓶子，则为否则，为如果玩家1的得分高于玩家2的得分，则为如果玩家2的得分高于玩家1的得分，则为如果平局，则为n==player1.length==player2.length1<=n<=10000<=player1[i],player2[i]<=10",1,2
2150,94,2,113,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个的整数。和都包含范围内的整数。从下标开始遍历中的每个下标，并将包含整数的单元格涂色。请你找出中在的某一行或某一列上都被涂色且下标最小的元素，并返回其下标。,"m==mat.lengthn=mat[i].lengtharr.length==m*n1<=m,n<=101<=m*n<=101<=arr[i],mat[r][c]<=m*narr中的所有整数互不相同mat中的所有整数互不相同",1,3
2151,136,2,181,题库,1,0,3,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个数组，其中表示你的初始位置位于二维空间上的。另给你一个数组，其中表示你的目标位置。从位置到空间中任一其他位置的代价是。给你一个二维数组，表示空间中存在的一些特殊路径。其中表示第条特殊路径可以从到，但成本等于。你可以使用每条特殊路径任意次数。返回从到所需的最小代价。,"start.length==target.length==21<=startX<=targetX<=101<=startY<=targetY<=101<=specialRoads.length<=200specialRoads[i].length==5startX<=x1,x2<=targetXstartY<=y1,y2<=targetY1<=cost<=10",1,4
2152,165,2,119,题库,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,如果一个字符串满足以下条件，则称其为：给你一个长度为的美丽字符串和一个正整数。请你找出并返回一个长度为的美丽字符串，该字符串还满足：在字典序大于的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。对于长度相同的两个字符串和，如果字符串在与字符串不同的第一个位置上的字符字典序更大，则字符串的字典序大于字符串。,"它由英语小写字母表的前个字母组成。它不包含任何长度为或更长的回文子字符串。例如，""abcd""的字典序比""abcc""更大，因为在不同的第一个位置（第四个字符）上的字典序大于1<=n==s.length<=104<=k<=26是一个美丽字符串",1,2
2153,44,2,94,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你写一个函数.这个函数接收一个初始的整数值并返回一个包含三个函数的对象。这三个函数是：,increment()将当前值加1并返回。decrement()将当前值减1并返回。reset()将当前值设置为init并返回。-1000<=init<=1000总调用次数不会超过1000,0,0
2154,46,1,127,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个函数，它返回一个新的函数，返回的函数与原始函数完全相同，只不过它确保最多被调用一次。,第一次调用返回的函数时，它应该返回与相同的结果。第一次后的每次调用，它应该返回undefined1<=calls.length<=101<=calls[i].length<=1002<=JSON.stringify(calls).length<=1000,0,0
2155,34,2,18,题库,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"请你编写一个名为的函数。它应该返回一个新的函数，该函数总是返回。
",0<=args.length<=10,1,0
2156,122,2,35,题库,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的数组，数组长度为。的数组可以用一个长度为的数组表示，其中等于前缀中不同元素的数目后缀中不同元素的数目。返回的数组。注意表示的一个从下标开始到下标结束的子数组（包含下标和对应元素）。特别需要说明的是，如果，则表示一个空子数组。,1<=n==nums.length<=501<=nums[i]<=50,0,2
2157,45,3,291,题库,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。实现类：,FrequencyTracker()：使用一个空数组初始化FrequencyTracker对象。voidadd(intnumber)：添加一个number到数据结构中。voiddeleteOne(intnumber)：从数据结构中删除一个number。数据结构可能不包含number，在这种情况下不删除任何内容。boolhasFrequency(intfrequency):如果数据结构中存在出现frequency次的数字，则返回true，否则返回false1<=number<=101<=frequency<=10最多调用adddeleteOne和hasFrequency2*10,0,2
2158,133,2,74,题库,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、长度为的数组。一开始，所有元素都是（值为）的。给你一个二维整数数组，其中。对于每个操作，你需要将数组中下标为的格子染色为。请你返回一个长度与相等的数组，其中是前个操作，相邻元素颜色相同的数目。更正式的，是执行完前个操作后，的下标中，满足且的数目。,1<=n<=101<=queries.length<=10queries[i].length==20<=index<=n-11<=color<=10,0,1
2159,158,2,113,题库,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数表示一棵里面节点的数目，节点编号从到。根节点编号为，树中每个非叶子节点都有两个孩子，分别是左孩子和右孩子。树中每个节点都有一个值，用下标从开始、长度为的整数数组表示，其中是第个节点的值。每次操作，你可以将树中节点的值。你可以执行操作次。你的目标是让根到每一个的路径值相等。请你返回需要执行增加操作多少次。,满二叉树指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有2个节点，且所有叶子节点距离根节点距离相同。路径值指的是路径上所有节点的值之和。3<=n<=10n+1是的幂cost.length==n1<=cost[i]<=10,0,5
2160,128,4,74,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个数组和一个块大小，返回一个的数组。的数组包含了中的原始元素，但是每个子数组的长度都是。如果不能被整除，那么最后一个子数组的长度可能小于。你可以假设该数组是的输出结果。换句话说，它是有效的JSON。请你在不使用lodash的函数的情况下解决这个问题。,arrisavalidJSONarray2<=JSON.stringify(arr).length<=101<=size<=arr.length+1,0,0
2161,62,2,171,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串。中每个元素都是一位乘客的信息，信息用长度为的字符串表示，表示方式如下：请你返回乘客中年龄的人数。,前十个字符是乘客的手机号码。接下来的一个字符是乘客的性别。接下来两个字符是乘客的年龄。最后两个字符是乘客的座位号。1<=details.length<=100details[i].length==15details[i]中的数字只包含'0'到'9'details[i][10]是'M''F'或者'O'之一。所有乘客的手机号码和座位号互不相同。,0,2
2162,51,2,58,题库,4,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的二维整数数组。一开始你的分数为。你需要执行以下操作直到矩阵变为空：请你返回最后的。,1<=nums.length<=3001<=nums[i].length<=5000<=nums[i][j]<=10,0,5
2163,74,2,40,题库,1,1,0,0,2,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始长度为的整数数组和一个整数。每一次操作中，你可以选择一个数并将它乘。你最多可以进行次操作，请你返回的最大值。表示两个整数和的运算。,1<=nums.length<=101<=nums[i]<=101<=k<=15,0,4
2164,78,2,110,题库,2,0,0,0,1,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的整数数组，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的定义为：请你返回所有可能的英雄组的之和。由于答案可能非常大，请你将结果对,"...表示这组英雄在数组中的下标。那么这组英雄的力量为max(nums[],nums[]...nums[*min(nums[],nums[]...nums[1<=nums.length<=101<=nums[i]<=10",0,4
2165,208,2,100,题库,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,个朋友在玩游戏。这些朋友坐成一个圈，按从到编号。从第个朋友的位置开始顺时针移动步会到达第个朋友的位置（），而从第个朋友的位置开始顺时针移动步会回到第个朋友的位置。游戏规则如下：第个朋友接球。换句话说，在第轮中持有球的那位朋友需要将球传递给距离他顺时针方向步的朋友。当某个朋友第2次接到球时，游戏结束。在整场游戏中没有接到过球的朋友是。给你参与游戏的朋友数量和一个整数，请按升序排列返回包含所有输家编号的数组作为答案。,接着，第个朋友将球传给距离他顺时针方向步的朋友。然后，接球的朋友应该把球传给距离他顺时针方向2*k步的朋友。接着，接球的朋友应该把球传给距离他顺时针方向3*k步的朋友，以此类推。1<=k<=n<=50,0,3
2166,100,3,136,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,下标从开始、长度为的数组是由同样长度为的原始通过计算相邻值的派生而来。特别地，对于范围内的每个下标：给你一个数组，请判断是否存在一个能够派生得到的。如果存在满足要求的原始二进制数组，返回；否则，返回。,如果i=n-1，那么derived[i]=original[i]⊕original[0]否则derived[i]=original[i]⊕original[i+1]二进制数组是仅由和组成的数组。n==derived.length1<=n<=10derived中的值不是就是,0,2
2167,65,2,149,题库,2,1,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、大小为的矩阵，矩阵由若干整数组成。你可以从矩阵第一列中的单元格出发，按以下方式遍历：返回你在矩阵中能够的次数。,"从单元格(row,col)可以移动到(row-1,col+1)(row,col+1)和(row+1,col+1)三个单元格中任一满足值大于当前单元格的单元格。m==grid.lengthn==grid[i].length2<=m,n<=10004<=m*n<=101<=grid[i][j]<=10",1,3
2168,135,2,73,题库,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数。现有一个包含个顶点的图，顶点按从到编号。给你一个二维整数数组其中表示顶点和之间存在一条边。返回图中的数量。如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为。如果连通分量中每对节点之间都存在一条边，则称其为。,"1<=n<=500<=edges.length<=n*(n-1)/2edges[i].length==20<=a,b<=n-1!=b不存在重复的边",0,3
2169,152,2,95,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,增强所有函数，使其具有方法。该方法接受一个对象作为第一个参数，以及任意数量的附加参数。成为函数的上下文。附加参数将传递给该函数（即方法所属的函数）。例如，如果有以下函数：调用将输出。这是因为上下文未定义。然而，调用将输出。上下文被正确设置，函数输出了适当的结果。请在不使用内置的方法的情况下解决这个问题。,typeofargs[0]=='object'andargs[0]!=null1<=args.length<=1002<=JSON.stringify(args[0]).length<=10,0,0
2170,73,4,618,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个类。这个接口与Node.js或DOM的EventTarget接口相似，但有一些差异。应该允许订阅事件和触发事件。你的类应该有以下两个方法：,subscribe-这个方法接收两个参数：一个作为字符串的事件名和一个回调函数。当事件被触发时，这个回调函数将被调用。一个事件应该能够有多个监听器。当触发带有多个回调函数的事件时，应按照订阅的顺序依次调用每个回调函数。应返回一个结果数组。你可以假设传递给subscribe的回调函数都不是引用相同的。subscribe方法还应返回一个对象，其中包含一个unsubscribe方法，使用户可以取消订阅。当调用unsubscribe方法时，回调函数应该从订阅列表中删除，并返回undefined。emit-这个方法接收两个参数：一个作为字符串的事件名和一个可选的参数数组，这些参数将传递给回调函数。如果没有订阅给定事件的回调函数，则返回一个空数组。否则，按照它们被订阅的顺序返回所有回调函数调用的结果数组。1<=actions.length<=10values.length===actions.length所有测试用例都是有效的。例如，你不需要处理取消一个不存在的订阅的情况。只有4种不同的操作：EventEmitteremitsubscribe和unsubscribe。EventEmitter操作没有参数。emit操作接收1或2个参数。第一个参数是要触发的事件名，第二个参数传递给回调函数。subscribe操作接收2个参数，第一个是事件名，第二个是回调函数。unsubscribe操作接收一个参数，即之前进行订阅的顺序（从0开始）。,0,0
2171,42,3,142,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,创建一个名为的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：,"当使用运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。当在实例上调用String()函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，[1,2,3]0<=nums.length<=10000<=nums[i]<=1000注意：nums是传递给构造函数的数组。",0,0
2172,112,2,26,题库,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个仅由英文字符组成的字符串。你可以对此字符串执行一些操作，在每一步操作中，你可以从中删除或子字符串。通过执行操作，删除所有和子串，返回可获得的最终字符串的可能长度。，删除子串后，重新连接出的字符串可能会产生新的或子串。,1<=s.length<=100仅由大写英文字母组成,0,3
2173,168,3,27,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个由组成的字符串，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母中的一个字符。请你执行，使变成一个。如果执行操作次数的方案不止一种，则只需选取的方案。对于两个长度相同的字符串和，在和出现不同的第一个位置，如果该位置上中对应字母比中对应字母在字母表中出现顺序更早，则认为的字典序比的字典序要小。返回最终的回文字符串。,1<=s.length<=1000仅由小写英文字母组成,0,2
2174,33,2,61,题库,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给你一个正整数，请你返回的。的定义为所有满足以下条件的数的平方和：,1<=i<=ni*i的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于1<=n<=1000,0,2
2175,211,3,150,题库,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个个节点的图，节点编号为到，再给你一个整数数组，其中表示节点和之间有一条边权为的边。部分边的边权为（），其他边的边权都为数（）。你需要将所有边权为的边都修改为范围中的，使得从节点到节点的为整数。如果有修改方案可以使和之间的最短距离等于，你可以返回任意一种方案。如果存在使到最短距离为的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个。你不能修改一开始边权为正数的边。,"1<=n<=1001<=edges.length<=n*(n-1)/2edges[i].length==30<=a,b<n=-1或者1<=w<=10!=b0<=source,destination<nsource!=destination1<=target<=10输入的图是连通图，且没有自环和重边。",0,3
2176,25,2,41,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"请你编写一个函数，返回传递给该函数的参数数量。
",argsArr是一个有效的JSON数组0<=argsArr.length<=100,0,0
2177,53,3,118,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请你编写一个名为的函数，用于帮助开发人员测试他们的代码。它应该接受任何值并返回一个包含以下两个函数的对象。,"toBe(val)接受另一个值并在两个值相等（===）时返回true。如果它们不相等，则应抛出错误""NotEqual""notToBe(val)接受另一个值并在两个值不相等（!==）时返回true。如果它们相等，则应抛出错误""Equal""",0,0
2178,102,3,48,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现给定一个对象或数组，返回一个。与原始对象相同，只是将包含值的键移除。该操作适用于对象及其嵌套对象。数组被视为索引作为键的对象。当返回时，值被视为值。你可以假设是的输出结果。换句话说，它是有效的JSON。,obj是一个有效的JSON对象2<=JSON.stringify(obj).length<=10,0,0
2179,150,2,50,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，它表示一个商店里若干巧克力的价格。同时给你一个整数，表示你一开始拥有的钱数。你必须购买两块巧克力，而且剩余的钱数必须是。同时你想最小化购买两块巧克力的总花费。请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回。注意剩余钱数必须是非负数。,2<=prices.length<=501<=prices[i]<=1001<=money<=100,0,2
2180,85,2,109,题库,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串和一个单词字典。你需要将分割成若干个的子字符串，每个子字符串都在中出现过。中可能会有一些不在任何子字符串中。请你采取最优策略分割，使剩下的字符。,1<=s.length<=501<=dictionary.length<=501<=dictionary[i].length<=50dictionary[i]和只包含小写英文字母。dictionary中的单词互不相同。,0,5
2181,122,2,32,题库,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你一个下标从开始的整数数组，它表示一个班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个小组，且这个小组的最大，如果这个小组里的学生下标为,,,...,，那么这个小组的实力值定义为。请你返回老师创建的小组能得到的最大实力值为多少。",1<=nums.length<=13-9<=nums[i]<=9,0,4
2182,127,3,32,题库,1,0,0,1,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始的整数数组，你可以在一些下标之间遍历。对于两个下标和（），当且仅当时，我们可以在两个下标之间通行，其中是两个数的。你需要判断数组中两个满足的下标和，是否存在若干次通行可以从遍历到。如果任意满足条件的下标对都可以遍历，那么返回，否则返回。,1<=nums.length<=101<=nums[i]<=10,0,4
2183,34,2,37,题库,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个用字符串表示的正整数，请你以字符串形式返回不含尾随零的整数。,1<=num.length<=1000num仅由数字到组成num不含前导零,0,1
2184,147,2,142,题库,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、大小为的二维矩阵，请你求解大小同样为的答案矩阵。矩阵中每个单元格的值可以按下述方式进行计算：然后。返回矩阵。是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。如果单元格和单元格属于同一条对角线且，则单元格属于单元格的左上对角线。类似地，可以定义右下对角线。,"topLeft[r][c]为矩阵grid中单元格(r,c)左上角对角线上不同值的数量。bottomRight[r][c]为矩阵grid中单元格(r,c)右下角对角线上不同值的数量。m==grid.lengthn==grid[i].length1<=m,n,grid[i][j]<=50",0,3
2185,81,2,110,题库,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、长度为的二进制字符串，你可以对其执行两种操作：返回使字符串内所有字符需要的。字符意味着：如果原来的值是'0'，则反转后值变为'1'，反之亦然。,选中一个下标并且反转从下标到下标（包括下标和下标）的所有字符，成本为i+1选中一个下标并且反转从下标到下标n-1（包括下标和下标n-1）的所有字符，成本为n-i1<=s.length==n<=10s[i]为'0'或'1',0,3
2186,157,3,67,题库,3,3,0,0,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始、大小为的整数矩阵，你可以选择任一单元格作为。从起始单元格出发，你可以移动到中的任何其他单元格，但前提是目标单元格的值当前单元格的值。你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。请你找出从某个单元开始访问矩阵所能访问的。返回一个表示可访问单元格最大数量的整数。,"m==mat.lengthn==mat[i].length1<=m,n<=101<=m*n<=10-10<=mat[i][j]<=10",1,6
2187,100,3,69,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,现给定一个函数，一个参数数组和一个以毫秒为单位的超时时间，返回一个取消函数。在经过毫秒的延迟后，应该调用函数，并将作为参数传递。在毫秒的延迟过程中，在毫秒时调用了。并且在这种情况下，函数不应该被调用。,fn是一个函数args是一个有效的JSON数组1<=args.length<=1020<=t<=100010<=cancelT<=1000,0,0
2188,59,3,74,题库,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的字符串，重复执行下述操作次：请你通过执行上述操作任意次，使的长度。返回一个表示字符串的长度的整数。,在字符串中选出一个下标，并使为字符串下标处的字符。并在（如果有）和（如果有）各删除一个距离的字符1<=s.length<=100仅由小写英文字母组成,0,2
2189,109,3,64,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始、长度为的整数排列。如果排列的第一个数字等于且最后一个数字等于，则称其为。你可以执行多次下述操作，直到将变成一个：返回使变成所需的最小操作次数。是一个长度为的整数序列，其中包含从到的每个数字恰好一次。,选择nums中相邻的两个元素，然后交换它们。2<=nums.length==n<=501<=nums[i]<=50nums是一个,0,2
2190,85,2,159,题库,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数和一个下标从开始的，其中。一开始，给你一个下标从开始的矩阵，所有元素均为。每一个查询，你需要执行以下操作之一：请你执行完所有查询以后，返回矩阵中所有整数的和。,如果type==0，将第index行的元素全部修改为val，覆盖任何之前的值。如果type==1，将第index列的元素全部修改为val，覆盖任何之前的值。1<=n<=101<=queries.length<=5*10queries[i].length==30<=type<=10<=index<n0<=val<=10,0,2
2191,86,2,84,题库,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个数字字符串和，以及两个整数和。如果一个整数满足以下条件，我们称它是一个好整数：请你返回好整数的数目。答案可能很大，请返回答案对取余后的结果。注意，表示各位数字之和。,num1<=x<=num2min_sum<=digit_sum(x)<=max_sum1<=num1<=num2<=101<=min_sum<=max_sum<=400,1,3
2192,90,3,185,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个异步函数数组，返回一个新的promise对象。数组中的每个函数都不接受参数并返回一个promise。resolve条件：reject条件：请在不使用内置的函数的情况下解决。,当所有从functions返回的promise都成功解析时。promise的解析值应该是一个按照它们在functions中的顺序排列的promise的解析值数组。当任何从functions返回的promise被拒绝时。promise也会被拒绝，并返回第一个拒绝的原因。函数functions是一个返回Promise的函数数组1<=functions.length<=10,0,0
2193,142,3,171,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,现给定两个数组和，返回一个新的数组。两个输入数组中的每个对象都包含一个字段。是一个通过将和连接而成的数组。的长度应为唯一值的长度。返回的数组应按排序。如果一个存在于一个数组中但不存在于另一个数组中，则该对象应包含在结果数组中且不进行修改。如果两个对象共享一个，则它们的属性应进行合并：,如果一个键只存在于一个对象中，则该键值对应该包含在对象中。如果一个键在两个对象中都包含，则arr2中的值应覆盖arr1中的值。arr1和arr2都是有效的JSON数组在arr1和arr2中都有唯一的键值id2<=JSON.stringify(arr1).length<=102<=JSON.stringify(arr2).length<=10,0,0
2194,66,2,37,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定两个promise对象和，返回一个新的promise。和都会被解析为一个数字。返回的Promise应该解析为这两个数字的和。
",promise1和promise2都是被解析为一个数字的promise对象,0,0
2195,83,3,48,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个数组和一个函数，返回一个排序后的数组。你可以假设只返回数字，并且这些数字决定了的排序顺序。必须按照的输出值排序。你可以假设对于给定的数组，不会返回重复的数字。,arr是一个有效的JSON数组fn是一个函数，返回一个数字1<=arr.length<=5*10,0,0
2196,60,3,69,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,现给定一个函数，一个参数数组和一个时间间隔，返回一个取消函数。函数应该立即使用调用，并且在每个毫秒内再次调用，直到调用。,fn是一个函数args是一个有效的JSON数组1<=args.length<=1020<=t<=100010<=cancelT<=1000,0,0
2197,107,2,494,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,设计一个类。该类应提供加法、减法、乘法、除法和乘方等数学运算功能。同时，它还应支持连续操作的方法链式调用。类的构造函数应接受一个数字作为的初始值。你的类应包含以下方法：结果与实际结果相差在范围内的解被认为是正确的。,"add-将给定的数字value与result相加，并返回更新后的Calculator对象。subtract-从result中减去给定的数字value，并返回更新后的Calculator对象。multiply-将result乘以给定的数字value，并返回更新后的Calculator对象。divide-将result除以给定的数字value，并返回更新后的Calculator对象。如果传入的值为，则抛出错误""Divisionbyzeroisnotallowed""power-计算result的幂，指数为给定的数字value，并返回更新后的Calculator对象。（result=result^valuegetResult-返回result的值。2<=actions.length<=2*101<=values.length<=2*10-1actions[i]是""Calculator"",""add"",""subtract"",""multiply"",""divide"",""power"",和""getResult""其中的元素最后一个操作总是""getResult""values是一个数字的JSON数组",0,0
2198,37,3,60,题库,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个对象或数组，判断它是否为空。你可以假设对象或数组是通过解析得到的。,一个空对象不包含任何键值对。一个空数组不包含任何元素。2<=JSON.stringify(obj).length<=10,0,0
2199,89,2,21,题库,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个三位数整数。如果经过以下修改得到的数字包含数字到各一次且不包含任何，那么我们称数字是：如果是迷人的，返回，否则返回。两个数字表示把它们首尾相接连在一起。比方说和连接得到。,与数字2*n和3*n100<=n<=999,0,2
2200,113,3,29,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串，这个字符串只包含到的数字字符。如果一个字符串中至多有一对相邻字符是相等的，那么称这个字符串是。例如，、、、和是半重复字符串，而和不是。请你返回中最长子字符串的长度。一个是一个字符串中一段连续的字符。,1<=s.length<=50'0'<=s[i]<='9',0,2
2201,412,2,373,题库,2,0,0,0,1,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从开始的整数数组表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。给你一个字符串，每个字符按顺序分别表示每个机器人移动的方向。表示机器人往左或者数轴的负方向移动，表示机器人往右或者数轴的正方向移动。当两个机器人相撞时，它们开始沿着原本相反的方向移动。请你返回指令重复执行秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对取余后返回。当两个机器人在同一时刻占据相同的位置时，就会相撞。例如，如果一个机器人位于位置0并往右移动，另一个机器人位于位置2并往左移动，下一秒，它们都将占据位置1，并改变方向。再下一秒钟后，第一个机器人位于位置0并往左移动，而另一个机器人位于位置2并往右移动。例如，如果一个机器人位于位置0并往右移动，另一个机器人位于位置1并往左移动，下一秒，第一个机器人位于位置0并往左行驶，而另一个机器人位于位置1并往右移动。,"对于坐标在和的两个机器人，(i,j)和(j,i)视为相同的坐标对。也就是说，机器人视为无差别的。当机器人相撞时，它们立即改变它们的前进时间，这个过程不消耗任何时间。当两个机器人在同一时刻占据相同的位置时，就会相撞。例如，如果一个机器人位于位置0并往右移动，另一个机器人位于位置2并往左移动，下一秒，它们都将占据位置1，并改变方向。再下一秒钟后，第一个机器人位于位置0并往左移动，而另一个机器人位于位置2并往右移动。例如，如果一个机器人位于位置0并往右移动，另一个机器人位于位置1并往左移动，下一秒，第一个机器人位于位置0并往左行驶，而另一个机器人位于位置1并往右移动。2<=nums.length<=10-2*10<=nums[i]<=2*100<=d<=10nums.length==s.length只包含'L'和'R'nums[i]互不相同。",0,4
2202,214,3,63,题库,2,1,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个下标从开始大小为的二进制矩阵。从原矩阵中选出若干行构成一个行的子集，如果子集中任何一列的和至多为子集大小的一半，那么我们称这个子集是。更正式的，如果选出来的行子集大小（即行的数量）为k，那么每一列的和至多为。请你返回一个整数数组，它包含好子集的行下标，请你将子集中的元素返回。如果有多个好子集，你可以返回任意一个。如果没有好子集，请你返回一个空数组。一个矩阵的行，是删除中某些（也可能不删除）行后，剩余行构成的元素集合。,m==grid.lengthn==grid[i].length1<=m<=101<=n<=5grid[i][j]要么是，要么是,0,4
2203,56,3,48,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，数组由组成，请你找出并返回数组中既不是也不是的数字，如果不存在这样的数字，返回。返回所选整数。,1<=nums.length<=1001<=nums[i]<=100nums中的所有数字互不相同,0,2
2204,70,3,100,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个仅由小写英文字母组成的字符串。在一步操作中，你可以完成以下行为：返回执行上述操作后可以获得的的字符串。是字符串中的一个连续字符序列。,选则的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b'用'a'替换，'a'用'z'替换。1<=s.length<=3*10仅由小写英文字母组成,0,2
2205,120,2,78,题库,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个长度为、下标从开始的整数数组，表示收集不同巧克力的成本。每个巧克力都对应一个不同的类型，最初，位于下标的巧克力就对应第个类型。在一步操作中，你可以用成本执行下述行为：假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。,同时修改所有巧克力的类型，将巧克力的类型修改为类型((i+1)modn)1<=nums.length<=10001<=nums[i]<=101<=x<=10,1,2
2206,90,3,154,题库,2,1,2,2,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个长度为、下标从开始的整数数组和，另给你一个下标从开始的二维数组，其中。对于第个查询，在所有满足且的下标中，找出的，如果不存在满足条件的则返回。返回数组其中是第个查询的答案。,"nums1.length==nums2.lengthn==nums1.length1<=n<=101<=nums1[i],nums2[i]<=101<=queries.length<=10queries[i].length==2==queries[i][1]==queries[i][2]1<=x,y<=10",0,7
2207,165,2,31,题库,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,卡车有两个油箱。给你两个整数，表示主油箱中的燃料（以升为单位），表示副油箱中的燃料（以升为单位）。该卡车每耗费升燃料都可以行驶km。每当主油箱使用了升燃料时，如果副油箱至少有升燃料，则会将升燃料从副油箱转移到主油箱。返回卡车可以行驶的最大距离。注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗升燃料时突然且立即发生。,"1<=mainTank,additionalTank<=100",0,2
2208,73,2,70,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,给你一个整数数组。将分成两个数组：和，并满足下述条件：分区值的计算方法是。其中，表示数组中的最大元素，表示数组中的最小元素。返回表示分区值的整数。,数组nums中的每个元素都属于数组nums1或数组nums2两个数组都分区值2<=nums.length<=101<=nums[i]<=10,0,2
2209,81,2,91,题库,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，它包含个的正整数。如果的一个排列满足以下条件，我们称它是一个特别的排列：请你返回特别排列的总数目，由于答案可能很大，请将它对后返回。,对于0<=i<n-1的下标，要么nums[i]%nums[i+1]==0，要么nums[i+1]%nums[i]==02<=nums.length<=141<=nums[i]<=10,0,3
2210,65,2,161,题库,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个长度为下标从开始的整数数组和，分别表示给堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：请你返回刷完堵墙最少开销为多少。,一位需要的油漆匠，刷第堵墙需要花费time[i]单位的时间，开销为cost[i]单位的钱。一位的油漆匠，刷一堵墙的时间为单位，开销为。但是必须在付费油漆匠时，免费油漆匠才会工作。1<=cost.length<=500cost.length==time.length1<=cost[i]<=101<=time[i]<=500,1,2
2211,77,3,118,题库,3,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的数组，数组中包含的字符串。如果字符串与字符串满足以下条件，我们称它们可以匹配：请你返回数组中的匹配数目。注意，每个字符串最多匹配一次。,字符串words[i]等于words[j]的反转字符串。0<=i<j<words.length1<=words.length<=50words[i].length==2words包含的字符串互不相同。words[i]只包含小写英文字母。,0,4
2212,135,2,12,题库,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你三个整数，和。这三个整数表示你有个字符串，个字符串，和个字符串。你需要选择这些字符串中的部分字符串（可以全部选择也可以一个都不选择），将它们按顺序连接得到一个新的字符串。新字符串不能包含子字符串或者。请你返回新字符串的最大可能长度。是一个字符串中一段连续的字符序列。,"1<=x,y,z<=50",0,3
2213,139,3,111,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的数组，它包含个字符串。定义操作表示将字符串和连在一起，得到。如果的最后一个字符与的第一个字符相等，连接后两个字符中的一个会被。比方说，。你需要执行次操作。令，从直到，对于第个操作，你可以执行以下操作之一：你的任务是使的长度。请你返回一个整数，表示的最小长度。,"str=join(stri-1,words[i])str=join(words[i],stri-11<=words.length<=10001<=words[i].length<=50words[i]中只包含小写英文字母。",0,2
2214,125,2,121,题库,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数，表示服务器的总数目，再给你一个下标从开始的整数数组，其中表示id为的服务器在时收到了一个请求。同时给你一个整数和一个下标从开始的整数数组。请你返回一个长度等于的数组，其中表示在时间区间内没有收到请求的服务器数目。注意时间区间是个闭区间。,1<=n<=101<=logs.length<=101<=queries.length<=10logs[i].length==21<=logs[i][0]<=n1<=logs[i][1]<=101<=x<=10x<queries[i]<=10,0,4
2215,97,2,48,题库,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组。如果下标对、满足，如果的和的，则认为和是一组。返回中的总数目。对于两个整数和，如果不存在大于1的整数可以整除它们，则认为和。换而言之，如果，则认为和互质，其中是和。,2<=nums.length<=1001<=nums[i]<=9999nums[i]%10!=0,0,3
2216,76,2,24,题库,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数：和。在一步操作中，你需要从范围中选出一个整数，并从减去。请你计算，要想使等于需要执行的最少操作数，并以整数形式返回。如果无法使等于，返回。,1<=num1<=10-10<=num2<=10,0,2
2217,103,2,31,题库,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二元数组。如果数组中的某个子数组只存在个值为的元素，则认为该子数组是一个。请你统计将数组划分成若干的方法数，并以整数形式返回。由于数字可能很大，返回其对之后的结果。子数组是数组中的一个连续元素序列。,1<=nums.length<=100<=nums[i]<=1,0,2
2218,344,3,146,题库,3,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,现有个机器人，编号从开始，每个机器人包含在路线上的位置、健康度和移动方向。给你下标从开始的两个整数数组、和一个字符串（为表示或表示）。中的所有整数。所有机器人以沿给定方向在路线上移动。如果两个机器人移动到相同位置，则会发生。如果两个机器人发生碰撞，则将的机器人从路线中，并且另一个机器人的健康度。幸存下来的机器人将会继续沿着与之前的方向前进。如果两个机器人的健康度相同，则将二者都从路线中移除。请你确定全部碰撞后幸存下的所有机器人的，并按照原来机器人编号的顺序排列。即机器人1（如果幸存）的最终健康度，机器人2（如果幸存）的最终健康度等。如果不存在幸存的机器人，则返回空数组。在不再发生任何碰撞后，请你以数组形式，返回所有剩余机器人的健康度（按机器人输入中的编号顺序）。位置可能是乱序的。,"1<=positions.length==healths.length==directions.length==n<=101<=positions[i],healths[i]<=10directions[i]=='L'或directions[i]=='R'positions中的所有值互不相同",0,4
2219,88,3,135,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组和一个整数。请你从的子数组中找出以下标开头、下标结尾且满足以下条件的：以整数形式返回满足题目要求的最长子数组的长度。是数组中的一个连续非空元素序列。,"nums[l]%2==0对于范围[l,r-1]内的所有下标nums[i]%2!=nums[i+1]%2对于范围[l,r]内的所有下标nums[i]<=threshold1<=nums.length<=1001<=nums[i]<=1001<=threshold<=100",0,2
2220,115,2,29,题库,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数。如果两个整数和满足下述条件，则认为二者形成一个质数对：请你以二维有序列表的形式返回符合题目要求的所有，列表需要按的排序。如果不存在符合要求的质数对，则返回一个空数组。质数是大于的自然数，并且只有两个因子，即它本身和。,1<=x<=y<=nx+y==n和都是质数1<=n<=10,0,4
2221,67,2,95,题库,1,0,4,0,1,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组。的一个子数组如果满足以下条件，那么它是的：请你返回子数组的总数目。子数组是一个数组中一段连续的元素序列。,"i+1，...，表示子数组中的下标。对于所有满足i<=i,i<=j的下标对，都有0<=|nums[i]-nums[i]|<=21<=nums.length<=101<=nums[i]<=10",1,6
2222,101,2,72,题库,1,0,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,一个长度为下标从开始的整数数组的定义为，在数组中，满足以下条件的下标数目：这里，表示将数组排序后得到的数组。给你一个下标从开始的整数数组，请你返回它所有的之和。子数组指的是一个数组中连续一段的元素序列。,0<=i<n-1，和sarr[i+1]-sarr[i]>11<=nums.length<=10001<=nums[i]<=nums.length,1,3
2223,93,2,122,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始的整数数组。如果中长度为的子数组满足以下条件，我们称它是一个：请你返回中所有子数组中，最长的长度，如果不存在交替子数组，请你返回。子数组是一个数组中一段连续的元素序列。,"大于=s+1下标从开始的子数组与数组,s,s,s,...,s(m-1)%2一样。也就是说，-s=1-s=-1-s=1-s=-1，以此类推，直到s[m-1]-s[m-2]=(-1)2<=nums.length<=1001<=nums[i]<=10",0,2
2224,108,2,178,题库,3,0,1,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组，表示一些石块的初始位置。再给你两个长度下标从开始的整数数组和。在次操作内，你可以改变石块的位置。在第次操作中，你将位置在的所有石块移到位置。完成这些操作后，请你按升序返回所有石块的位置。,"如果一个位置至少有一个石块，我们称这个位置石块。一个位置可能会有多个石块。1<=nums.length<=101<=moveFrom.length<=10moveFrom.length==moveTo.length1<=nums[i],moveFrom[i],moveTo[i]<=10测试数据保证在进行第步操作时，moveFrom[i]处至少有一个石块。",1,4
2225,120,3,50,题库,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个二进制字符串，你需要将字符串分割成一个或者多个，使每个子字符串都是的。如果一个字符串满足以下条件，我们称它是的：请你返回分割后的子字符串的数目。如果无法将字符串分割成美丽子字符串，请你返回。子字符串是一个字符串中一段连续的字符序列。,它不包含前导0。它是的幂的二进制表示。1<=s.length<=15s[i]要么是'0'要么是'1',0,4
2226,149,2,132,题库,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和，表示一个下标从开始的的网格图。给你一个下标从开始的二维整数矩阵，其中表示坐标为的格子是，所有没出现在中的格子都是。一个块定义为网格图中的一个子矩阵。更正式的，对于左上角格子为的块，其中且，包含坐标为，，和的格子。请你返回一个下标从开始长度为的整数数组，表示恰好包含个格子的块的数目。,2<=m<=102<=n<=100<=coordinates.length<=10coordinates[i].length==20<=coordinates[i][0]<m0<=coordinates[i][1]<ncoordinates中的坐标对两两互不相同。,1,3
2227,71,2,42,题库,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个整数和。如果整数可以在执行下述操作不超过次的情况下变为与相等，则称其为：返回所有可达成数字中的最大值。可以证明至少存在一个可达成数字。,"每次操作将的值增加或减少，同时可以选择将num的值增加或减少1<=num,t<=50",1,1
2228,86,3,94,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、由个整数组成的数组和一个整数。你的初始位置在下标。在一步操作中，你可以从下标跳跃到任意满足下述条件的下标：返回到达下标处所需的。如果无法到达下标，返回。,0<=i<j<n-target<=nums[j]-nums[i]<=target2<=nums.length==n<=1000-10<=nums[i]<=100<=target<=2*10,0,2
2229,123,3,60,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给你两个下标从开始的整数数组和，长度均为。让我们定义另一个下标从开始、长度为的整数数组，。对于范围的每个下标，你可以将或的值赋给。你的任务是使用最优策略为赋值，以最大化中的长度。以整数形式表示并返回中子数组的长度。是数组中的一个连续非空元素序列。,"1<=nums1.length==nums2.length==n<=101<=nums1[i],nums2[i]<=10",0,2
2230,77,2,60,题库,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个正整数。你可以对数组执行下述操作：如果你可以使数组中的所有元素都等于，返回；否则，返回。是数组中的一个非空连续元素序列。,从数组中选出长度为的子数组，并将子数组中每个元素都1<=k<=nums.length<=100<=nums[i]<=10,0,2
2231,51,2,35,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个下标从开始、长度为的整数数组。对中的元素而言，如果能够被整除，即，则认为是一个。返回中所有的。,1<=nums.length==n<=501<=nums[i]<=50,0,2
2232,157,2,108,题库,2,1,0,0,1,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个整数。在一步操作中，你可以执行下述指令：数组的定义为数组中由相等元素组成的最长子序列的长度。对数组执行上述操作任意次后，返回数组可能取得的美丽值。你能对每个下标执行此操作。数组的定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。,"在范围[0,nums.length-1]中选择一个此前没有选过的下标nums[i]替换为范围[nums[i]-k,nums[i]+k]内的任一整数。1<=nums.length<=100<=nums[i],k<=10",1,4
2233,204,3,94,题库,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果元素在长度为的整数数组中满足，那么我们称是。其中是在数组中出现的次数。注意，根据这个定义，数组只会有支配元素。给你一个下标从开始长度为的整数数组，数据保证它含有一个支配元素。你需要在下标处将分割成两个数组和，如果一个分割满足以下条件，我们称它是的：这里，表示的一个子数组，它开始于下标，结束于下标，两个端点都包含在子数组内。特别地，如果，那么表示一个空数组。请你返回一个的下标。如果合法分割不存在，返回。,"0<=i<n-1nums[0,...,i]和nums[i+1,...,n-1]的支配元素相同。1<=nums.length<=101<=nums[i]<=10nums有且只有一个支配元素。",0,3
2234,82,2,103,题库,2,0,1,0,1,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一个字符串和一个字符串数组。如果一个字符串不包含中的任何字符串，我们称这个字符串是的。请你返回字符串的一个的长度。指的是一个字符串中一段连续的字符，它可以为空。,1<=word.length<=10word只包含小写英文字母。1<=forbidden.length<=101<=forbidden[i].length<=10forbidden[i]只包含小写英文字母。,1,4
2235,117,4,33,题库,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一个整数数组，如果它是数组的一个排列，我们称它是个数组。（换句话说，它是一个长度为且包含到恰好各一次，包含两次的一个数组）。比方说，，。如果数组是一个好数组，请你返回，否则返回。数组的排列是这些数字按任意顺序排布后重新得到的数组。,1<=nums.length<=1001<=num[i]<=200,0,3
2236,91,2,198,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的字符串，将中的元素重新得到新的字符串，它满足：请你返回结果字母串。元音字母为，，，和，它们可能是小写字母也可能是大写字母，辅音字母是除了这5个字母以外的所有字母。,所有辅音字母都在原来的位置上。更正式的，如果满足0<=i<s.length的下标处的s[i]是个辅音字母，那么t[i]=s[i]元音字母都必须以他们的ASCII值按非递减顺序排列。更正式的，对于满足0<=i<j<s.length的下标和，如果s[i]和s[j]都是元音字母，那么t[i]的ASCII值不能大于t[j]的ASCII值。1<=s.length<=10只包含英语字母表中的大写小写字母。,0,2
2237,74,2,124,题库,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始的整数数组和一个正整数。你在数组的位置处，你可以按照下述规则访问数组中的其他位置：请你返回你能得到的得分之和。，你一开始的分数为。,"如果你当前在位置，那么你可以移动到满足i<j的位置对于你访问的位置，你可以获得分数nums[i]如果你从位置移动到位置且nums[i]和nums[j]的奇偶性不同，那么你将失去分数2<=nums.length<=101<=nums[i],x<=10",0,2
2238,92,2,16,题库,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你两个整数和。请你返回将表示成一些正整数的次幂之和的方案数。换句话说，你需要返回互不相同整数的集合数目，满足。由于答案可能非常大，请你将它对取余后返回。比方说，且，一个表示的方法是。,1<=n<=3001<=x<=5,0,1
2239,51,3,192,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个字符串数组和一个字符，请你按拆分中的每个字符串。返回一个由拆分后的新字符串组成的字符串数组，。,"separator用于决定拆分发生的位置，但它不包含在结果字符串中。拆分可能形成两个以上的字符串。结果字符串必须保持初始相同的先后顺序。1<=words.length<=1001<=words[i].length<=20words[i]中的字符要么是小写英文字母，要么就是字符串"".,|$#@""中的字符（不包括引号）separator是字符串"".,|$#@""中的某个字符（不包括引号）",0,2
2240,54,2,130,题库,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个下标从开始、由正整数组成的数组。你可以在数组上执行下述操作次：返回你可以从最终数组中获得的元素的值。,选中一个同时满足0<=i<nums.length-1和nums[i]<=nums[i+1]的整数。将元素nums[i+1]替换为nums[i]+nums[i+1]，并从数组中删除元素nums[i]1<=nums.length<=101<=nums[i]<=10,0,3
2241,98,3,101,题库,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,HARD,给你一个下标从开始、长度为的数组。你的任务是使用从到的数字创建若干组，并确保每个数字在中使用的次数总共不超过次。此外，还必须满足以下条件：在满足所有条件的情况下，以整数形式返回可以创建的最大组数。,每个组必须由的数字组成，也就是说，单个组内不能存在重复的数字。每个组（除了第一个）的长度必须严格大于前一个组。1<=usageLimits.length<=101<=usageLimits[i]<=10,0,5
2242,181,2,99,题库,0,2,1,0,2,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你一棵（即，一个连通、无向且无环的图），节点为，由编号从到的个节点组成。这棵树用一个长度为、下标从开始的数组表示，其中为节点的父节点，由于节点为根节点，所以。另给你一个长度为的字符串，其中是分配给和之间的边的字符。可以忽略。找出满足，且从到的路径上分配的字符可以形成的所有节点对，并返回节点对的数目。如果一个字符串正着读和反着读都相同，那么这个字符串就是一个。,n==parent.length==s.length1<=n<=10对于所有i>=10<=parent[i]<=n-1均成立parent[0]==-1parent表示一棵有效的树仅由小写英文字母组成,0,5
2243,92,2,44,题库,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,公司里共有名员工，按从到编号。每个员工已经在公司工作了小时。公司要求每位员工工作小时。给你一个下标从开始、长度为的非负整数数组和一个非负整数。请你用整数表示并返回工作至少小时的员工数。,"1<=n==hours.length<=500<=hours[i],target<=10",0,2
2244,59,2,59,题库,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个由整数组成的数组。如果数组中的某个子数组满足下述条件，则称之为：返回数组中的数目。是数组中的一个连续非空序列。,子数组中元素的数目等于整个数组不同元素的数目。1<=nums.length<=10001<=nums[i]<=2000,0,3
2245,73,2,117,题库,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给你三个字符串，和，你的任务是找到长度的字符串，且这三个字符串都是它的。
如果有多个这样的字符串，请你返回的一个。请你返回满足题目要求的字符串。","两个长度相同的字符串和，如果在第一个不相同的字符处，的字母在字母表中比的字母，那么字符串比字符串字典序小子字符串是一个字符串中一段连续的字符序列。1<=a.length,b.length,c.length<=100只包含小写英文字母。",1,3
2246,112,2,87,题库,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给你两个正整数和，都用字符串表示，请你统计闭区间内的数目。如果一个整数相邻数位之间差的绝对值都是，那么这个数字被称为。请你返回一个整数，表示闭区间之间步进数字的数目。由于答案可能很大，请你将它对后返回。步进数字不能有前导0。,"1<=int(low)<=int(high)<101001<=low.length,high.length<=100low和high只包含数字。low和high都不含前导0。",1,2
0,105,2,0,LCP,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"小A和小B在玩猜数字。小B每次从1,2,3中随机选择一个，小A每次也从1,2,3中选择一个猜。他们一共进行三次这个游戏，请返回小A猜对了几次？输入的数组为小A每次的猜测，数组为小B每次的选择。和的长度都等于3。",,1,1
1,121,2,0,LCP,2,0,0,0,0,2,0,0,0,1,1,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。输入的代表连分数的系数（代表上图的，以此类推）。返回一个长度为2的数组，使得连分数的值等于，且最大公约数为1。,,1,4
2,139,3,0,LCP,2,0,1,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,力扣团队买了一个可编程机器人，机器人初始位置在原点。小伙伴事先给机器人输入一串指令，机器人就会这条指令的步骤进行移动。指令有两种：不幸的是，在xy平面上还有一些障碍物，他们的坐标用表示。机器人一旦碰到障碍物就会被。给定终点坐标，返回机器人能否地到达终点。如果能，返回；否则返回。,,1,3
3,151,2,0,LCP,1,1,1,0,2,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为的多米诺骨牌，你想把这些骨牌地覆盖在的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。输入：代表棋盘的大小；是一个的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。输出：一个整数，代表最多能在棋盘上放的骨牌数。,,1,5
4,127,1,0,LCP,1,0,0,2,0,0,0,0,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,力扣决定给一个刷题团队发作为奖励。同时，为了监控给大家发了多少，力扣有时候也会进行查询。该刷题团队的管理模式可以用一棵树表示：力扣想进行的操作有以下三种：返回一个数组，数组里是每次的返回值（发的操作不需要任何返回值）。由于发的很多，请把每次查询的结果模。,,1,3
5,119,2,22,LCP,1,0,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,桌上有堆力扣币，每堆的数量保存在数组中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。输入：输出：解释：第一堆力扣币最少需要拿2次，第二堆最少需要拿1次，第三堆最少需要拿1次，总共4次即可拿完。输入：输出：,1<=n<=41<=coins[i]<=10,1,2
6,194,2,125,LCP,0,3,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,小朋友A在和ta的小伙伴们玩传信息游戏，游戏规则如下：给定总玩家数，以及按关系组成的二维数组。返回信息从小A(编号0)经过轮传递到编号为n-1的小伙伴处的方案数；若不能到达，返回0。输入：输出：解释：信息从小A编号0处开始，经3轮传递，到达编号4。共有3种方案，分别是0->2->0->4，0->2->1->4，0->2->3->4。输入：输出：解释：信息不能从小A处经过2轮传递到编号2,"2<=n<=101<=k<=51<=relation.length<=90,且relation[i].length==20<=relation[i][0],relation[i][1]<n且relation[i][0]!=relation[i][1]",1,4
7,421,3,99,LCP,2,1,0,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（），资源储备（）以及人口数量（）。在游戏开始时（第0天），三种属性的值均为0。随着游戏进程的进行，每一天玩家的三种属性都会对应，我们用一个二维数组来表示每天的增加情况。这个二维数组的每个元素是一个长度为3的一维数组，例如表示第一天三种属性分别增加而第二天分别增加。所有剧情的触发条件也用一个二维数组表示。这个二维数组的每个元素是一个长度为3的一维数组，对于某个剧情的触发条件，如果当前且且，则剧情会被触发。根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为-1。输入：输出:解释：初始时，C=0，R=0，H=0第1天，C=2，R=8，H=4第2天，C=4，R=13，H=4，此时触发剧情0第3天，C=14，R=22，H=12，此时触发剧情2剧情1和3无法触发。输入：输出:输入：输出:,1<=increase.length<=100001<=requirements.length<=1000000<=increase[i]<=100<=requirements[i]<=100000,1,3
8,295,1,37,LCP,1,2,0,1,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由个特殊弹簧排成一排，编号为到。初始有一个小球在编号的弹簧处。若小球在编号为的弹簧处，通过按动弹簧，可以选择把小球向右弹射的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为弹簧处按动弹簧，小球可以弹向到中任意弹簧或者的弹簧（若，则表示小球弹出了机器）。小球位于编号0处的弹簧时不能再向左弹。为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号弹簧弹出整个机器，即向右越过编号的弹簧。输入：输出：解释：小Z最少需要按动3次弹簧，小球依次到达的顺序为0->2->1->6，最终小球弹出了机器。,1<=jump.length<=10^61<=jump[i]<=10000,1,4
9,461,3,29,LCP,0,2,2,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。通常任务之间是存在依赖关系的，即对于某个任务，你需要先他的前导任务（如果非空），才能开始执行该任务。其中为根任务，和为他的两个前导任务（可能为空），为其自身的执行时间。在一个CPU核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。现在，系统有CPU核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。输入：root=[47,74,31]输出：121解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。输入：root=[15,21,null,24,null,27,26]输出：87输入：root=[1,3,2,null,null,4,4]输出：7.5",1<=节点数量<=10001<=单节点执行时间<=1000,1,4
10,427,3,40,LCP,1,0,1,0,0,2,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"某互联网公司一年一度的春招开始了，一共有名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。小A和小B负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中地取一个。现在给定名面试者的能力值，设代表小A和小B的浏览顺序中出现在同一位置的简历数，求的期望。提示：离散的非负随机变量的期望计算公式为。在本题中，由于的取值为0到之间，期望计算公式可以是。输入：输出：解释：由于面试者能力值互不相同，小A和小B的浏览顺序一定是相同的。的期望是3。输入：输出：解释：设两位面试者的编号为0,1。由于他们的能力值都是1，小A和小B的浏览顺序都为从全排列中等可能地取一个。如果小A和小B的浏览顺序都是或者，那么出现在同一位置的简历数为2，否则是0。所以的期望是(2+0+2+0)*1/4=1输入：输出：",1<=scores.length<=10^50<=scores[i]<=10^6,1,4
11,353,2,47,LCP,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,为了提高自己的代码能力，小张制定了刷题计划，他选中了题库中的道题，编号从到，并计划在天内刷完所有的题目（注意，小张不能用多天完成同一题）。在小张刷题计划中，小张需要用的时间完成编号的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。我们定义天中做题时间最多的一天耗时为（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的是多少。输入：输出：解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了3的时间，并且这个值是最小的。输入：输出：解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。,1<=time.length<=10^51<=time[i]<=100001<=m<=1000,1,2
12,620,3,126,LCP,2,2,0,0,2,0,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用'S'表示），和唯一的宝藏地点（用'T'表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用'M'表示），要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用'O'表示），每个石堆都有个足够触发机关的重石。但是由于石头太重，我们一次只能搬石头到指定地点。迷宫中同样有一些墙壁（用'#'表示），我们不能走入墙壁。剩余的都是可随意通行的点（用'.'表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回-1。输入：[""S#O"",""M.."",""M.T""]输出：16解释：最优路线为：S->O,cost=4,去搬石头O->第二行的M,cost=3,M机关触发第二行的M->O,cost=3,我们需要继续回去O搬石头。O->第三行的M,cost=4,此时所有机关均触发第三行的M->T,cost=2，去T点拿宝藏。总步数为16。输入：[""S#O"",""M.#"",""M.T""]输出：-1解释：我们无法搬到石头触发机关输入：[""S#O"",""M.T"",""M..""]输出：17解释：注意终点也是可以通行的。",1<=maze.length<=1001<=maze[i].length<=100maze[i].length==maze[j].lengthS和T有且只有一个0<=M的数量<=160<=O的数量<=40，题目保证当迷宫中存在M时，一定存在至少一个O。,1,6
13,181,2,36,LCP,1,1,0,0,0,2,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,"给定一个整数数组，小李想将切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于1。为了减少他的工作量，请求出最少可以切成多少个子数组。输入：输出：解释：最优切割为[2,3,3,2]和[3,3]。第一个子数组头尾数字的最大公约数为2，第二个子数组头尾数字的最大公约数为3。输入：输出：解释：只有一种可行的切割：[2],[3],[5],[7]",1<=nums.length<=10^52<=nums[i]<=10^6,1,4
14,425,2,129,LCP,1,1,0,0,0,2,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,"小王来到了游乐园，她玩的第一个项目是模拟推销员。有一个二维平面地图，其中散布着个推销点，编号到，不存在三点共线的情况。每两点之间有一条直线相连。游戏没有规定起点和终点，但限定了每次转角的方向。首先，小王需要先选择两个点分别作为起点和终点，然后从起点开始访问剩余个点恰好一次并回到终点。访问的顺序需要满足一串给定的长度为由和组成的字符串，表示从起点出发之后在每个顶点上转角的方向。根据这个提示，小王希望你能够帮她找到一个可行的遍历顺序，输出顺序下标（若有多个方案，输出任意一种）。可以证明这样的遍历顺序一定是存在的。（上图：A->B->C右转；下图：D->E->F左转）输入：输入：解释：[0,2,1,3]是符合""LL""的方案之一。在[0,2,1,3]方案中，0->2->1是左转方向，2->1->3也是左转方向输入：输入：解释：[0,3,1,2]是符合""LR""的方案之一。在[0,3,1,2]方案中，0->3->1是左转方向，3->1->2是右转方向","3<=points.length<=1000且points[i].length==21<=points[i][0],points[i][1]<=10000direction.length==points.length-2direction只包含""L"",""R""",1,4
15,553,3,137,LCP,0,0,1,0,0,2,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,又到了一年一度的春游时间，小吴计划去游乐场游玩1天，游乐场总共有个游乐项目，编号从到。小吴给每个游乐项目定义了一个非负整数值表示自己的喜爱值。两个游乐项目之间会有双向路径相连，整个游乐场总共有条双向路径，保存在二维数组中。小吴计划选择一个游乐项目作为这一天游玩的重点项目。上午小吴准备游玩重点项目以及与项目相邻的两个项目、（项目、与要求是不同的项目，且项目与项目要求相邻），并返回，即存在一条的路径。下午，小吴决定再游玩重点项目以及与相邻的两个项目、，（项目、与要求是不同的项目，且项目与项目要求相邻），并返回，即存在一条的路径。下午游玩项目、可与上午游玩项目、存在重复项目。小吴希望提前安排好游玩路径，使得喜爱值之和最大。请你返回满足游玩路径选取条件的最大喜爱值之和，如果没有这样的路径，返回。注意：一天中重复游玩同一个项目并不能重复增加喜爱值了。例如：上下午游玩路径分别是与那么只能获得的总和。输入：输出：解释：喜爱值之和最高的方案之一是0->1->2->0与0->2->1->0。重复游玩同一点不重复计入喜爱值，返回1+2+3=6输入：输出：解释：无满足要求的游玩路径，返回0输入：输出：解释：喜爱值之和最高的方案之一是3->0->1->3与3->4->5->3。喜爱值最高为7+8+8+9+7=39,"3<=value.length<=100001<=edges.length<=100000<=edges[i][0],edges[i][1]<value.length0<=value[i]<=10000edges中没有重复的边edges[i][0]!=edges[i][1]",1,3
16,352,1,0,LCP,2,0,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作`x`和`y`），请小扣说出计算指令：
-`""A""`运算：使`x=2*x+y`；
-`""B""`运算：使`y=2*y+x`。

在本次游戏中，店家说出的数字为`x=1`和`y=0`，小扣说出的计算指令记作仅由大写字母`A`、`B`组成的字符串`s`，字符串中字符的顺序表示计算顺序，请返回最终`x`与`y`的和为多少。

**示例1：**
>输入：`s=""AB""`
>
>输出：`4`
>
>解释：
>经过一次A运算后，x=2,y=0。
>再经过一次B运算，x=2,y=2。
>最终x与y之和为4。

**提示：**
-`0<=s.length<=10`
-`s`由`'A'`和`'B'`组成


",,1,3
17,1007,2,0,LCP,2,1,0,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"小扣在秋日市集选择了一家早餐摊位，一维整型数组`staple`中记录了每种主食的价格，一维整型数组`drinks`中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过`x`元。请返回小扣共有多少种购买方案。

注意：答案需要以`1e9+7(1000000007)`为底取模，如：计算初始结果为：`1000000008`，请返回`1`

**示例1：**
>输入：`staple=[10,20,5],drinks=[5,5,2],x=15`
>
>输出：`6`
>
>解释：小扣有6种购买方案，所选主食与所选饮料在数组中对应的下标分别是：
>第1种方案：staple[0]+drinks[0]=10+5=15；
>第2种方案：staple[0]+drinks[1]=10+5=15；
>第3种方案：staple[0]+drinks[2]=10+2=12；
>第4种方案：staple[2]+drinks[0]=5+5=10；
>第5种方案：staple[2]+drinks[1]=5+5=10；
>第6种方案：staple[2]+drinks[2]=5+2=7。

**示例2：**
>输入：`staple=[2,1,1],drinks=[8,9,5,1],x=9`
>
>输出：`8`
>
>解释：小扣有8种购买方案，所选主食与所选饮料在数组中对应的下标分别是：
>第1种方案：staple[0]+drinks[2]=2+5=7；
>第2种方案：staple[0]+drinks[3]=2+1=3；
>第3种方案：staple[1]+drinks[0]=1+8=9；
>第4种方案：staple[1]+drinks[2]=1+5=6；
>第5种方案：staple[1]+drinks[3]=1+1=2；
>第6种方案：staple[2]+drinks[0]=1+8=9；
>第7种方案：staple[2]+drinks[2]=1+5=6；
>第8种方案：staple[2]+drinks[3]=1+1=2；

**提示：**
+`1<=staple.length<=10^5`
+`1<=drinks.length<=10^5`
+`1<=staple[i],drinks[i]<=10^5`
+`1<=x<=2*10^5`",,1,4
18,457,2,0,LCP,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集`leaves`，字符串`leaves`仅包含小写字符`r`和`y`，其中字符`r`表示一片红叶，字符`y`表示一片黄叶。
出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。

**示例1：**
>输入：`leaves=""rrryyyrryyyrr""`
>
>输出：`2`
>
>解释：调整两次，将中间的两片红叶替换成黄叶，得到""rrryyyyyyyyrr""

**示例2：**
>输入：`leaves=""ryr""`
>
>输出：`0`
>
>解释：已符合要求，不需要额外操作

**提示：**
-`3<=leaves.length<=10^5`
-`leaves`中只包含字符`'r'`和字符`'y'`",,1,2
19,1008,2,0,LCP,1,2,0,0,0,0,0,0,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,HARD,"小扣打算去秋日市集，由于游客较多，小扣的移动速度受到了人流影响：
-小扣从`x`号站点移动至`x+1`号站点需要花费的时间为`inc`；
-小扣从`x`号站点移动至`x-1`号站点需要花费的时间为`dec`。

现有`m`辆公交车，编号为`0`到`m-1`。小扣也可以通过搭乘编号为`i`的公交车，从`x`号站点移动至`jump[i]*x`号站点，耗时仅为`cost[i]`。小扣可以搭乘任意编号的公交车且搭乘公交次数不限。

假定小扣起始站点记作`0`，秋日市集站点记作`target`，请返回小扣抵达秋日市集最少需要花费多少时间。由于数字较大，最终答案需要对1000000007(1e9+7)取模。

注意：小扣可在移动过程中到达编号大于`target`的站点。

**示例1：**
>输入：`target=31,inc=5,dec=3,jump=[6],cost=[10]`
>
>输出：`33`
>
>解释：
>小扣步行至1号站点，花费时间为5；
>小扣从1号站台搭乘0号公交至6*1=6站台，花费时间为10；
>小扣从6号站台步行至5号站台，花费时间为3；
>小扣从5号站台搭乘0号公交至6*5=30站台，花费时间为10；
>小扣从30号站台步行至31号站台，花费时间为5；
>最终小扣花费总时间为33。


**示例2：**
>输入：`target=612,inc=4,dec=5,jump=[3,6,8,11,5,10,4],cost=[4,7,6,3,7,6,4]`
>
>输出：`26`
>
>解释：
>小扣步行至1号站点，花费时间为4；
>小扣从1号站台搭乘0号公交至3*1=3站台，花费时间为4；
>小扣从3号站台搭乘3号公交至11*3=33站台，花费时间为3；
>小扣从33号站台步行至34站台，花费时间为4；
>小扣从34号站台搭乘0号公交至3*34=102站台，花费时间为4；
>小扣从102号站台搭乘1号公交至6*102=612站台，花费时间为7；
>最终小扣花费总时间为26。


**提示：**
-`1<=target<=10^9`
-`1<=jump.length,cost.length<=10`
-`2<=jump[i]<=10^6`
-`1<=inc,dec,cost[i]<=10^6`",,1,3
20,1112,2,0,LCP,0,2,2,0,0,0,0,1,0,0,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"秋游中的小力和小扣设计了一个追逐游戏。他们选了秋日市集景区中的N个景点，景点编号为1~N。此外，他们还选择了N条小路，满足任意两个景点之间都可以通过小路互相到达，且不存在两条连接景点相同的小路。整个游戏场景可视作一个无向连通图，记作二维数组`edges`，数组中以`[a,b]`形式表示景点a与景点b之间有一条小路连通。

小力和小扣只能沿景点间的小路移动。小力的目标是在最快时间内追到小扣，小扣的目标是尽可能延后被小力追到的时间。游戏开始前，两人分别站在两个不同的景点`startA`和`startB`。每一回合，小力先行动，小扣观察到小力的行动后再行动。小力和小扣在每回合可选择以下行动之一：
-移动至相邻景点
-留在原地

如果小力追到小扣（即两人于某一时刻出现在同一位置），则游戏结束。若小力可以追到小扣，请返回最少需要多少回合；若小力无法追到小扣，请返回-1。

注意：小力和小扣一定会采取最优移动策略。

**示例1：**
>输入：`edges=[[1,2],[2,3],[3,4],[4,1],[2,5],[5,6]],startA=3,startB=5`
>
>输出：`3`
>
>解释：
>![image.png](https://pic.leetcode-cn.com/1597991318-goeHHr-image.png){:height=""250px""}
>
>第一回合，小力移动至2号点，小扣观察到小力的行动后移动至6号点；
>第二回合，小力移动至5号点，小扣无法移动，留在原地；
>第三回合，小力移动至6号点，小力追到小扣。返回3。


**示例2：**
>输入：`edges=[[1,2],[2,3],[3,4],[4,1]],startA=1,startB=3`
>
>输出：`-1`
>
>解释：
>![image.png](https://pic.leetcode-cn.com/1597991157-QfeakF-image.png){:height=""250px""}
>
>小力如果不动，则小扣也不动；否则小扣移动到小力的对角线位置。这样小力无法追到小扣。

**提示：**
-`edges`的长度等于图中节点个数
-`3<=edges.length<=10^5`
-`1<=edges[i][0],edges[i][1]<=edges.length且edges[i][0]!=edges[i][1]`
-`1<=startA,startB<=edges.length且startA!=startB`

",,1,4
21,496,3,0,LCP,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有`n*n`的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色（选择的整行、整列均需涂成黑色），所选行数、列数均可为0。

小扣希望最终的成品上需要有`k`个黑色格子，请返回小扣共有多少种涂色方案。

注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。

**示例1：**
>输入：`n=2,k=2`
>
>输出：`4`
>
>解释：一共有四种不同的方案：
>第一种方案：涂第一列；
>第二种方案：涂第二列；
>第三种方案：涂第一行；
>第四种方案：涂第二行。

**示例2：**
>输入：`n=2,k=1`
>
>输出：`0`
>
>解释：不可行，因为第一次涂色至少会涂两个黑格。

**示例3：**
>输入：`n=2,k=4`
>
>输出：`1`
>
>解释：共有2*2=4个格子，仅有一种涂色方案。

**限制：**
-`1<=n<=6`
-`0<=k<=n*n`


",,1,1
22,929,2,0,LCP,2,0,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"秋日市集上，魔术师邀请小扣与他互动。魔术师的道具为分别写有数字`1~N`的`N`张卡牌，然后请小扣思考一个`N`张卡牌的排列`target`。

魔术师的目标是找到一个数字k（k>=1），使得初始排列顺序为`1~N`的卡牌经过特殊的洗牌方式最终变成小扣所想的排列`target`，特殊的洗牌方式为：
-第一步，魔术师将当前位于**偶数位置**的卡牌（下标自1开始），保持**当前排列顺序**放在位于**奇数位置**的卡牌之前。例如：将当前排列[1,2,3,4,5]位于偶数位置的[2,4]置于奇数位置的[1,3,5]前，排列变为[2,4,1,3,5]；
-第二步，若当前卡牌数量小于等于`k`，则魔术师按排列顺序取走全部卡牌；若当前卡牌数量大于`k`，则取走前`k`张卡牌，剩余卡牌继续重复这两个步骤，直至所有卡牌全部被取走；

卡牌按照魔术师取走顺序构成的新排列为「魔术取数排列」，请返回是否存在这个数字k使得「魔术取数排列」恰好就是`target`，从而让小扣感到大吃一惊。

**示例1：**
>输入：`target=[2,4,3,1,5]`
>
>输出：`true`
>
>解释：排列target长度为5，初始排列为：1,2,3,4,5。我们选择k=2：
>第一次：将当前排列[1,2,3,4,5]位于偶数位置的[2,4]置于奇数位置的[1,3,5]前，排列变为[2,4,1,3,5]。取走前2张卡牌2,4，剩余[1,3,5]；
>第二次：将当前排列[1,3,5]位于偶数位置的[3]置于奇数位置的[1,5]前，排列变为[3,1,5]。取走前2张3,1，剩余[5]；
>第三次：当前排列为[5]，全部取出。
>最后，数字按照取出顺序构成的「魔术取数排列」2,4,3,1,5恰好为target。

**示例2：**
>输入：`target=[5,4,3,2,1]`
>
>输出：`false`
>
>解释：无法找到一个数字k可以使「魔术取数排列」恰好为target。


**提示：**
-`1<=target.length=N<=5000`
-题目保证`target`是`1~N`的一个排列。",,1,3
23,1035,3,0,LCP,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"小扣在秋日市集入口处发现了一个数字游戏。主办方共有`N`个计数器，计数器编号为`0~N-1`。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组`nums`。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。

主办方请小扣回答出一个长度为`N`的数组，第`i`个元素(0<=i<N)表示将`0~i`号计数器**初始**所示数字操作成满足所有条件`nums[a]+1==nums[a+1],(0<=a<i)`的最小操作数。回答正确方可进入秋日市集。

由于答案可能很大，请将每个最小操作数对`1,000,000,007`取余。


**示例1：**
>输入：`nums=[3,4,5,1,6,7]`
>
>输出：`[0,0,0,5,6,7]`
>
>解释：
>i=0，[3]无需操作
>i=1，[3,4]无需操作；
>i=2，[3,4,5]无需操作；
>i=3，将[3,4,5,1]操作成[3,4,5,6],最少5次操作；
>i=4，将[3,4,5,1,6]操作成[3,4,5,6,7],最少6次操作；
>i=5，将[3,4,5,1,6,7]操作成[3,4,5,6,7,8]，最少7次操作；
>返回[0,0,0,5,6,7]。


**示例2：**
>输入：`nums=[1,2,3,4,5]`
>
>输出：`[0,0,0,0,0]`
>
>解释：对于任意计数器编号i都无需操作。

**示例3：**
>输入：`nums=[1,1,1,2,3,4]`
>
>输出：`[0,1,2,3,3,3]`
>
>解释：
>i=0，无需操作；
>i=1，将[1,1]操作成[1,2]或[0,1]最少1次操作；
>i=2，将[1,1,1]操作成[1,2,3]或[0,1,2]，最少2次操作；
>i=3，将[1,1,1,2]操作成[1,2,3,4]或[0,1,2,3]，最少3次操作；
>i=4，将[1,1,1,2,3]操作成[-1,0,1,2,3]，最少3次操作；
>i=5，将[1,1,1,2,3,4]操作成[-1,0,1,2,3,4]，最少3次操作；
>返回[0,1,2,3,3,3]。


**提示：**
-`1<=nums.length<=10^5`
-`1<=nums[i]<=10^3`

",,0,3
24,369,2,0,LCP,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有26个字母**a~z**可以按下，且每个字母最多仅能被按`k`次。

小扣随机按了`n`次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对1000000007(1e9+7)取模。


**示例1：**
>输入：`k=1,n=1`
>
>输出：`26`
>
>解释：由于只能按一次按键，所有可能的字符串为""a"",""b"",...""z""

**示例2：**
>输入：`k=1,n=2`
>
>输出：`650`
>
>解释：由于只能按两次按键，且每个键最多只能按一次，所有可能的字符串（按字典序排序）为""ab"",""ac"",...""zy""

**提示：**
-`1<=k<=5`
-`1<=n<=26*k`


",,0,3
25,689,2,0,LCP,0,1,2,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"小扣参加的秋日市集景区共有$N$个景点，景点编号为$1$~$N$。景点内设有$N-1$条双向道路，使所有景点形成了一个二叉树结构，根结点记为`root`，景点编号即为节点值。

由于秋日市集景区的结构特殊，游客很容易迷路，主办方决定在景区的若干个景点设置导航装置，按照所在景点编号升序排列后定义装置编号为1~M。导航装置向游客发送数据，数据内容为列表`[游客与装置1的相对距离,游客与装置2的相对距离,...,游客与装置M的相对距离]`。由于游客根据导航装置发送的信息来确认位置，因此主办方需保证游客在每个景点接收的数据信息皆不相同。请返回主办方最少需要设置多少个导航装置。

**示例1：**
>输入：`root=[1,2,null,3,4]`
>
>输出：`2`
>
>解释：在景点1、3或景点1、4或景点3、4设置导航装置。
>
>![image.png](https://pic.leetcode-cn.com/1597996812-tqrgwu-image.png){:height=""250px""}



**示例2：**
>输入：`root=[1,2,3,4]`
>
>输出：`1`
>
>解释：在景点3、4设置导航装置皆可。
>
>![image.png](https://pic.leetcode-cn.com/1597996826-EUQRyz-image.png){:height=""200px""}



**提示：**
-`2<=N<=50000`
-二叉树的非空节点值为`1~N`的一个排列。
",,1,3
26,2121,2,0,LCP,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"秋日市集上有个奇怪的黑盒，黑盒的主视图为n\*m的矩形。从黑盒的主视图来看，黑盒的上面和下面各均匀分布有m个小孔，黑盒的左面和右面各均匀分布有n个小孔。黑盒左上角小孔序号为0，按顺时针编号，总共有2*(m+n)个小孔。每个小孔均可以打开或者关闭，初始时，所有小孔均处于关闭状态。每个小孔上的盖子均为镜面材质。例如一个2\*3的黑盒主视图与其小孔分布如图所示:

![image.png](https://pic.leetcode-cn.com/1598951281-ZCBrif-image.png){:height=""200px""}

店长告诉小扣，这里是「几何学的快问快答」，店长可能有两种操作：

-`open(intindex,intdirection)`-若小孔处于关闭状态，则打开小孔，照入光线；否则直接照入光线；
-`close(intindex)`-关闭处于打开状态小孔，店长保证不会关闭已处于关闭状态的小孔；

其中：
-`index`：表示小孔序号
-`direction`：`1`表示光线沿$y=x$方向，`-1`表示光线沿$y=-x$方向。

![image.png](https://pic.leetcode-cn.com/1599620810-HdOlMi-image.png){:height=""200px""}


当光线照至边界时：若边界上的小孔为开启状态，则光线会射出；否则，光线会在小孔之间进行反射。特别地：
1.若光线射向未打开的拐角（黑盒顶点），则光线会原路反射回去；
2.光线自拐角处的小孔照入时，只有一种入射方向（如自序号为0的小孔照入方向只能为`-1`）

![image.png](https://pic.leetcode-cn.com/1598953840-DLiAsf-image.png){:height=""200px""}

请帮助小扣判断并返回店长每次照入的光线从几号小孔射出。


**示例1：**
>输入：
>`[""BlackBox"",""open"",""open"",""open"",""close"",""open""]`
>`[[2,3],[6,-1],[4,-1],[0,-1],[6],[0,-1]]`
>
>输出：`[null,6,4,6,null,4]`
>
>解释：
>BlackBoxb=BlackBox(2,3);//新建一个2x3的黑盒
>b.open(6,-1)//打开6号小孔，并沿y=-x方向照入光线，光线至0号小孔反射，从6号小孔射出
>b.open(4,-1)//打开4号小孔，并沿y=-x方向照入光线，光线轨迹为4-2-8-2-4，从4号小孔射出
>b.open(0,-1)//打开0号小孔，并沿y=-x方向照入光线，由于6号小孔为开启状态，光线从6号小孔射出
>b.close(6)//关闭6号小孔
>b.shoot(0,-1)//从0号小孔沿y=-x方向照入光线，由于6号小孔为关闭状态，4号小孔为开启状态，光线轨迹为0-6-4，从4号小孔射出

**示例2：**
>输入：
>`[""BlackBox"",""open"",""open"",""open"",""open"",""close"",""open"",""close"",""open""]`
>`[[3,3],[1,-1],[5,1],[11,-1],[11,1],[1],[11,1],[5],[11,-1]]`
>
>输出：`[null,1,1,5,1,null,5,null,11]`
>
>解释：
>
>![image.png](https://pic.leetcode-cn.com/1599204202-yGDMVk-image.png){:height=""300px""}
>
>BlackBoxb=BlackBox(3,3);//新建一个3x3的黑盒
>b.open(1,-1)//打开1号小孔，并沿y=-x方向照入光线，光线轨迹为1-5-7-11-1，从1号小孔射出
>b.open(5,1)//打开5号小孔，并沿y=x方向照入光线，光线轨迹为5-7-11-1，从1号小孔射出
>b.open(11,-1)//打开11号小孔，并沿逆y=-x方向照入光线，光线轨迹为11-7-5，从5号小孔射出
>b.open(11,1)//从11号小孔沿y=x方向照入光线，光线轨迹为11-1，从1号小孔射出
>b.close(1)//关闭1号小孔
>b.open(11,1)//从11号小孔沿y=x方向照入光线，光线轨迹为11-1-5，从5号小孔射出
>b.close(5)//关闭5号小孔
>b.open(11,-1)//从11号小孔沿y=-x方向照入光线，光线轨迹为11-1-5-7-11，从11号小孔射出



**提示：**
-`1<=n,m<=10000`
-`1<=操作次数<=10000`
-`direction`仅为`1`或`-1`
-`0<=index<2*(m+n)`
",,1,4
27,452,2,0,LCP,2,1,0,0,1,0,0,0,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"小力将N个零件的报价存于数组`nums`。小力预算为`target`，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。

注意：答案需要以`1e9+7(1000000007)`为底取模，如：计算初始结果为：`1000000008`，请返回`1`


**示例1：**
>输入：`nums=[2,5,3,5],target=6`
>
>输出：`1`
>
>解释：预算内仅能购买nums[0]与nums[2]。

**示例2：**
>输入：`nums=[2,2,1,9],target=10`
>
>输出：`4`
>
>解释：符合预算的采购方案如下：
>nums[0]+nums[1]=4
>nums[0]+nums[2]=3
>nums[1]+nums[2]=3
>nums[2]+nums[3]=10

**提示：**
-`2<=nums.length<=10^5`
-`1<=nums[i],target<=10^5`
",,1,4
28,602,2,0,LCP,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"某乐团的演出场地可视作`num*num`的二维矩阵`grid`（左上角坐标为`[0,0]`)，每个位置站有一位成员。乐团共有`9`种乐器，乐器编号为`1~9`，每位成员持有`1`个乐器。

为保证声乐混合效果，成员站位规则为：自`grid`左上角开始顺时针螺旋形向内循环以`1，2，...，9`循环重复排列。例如当num=`5`时，站位如图所示

![image.png](https://pic.leetcode-cn.com/1616125411-WOblWH-image.png)


请返回位于场地坐标[`Xpos`,`Ypos`]的成员所持乐器编号。

**示例1：**
>输入：`num=3,Xpos=0,Ypos=2`
>
>输出：`3`
>
>解释：
![image.png](https://pic.leetcode-cn.com/1616125437-WUOwsu-image.png)


**示例2：**
>输入：`num=4,Xpos=1,Ypos=2`
>
>输出：`5`
>
>解释：
![image.png](https://pic.leetcode-cn.com/1616125453-IIDpxg-image.png)


**提示：**
-`1<=num<=10^9`
-`0<=Xpos,Ypos<num`",,1,1
29,548,2,0,LCP,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"小扣当前位于魔塔游戏第一层，共有`N`个房间，编号为`0~N-1`。每个房间的补血道具/怪物对于血量影响记于数组`nums`，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；`0`表示房间对血量无影响。

**小扣初始血量为1，且无上限**。假定小扣原计划按房间编号升序访问所有房间补血/打怪，**为保证血量始终为正值**，小扣需对房间访问顺序进行调整，**每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾**。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回-1。


**示例1：**
>输入：`nums=[100,100,100,-250,-60,-140,-50,-50,100,150]`
>
>输出：`1`
>
>解释：初始血量为1。至少需要将nums[3]调整至访问顺序末尾以满足要求。

**示例2：**
>输入：`nums=[-200,-300,400,0]`
>
>输出：`-1`
>
>解释：调整访问顺序也无法完成全部房间的访问。

**提示：**
-`1<=nums.length<=10^5`
-`-10^5<=nums[i]<=10^5`",,1,3
30,939,3,0,LCP,2,3,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"某解密游戏中，有一个N\*M的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于`(n-1,m-1)`位置。迷宫变化规律记录于`maze`中，`maze[i]`表示`i`时刻迷宫的地形状态，`"".""`表示可通行空地，`""#""`表示陷阱。

地形图初始状态记作`maze[0]`，此时小力位于起点`(0,0)`。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。

小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：
+临时消除术：将指定位置在下一个时刻变为空地；
+永久消除术：将指定位置永久变为空地。

请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？

**注意：输入数据保证起点和终点在所有时刻均为空地。**

**示例1：**
>输入：`maze=[["".#."",""#..""],[""..."","".#.""],["".##"","".#.""],[""..#"","".#.""]]`
>
>输出：`true`
>
>解释：
![maze.gif](https://pic.leetcode-cn.com/1615892239-SCIjyf-maze.gif)


**示例2：**
>输入：`maze=[["".#."",""...""],[""..."",""...""]]`
>
>输出：`false`
>
>解释：由于时间不够，小力无法到达终点逃出迷宫。

**示例3：**
>输入：`maze=[[""..."",""..."",""...""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""],["".##"",""###"",""##.""]]`
>
>输出：`false`
>
>解释：由于道路不通，小力无法到达终点逃出迷宫。

**提示：**
-`1<=maze.length<=100`
-`1<=maze[i].length,maze[i][j].length<=50`
-`maze[i][j]`仅包含`"".""`、`""#""`",,1,5
31,671,2,0,LCP,1,1,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"某实验室计算机待处理任务以`[start,end,period]`格式记于二维数组`tasks`，表示完成该任务的时间范围为起始时间`start`至结束时间`end`之间，需要计算机投入`period`的时长，注意：
1.`period`可为不连续时间
2.首尾时间均包含在内

处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。

**示例1：**
>输入：`tasks=[[1,3,2],[2,5,3],[5,6,2]]`
>
>输出：`4`
>
>解释：
>tasks[0]选择时间点2、3；
>tasks[1]选择时间点2、3、5；
>tasks[2]选择时间点5、6；
>因此计算机仅需在时间点2、3、5、6四个时刻保持开机即可完成任务。

**示例2：**
>输入：`tasks=[[2,3,1],[5,5,1],[5,6,2]]`
>
>输出：`3`
>
>解释：
>tasks[0]选择时间点2或3；
>tasks[1]选择时间点5；
>tasks[2]选择时间点5、6；
>因此计算机仅需在时间点2、5、6或3、5、6三个时刻保持开机即可完成任务。

**提示：**
-`2<=tasks.length<=10^5`
-`tasks[i].length==3`
-`0<=tasks[i][0]<=tasks[i][1]<=10^9`
-`1<=tasks[i][2]<=tasks[i][1]-tasks[i][0]+1`",,1,3
32,593,2,0,LCP,1,1,1,0,0,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定N个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第`i`个水缸配备的水桶容量记作`bucket[i]`。小扣有以下两种操作：
-升级水桶：选择任意一个水桶，使其容量增加为`bucket[i]+1`
-蓄水：将全部水桶接满水，倒入各自对应的水缸

每个水缸对应最低蓄水量记作`vat[i]`，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。

注意：实际蓄水量**达到或超过**最低蓄水量，即完成蓄水要求。

**示例1：**
>输入：`bucket=[1,3],vat=[6,8]`
>
>输出：`4`
>
>解释：
>第1次操作升级bucket[0]；
>第2~4次操作均选择蓄水，即可完成蓄水要求。
![vat1.gif](https://pic.leetcode-cn.com/1616122992-RkDxoL-vat1.gif)



**示例2：**
>输入：`bucket=[9,0,1],vat=[0,2,2]`
>
>输出：`3`
>
>解释：
>第1次操作均选择升级bucket[1]
>第2~3次操作选择蓄水，即可完成蓄水要求。

**提示：**
-`1<=bucket.length==vat.length<=100`
-`0<=bucket[i],vat[i]<=10^4`
",,1,3
33,526,2,0,LCP,0,1,2,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,"小扣有一个根结点为`root`的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，模型的每个结点有一个`val`价值。小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过`k`个，求所有染成蓝色的结点价值总和最大是多少？


**示例1：**
>输入：`root=[5,2,3,4],k=2`
>
>输出：`12`
>
>解释：`结点5、3、4染成蓝色，获得最大的价值5+3+4=12`
![image.png](https://pic.leetcode-cn.com/1616126267-BqaCRj-image.png)


**示例2：**
>输入：`root=[4,1,3,9,null,null,2],k=2`
>
>输出：`16`
>
>解释：结点4、3、9染成蓝色，获得最大的价值4+3+9=16
![image.png](https://pic.leetcode-cn.com/1616126301-gJbhba-image.png)



**提示：**
+`1<=k<=10`
+`1<=val<=10000`
+`1<=结点数量<=10000`
",,1,3
34,1000,2,0,LCP,0,0,3,0,0,0,0,1,1,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"小明的电动车电量充满时可行驶距离为`cnt`，每行驶1单位距离消耗1单位电量，且花费1单位时间。小明想选择电动车作为代步工具。地图上共有N个景点，景点编号为0~N-1。他将地图信息以`[城市A编号,城市B编号,两城市间距离]`格式整理在在二维数组`paths`，表示城市A、B间存在双向通路。初始状态，电动车电量为0。每个城市都设有充电桩，`charge[i]`表示第i个城市每充1单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市`start`抵达终点城市`end`。


**示例1：**
>输入：`paths=[[1,3,3],[3,2,1],[2,1,3],[0,1,4],[3,0,5]],cnt=6,start=1,end=0,charge=[2,10,4,1]`
>
>输出：`43`
>
>解释：最佳路线为：1->3->0。
>在城市1仅充3单位电至城市3，然后在城市3充5单位电，行驶至城市5。
>充电用时共3\*10+5\*1=35
>行驶用时3+5=8，此时总用时最短43。
![image.png](https://pic.leetcode-cn.com/1616125304-mzVxIV-image.png)




**示例2：**
>输入：`paths=[[0,4,2],[4,3,5],[3,0,5],[0,1,5],[3,2,4],[1,2,8]],cnt=8,start=0,end=2,charge=[4,1,1,3,2]`
>
>输出：`38`
>
>解释：最佳路线为：0->4->3->2。
>城市0充电2单位，行驶至城市4充电8单位，行驶至城市3充电1单位，最终行驶至城市2。
>充电用时4\*2+2\*8+3\*1=27
>行驶用时2+5+4=11，总用时最短38。

**提示：**
-`1<=paths.length<=200`
-`paths[i].length==3`
-`2<=charge.length==n<=100`
-`0<=path[i][0],path[i][1],start,end<n`
-`1<=cnt<=100`
-`1<=path[i][2]<=cnt`
-`1<=charge[i]<=100`
-题目保证所有城市相互可以到达",,1,3
35,393,2,0,LCP,2,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,HARD,"麻将的游戏规则中，共有两种方式凑成「一组牌」：
-顺子：三张牌面数字连续的麻将，例如[4,5,6]
-刻子：三张牌面数字相同的麻将，例如[10,10,10]

给定若干数字作为麻将牌的数值（记作一维数组`tiles`），请返回所给`tiles`最多可组成的牌组数。

注意：凑成牌组时，每张牌仅能使用一次。

**示例1：**
>输入：`tiles=[2,2,2,3,4]`
>
>输出：`1`
>
>解释：最多可以组合出[2,2,2]或者[2,3,4]其中一组牌。

**示例2：**
>输入：`tiles=[2,2,2,3,4,1,3]`
>
>输出：`2`
>
>解释：最多可以组合出[1,2,3]与[2,3,4]两组牌。

**提示：**
-`1<=tiles.length<=10^5`
-`1<=tiles[i]<=10^9`",,1,3
36,608,2,0,LCP,2,1,0,0,0,3,0,1,1,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"二维平面上有$N$条直线，形式为`y=kx+b`，其中`k`、`b`为整数且`k>0`。所有直线以`[k,b]`的形式存于二维数组`lines`中，不存在重合的两条直线。两两直线之间可能存在一个交点，最多会有$C_N^2$个交点。我们用一个平行于坐标轴的矩形覆盖所有的交点，请问这个矩形最小面积是多少。若直线之间无交点、仅有一个交点或所有交点均在同一条平行坐标轴的直线上，则返回0。

注意：返回结果是浮点数，与标准答案**绝对误差或相对误差**在10^-4以内的结果都被视为正确结果


**示例1：**
>输入：`lines=[[2,3],[3,0],[4,1]]`
>
>输出：`48.00000`
>
>解释：三条直线的三个交点为(3,9)(1,5)和(-1,-3)。最小覆盖矩形左下角为(-1,-3)右上角为(3,9)，面积为48


**示例2：**
>输入：`lines=[[1,1],[2,3]]`
>
>输出：`0.00000`
>
>解释：仅有一个交点(-2，-1）


**限制：**
+`1<=lines.length<=10^5且lines[i].length==2`
+`1<=lines[0]<=10000`
+`-10000<=lines[1]<=10000`
+`与标准答案绝对误差或相对误差在10^-4以内的结果都被视为正确结果`",,1,6
37,1149,4,0,LCP,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"城堡守卫游戏的胜利条件为使恶魔无法从出生点到达城堡。游戏地图可视作`2*N`的方格图，记作字符串数组`grid`，其中：
-`"".""`表示恶魔可随意通行的平地；
-`""#""`表示恶魔不可通过的障碍物，玩家可通过在**平地**上设置障碍物，即将`"".""`变为`""#""`以阻挡恶魔前进；
-`""S""`表示恶魔出生点，将有大量的恶魔该点生成，恶魔可向上/向下/向左/向右移动，且无法移动至地图外；
-`""P""`表示瞬移点，移动到`""P""`点的恶魔可被传送至任意一个`""P""`点，也可选择不传送；
-`""C""`表示城堡。

然而在游戏中用于建造障碍物的金钱是有限的，请返回玩家最少需要放置几个障碍物才能获得胜利。若无论怎样放置障碍物均无法获胜，请返回`-1`。

**注意：**
-地图上可能有一个或多个出生点
-地图上有且只有一个城堡

**示例1**
>输入：`grid=[""S.C.P#P."","".....#.S""]`
>
>输出：`3`
>
>解释：至少需要放置三个障碍物
![image.png](https://pic.leetcode-cn.com/1614828255-uuNdNJ-image.png)


**示例2：**
>输入：`grid=[""SP#P..P#PC#.S"",""..#P..P####.#""]`
>
>输出：`-1`
>
>解释：无论怎样修筑障碍物，均无法阻挡最左侧出生的恶魔到达城堡位置
![image.png](https://pic.leetcode-cn.com/1614828208-oFlpVs-image.png)

**示例3：**
>输入：`grid=[""SP#.C.#PS"",""P.#...#.P""]`
>
>输出：`0`
>
>解释：无需放置障碍物即可获得胜利
![image.png](https://pic.leetcode-cn.com/1614828242-oveClu-image.png)

**示例4：**
>输入：`grid=[""CP.#.P."",""...S..S""]`
>
>输出：`4`
>
>解释：至少需要放置4个障碍物，示意图为放置方法之一
![image.png](https://pic.leetcode-cn.com/1614828218-sIAYkb-image.png)


**提示：**
-`grid.length==2`
-`2<=grid[0].length==grid[1].length<=10^4`
-`grid[i][j]`仅包含字符`"".""`、`""#""`、`""C""`、`""P""`、`""S""`
",,1,3
38,918,2,0,LCP,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"在「力扣挑战赛」开幕式的压轴节目「无人机方阵」中，每一架无人机展示一种灯光颜色。无人机方阵通过两种操作进行颜色图案变换：
-调整无人机的位置布局
-切换无人机展示的灯光颜色


给定两个大小均为`N*M`的二维数组`source`和`target`表示无人机方阵表演的两种颜色图案，由于无人机切换灯光颜色的耗能很大，请返回从`source`到`target`最少需要多少架无人机切换灯光颜色。


**注意：**调整无人机的位置布局时无人机的位置可以随意变动。


**示例1：**
>输入：`source=[[1,3],[5,4]],target=[[3,1],[6,5]]`
>
>输出：`1`
>
>解释：
>最佳方案为
将`[0,1]`处的无人机移动至`[0,0]`处；
将`[0,0]`处的无人机移动至`[0,1]`处；
将`[1,0]`处的无人机移动至`[1,1]`处；
将`[1,1]`处的无人机移动至`[1,0]`处，其灯光颜色切换为颜色编号为`6`的灯光；
因此从`source`到`target`所需要的最少灯光切换次数为1。
>![8819ccdd664e91c78cde3bba3c701986.gif](https://pic.leetcode-cn.com/1628823765-uCDaux-8819ccdd664e91c78cde3bba3c701986.gif){:height=300px}





**示例2：**
>输入：`source=[[1,2,3],[3,4,5]],target=[[1,3,5],[2,3,4]]`
>
>输出：`0`
>解释：
>仅需调整无人机的位置布局，便可完成图案切换。因此不需要无人机切换颜色


**提示：**
`n==source.length==target.length`
`m==source[i].length==target[i].length`
`1<=n,m<=100`
`1<=source[i][j],target[i][j]<=10^4`



",,1,4
39,414,2,0,LCP,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"「力扣挑战赛」心算项目的挑战比赛中，要求选手从`N`张卡牌中选出`cnt`张卡牌，若这`cnt`张卡牌数字总和为偶数，则选手成绩「有效」且得分为`cnt`张卡牌数字总和。
给定数组`cards`和`cnt`，其中`cards[i]`表示第`i`张卡牌上的数字。请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回0。

**示例1：**
>输入：`cards=[1,2,8,9],cnt=3`
>
>输出：`18`
>
>解释：选择数字为1、8、9的这三张卡牌，此时可获得最大的有效得分1+8+9=18。

**示例2：**
>输入：`cards=[3,3,1],cnt=1`
>
>输出：`0`
>
>解释：不存在获取有效得分的卡牌方案。

**提示：**
-`1<=cnt<=cards.length<=10^5`
-`1<=cards[i]<=1000`


",,1,3
40,1344,3,0,LCP,2,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"在`n*m`大小的棋盘中，有黑白两种棋子，黑棋记作字母`""X""`,白棋记作字母`""O""`，空余位置记作`"".""`。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。



![1.gif](https://pic.leetcode-cn.com/1630396029-eTgzpN-6da662e67368466a96d203f67bb6e793.gif){:height=170px}![2.gif](https://pic.leetcode-cn.com/1630396240-nMvdcc-8e4261afe9f60e05a4f740694b439b6b.gif){:height=170px}![3.gif](https://pic.leetcode-cn.com/1630396291-kEtzLL-6fcb682daeecb5c3f56eb88b23c81d33.gif){:height=170px}

「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作`chessboard`。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。

**注意：**
-若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以**继续**翻转白棋
-输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置

**示例1：**
>输入：`chessboard=[""....X."",""....X."",""XOOO.."",""......"",""......""]`
>
>输出：`3`
>
>解释：
>可以选择下在`[2,4]`处，能够翻转白方三枚棋子。

**示例2：**
>输入：`chessboard=["".X."","".O."",""XO.""]`
>
>输出：`2`
>
>解释：
>可以选择下在`[2,2]`处，能够翻转白方两枚棋子。
![2126c1d21b1b9a9924c639d449cc6e65.gif](https://pic.leetcode-cn.com/1626683255-OBtBud-2126c1d21b1b9a9924c639d449cc6e65.gif)

**示例3：**
>输入：`chessboard=[""......."",""......."",""......."",""X......"","".O....."",""..O...."",""....OOX""]`
>
>输出：`4`
>
>解释：
>可以选择下在`[6,3]`处，能够翻转白方四枚棋子。
![803f2f04098b6174397d6c696f54d709.gif](https://pic.leetcode-cn.com/1630393770-Puyked-803f2f04098b6174397d6c696f54d709.gif)



**提示：**
-`1<=chessboard.length,chessboard[i].length<=8`
-`chessboard[i]`仅包含`"".""、""O""`和`""X""`",,1,3
41,838,2,0,LCP,2,1,1,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"「力扣挑战赛」场地外，小力组织了一个套玩具的游戏。所有的玩具摆在平地上，`toys[i]`以`[xi,yi,ri]`的形式记录了第`i`个玩具的坐标`(xi,yi)`和半径`ri`。小扣试玩了一下，他扔了若干个半径均为`r`的圈，`circles[j]`记录了第`j`个圈的坐标`(xj,yj)`。套圈的规则如下：
-若一个玩具被某个圈完整覆盖了（即玩具的任意部分均在圈内或者圈上），则该玩具被套中。
-若一个玩具被多个圈同时套中，最终仅计算为套中一个玩具

请帮助小扣计算，他成功套中了多少玩具。

**注意：**
-输入数据保证任意两个玩具的圆心不会重合，但玩具之间可能存在重叠。


**示例1：**

>输入：`toys=[[3,3,1],[3,2,1]],circles=[[4,3]],r=2`
>
>输出：`1`
>
>解释：如图所示，仅套中一个玩具
![image.png](https://pic.leetcode-cn.com/1629194140-ydKiGF-image.png)


**示例2：**

>输入：`toys=[[1,3,2],[4,3,1],[7,1,2]],circles=[[1,0],[3,3]],r=4`
>
>输出：`2`
>
>解释：如图所示，套中两个玩具
![image.png](https://pic.leetcode-cn.com/1629194157-RiOAuy-image.png){:width=""400px""}



**提示：**
-`1<=toys.length<=10^4`
-`0<=toys[i][0],toys[i][1]<=10^9`
-`1<=circles.length<=10^4`
-`0<=circles[i][0],circles[i][1]<=10^9`
-`1<=toys[i][2],r<=10`
",,0,6
42,1004,2,0,LCP,2,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"前往「力扣挑战赛」场馆的道路上，有一个拥堵的十字路口，该十字路口由两条双向两车道的路交叉构成。由于信号灯故障，交警需要手动指挥拥堵车辆。假定路口没有新的来车且一辆车从一个车道驶入另一个车道所需的时间恰好为一秒钟，长度为4的一维字符串数组`directions`中按照**东、南、西、北**顺序记录了四个方向从最靠近路口到最远离路口的车辆计划开往的方向。其中：
-`""E""`表示向东行驶；
-`""S""`表示向南行驶；
-`""W""`表示向西行驶；
-`""N""`表示向北行驶。

交警每秒钟只能指挥各个车道距离路口最近的一辆车，且每次指挥需要满足如下规则：
-同一秒钟内，一个方向的车道只允许驶出一辆车；
-同一秒钟内，一个方向的车道只允许驶入一辆车；
-同一秒钟内，车辆的行驶路线不可相交。

请返回最少需要几秒钟，该十字路口等候的车辆才能全部走完。

各个车道驶出的车辆可能的行驶路线如图所示：


![图片.png](https://pic.leetcode-cn.com/1630393755-gyPeMM-%E5%9B%BE%E7%89%87.png){:height=""350px""}

**注意：**
-测试数据保证不会出现掉头行驶指令，即某一方向的行驶车辆计划开往的方向不会是当前车辆所在的车道的方向;
-表示堵塞车辆行驶方向的字符串仅用大写字母`""E""`，`""N""`，`""W""`，`""S""`表示。

**示例1：**
>输入：`directions=[""W"",""N"",""ES"",""W""]`
>
>输出：`2`
>
>解释：
>第1秒：东西方向排在最前的车先行，剩余车辆状态`["""",""N"",""S"",""W""]`；
>第2秒：南、西、北方向的车行驶，路口无等待车辆；
>因此最少需要2秒，返回2。

**示例2：**
>输入：`directions=[""NS"",""WE"",""SE"",""EW""]`
>
>输出：`3`
>
>解释：
>第1秒：四个方向排在最前的车均可驶出；
>第2秒：东南方向的车驶出，剩余车辆状态`["""","""",""E"",""W""]`；
>第3秒：西北方向的车驶出。


**提示：**
-`directions.length=4`
-`0<=directions[i].length<=20`
",,1,3
43,299,2,0,LCP,0,2,3,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"「力扣挑战赛」开幕式开始了，空中绽放了一颗二叉树形的巨型焰火。
给定一棵二叉树`root`代表焰火，节点值表示巨型焰火这一位置的颜色种类。请帮小扣计算巨型焰火有多少种不同的颜色。


**示例1：**
>输入：`root=[1,3,2,1,null,2]`
>
>输出：`3`
>
>解释：焰火中有3个不同的颜色，值分别为1、2、3

**示例2：**
>输入：`root=[3,3,3]`
>
>输出：`1`
>
>解释：焰火中仅出现1个颜色，值为3

**提示：**
-`1<=节点个数<=1000`
-`1<=Node.val<=1000`


",,1,5
44,860,2,0,LCP,2,4,0,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"「力扣挑战赛」中`N*M`大小的自行车炫技赛场的场地由一片连绵起伏的上下坡组成，场地的高度值记录于二维数组`terrain`中，场地的减速值记录于二维数组`obstacle`中。
-若选手骑着自行车从高度为`h1`且减速值为`o1`的位置到高度为`h2`且减速值为`o2`的相邻位置（上下左右四个方向），速度变化值为`h1-h2-o2`（负值减速，正值增速）。

选手初始位于坐标`position`处且初始速度为1，请问选手可以刚好到其他哪些位置时速度依旧为1。请以二维数组形式返回这些位置。若有多个位置则按行坐标升序排列，若有多个位置行坐标相同则按列坐标升序排列。

**注意：**骑行过程中速度不能为零或负值

**示例1：**
>输入：`position=[0,0],terrain=[[0,0],[0,0]],obstacle=[[0,0],[0,0]]`
>
>输出：`[[0,1],[1,0],[1,1]]`
>
>解释：
>由于当前场地属于平地，根据上面的规则，选手从`[0,0]`的位置出发都能刚好在其他处的位置速度为1。

**示例2：**
>输入：`position=[1,1],terrain=[[5,0],[0,6]],obstacle=[[0,6],[7,0]]`
>
>输出：`[[0,1]]`
>
>解释：
>选手从`[1,1]`处的位置出发，到`[0,1]`处的位置时恰好速度为1。


**提示：**
-`n==terrain.length==obstacle.length`
-`m==terrain[i].length==obstacle[i].length`
-`1<=n<=100`
-`1<=m<=100`
-`0<=terrain[i][j],obstacle[i][j]<=100`
-`position.length==2`
-`0<=position[0]<n`
-`0<=position[1]<m`",,1,6
45,1379,2,0,LCP,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"「力扣挑战赛」有`n`个比赛场馆（场馆编号从`0`开始），场馆之间的通道分布情况记录于二维数组`edges`中，`edges[i]=[x,y]`表示第`i`条通道连接场馆`x`和场馆`y`(即两个场馆相邻)。初始每个场馆中都有一定人数的志愿者（不同场馆人数可能不同），后续`m`天每天均会根据赛事热度进行志愿者人数调配。调配方案分为如下三种：
1.将编号为`idx`的场馆内的志愿者人数减半；
2.将编号为`idx`的场馆相邻的场馆的志愿者人数都加上编号为`idx`的场馆的志愿者人数；
3.将编号为`idx`的场馆相邻的场馆的志愿者人数都减去编号为`idx`的场馆的志愿者人数。

所有的调配信息记录于数组`plans`中，`plans[i]=[num,idx]`表示第`i`天对编号`idx`的场馆执行了第`num`种调配方案。
在比赛结束后对调配方案进行复盘时，不慎将第`0`个场馆的**最终**志愿者人数丢失，只保留了**初始**所有场馆的志愿者总人数`totalNum`，以及记录了第`1~n-1`个场馆的**最终**志愿者人数的一维数组`finalCnt`。请你根据现有的信息求出初始每个场馆的志愿者人数，并按场馆编号顺序返回志愿者人数列表。

**注意：**
-测试数据保证当某场馆进行第一种调配时，该场馆的志愿者人数一定为偶数；
-测试数据保证当某场馆进行第三种调配时，该场馆的相邻场馆志愿者人数不为负数；
-测试数据保证比赛开始时每个场馆的志愿者人数都不超过`10^9`；
-测试数据保证给定的场馆间的道路分布情况中不会出现自环、重边的情况。


**示例1：**
>![image.png](https://pic.leetcode-cn.com/1630061228-gnZsOz-image.png)
>输入：
>`finalCnt=[1,16],totalNum=21,edges=[[0,1],[1,2]],plans=[[2,1],[1,0],[3,0]]`
>
>输出：`[5,7,9]`
>
>解释：
>![image.png](https://pic.leetcode-cn.com/1630061300-WuVkeF-image.png){:height=200}


**示例2：**
>输入：
>`finalCnt=[4,13,4,3,8],totalNum=54,edges=[[0,3],[1,3],[4,3],[2,3],[2,5]],plans=[[1,1],[3,3],[2,5],[1,0]]`
>
>输出：`[10,16,9,4,7,8]`



**提示：**
-`2<=n<=5*10^4`
-`1<=edges.length<=min((n*(n-1))/2,5*10^4)`
-`0<=edges[i][0],edges[i][1]<n`
-`1<=plans.length<=10`
-`1<=plans[i][0]<=3`
-`0<=plans[i][1]<n`
-`finalCnt.length=n-1`
-`0<=finalCnt[i]<10^9`
-`0<=totalNum<5*10^13`
",,0,3
46,1250,3,0,LCP,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"「力扣挑战赛」的入场仪式马上就要开始了，由于安保工作的需要，设置了可容纳人数总和为`M`的`N`个安检室，`capacities[i]`记录第`i`个安检室可容纳人数。安检室拥有两种类型：
-先进先出：在安检室中的所有观众中，最早进入安检室的观众最先离开
-后进先出：在安检室中的所有观众中，最晚进入安检室的观众最先离开

![c24754f1a5ff56989340ba5004dc5eda.gif](https://pic.leetcode-cn.com/1628843202-cdFPSt-c24754f1a5ff56989340ba5004dc5eda.gif)



恰好`M+1`位入场的观众（编号从0开始）需要排队**依次**入场安检，入场安检的规则如下：
-观众需要先进入编号`0`的安检室
-当观众将进入编号`i`的安检室时（`0<=i<N`)，
-若安检室未到达可容纳人数上限，该观众可直接进入；
-若安检室已到达可容纳人数上限，在该观众进入安检室之前需根据当前安检室类型选择一位观众离开后才能进入；
-当观众离开编号`i`的安检室时（`0<=i<N-1`)，将进入编号`i+1`的安检室接受安检。

若可以任意设定每个安检室的类型，请问有多少种设定安检室类型的方案可以使得编号`k`的观众第一个通过最后一个安检室入场。


**注意：**
-观众不可主动离开安检室，只有当安检室容纳人数达到上限，且又有新观众需要进入时，才可根据安检室的类型选择一位观众离开；
-由于方案数可能过大，请将答案对`1000000007`取模后返回。


**示例1：**
>输入：`capacities=[2,2,3],k=2`
>
>输出：`2`
>解释：
>存在两种设定的`2`种方案：
>-方案1：将编号为`0`、`1`的实验室设置为**后进先出**的类型，编号为`2`的实验室设置为**先进先出**的类型；
>-方案2：将编号为`0`、`1`的实验室设置为**先进先出**的类型，编号为`2`的实验室设置为**后进先出**的类型。
>
>以下是方案1的示意图：
>![c60e38199a225ad62f13b954872edf9b.gif](https://pic.leetcode-cn.com/1628841618-bFKsnt-c60e38199a225ad62f13b954872edf9b.gif)



**示例2：**
>输入：`capacities=[3,3],k=3`
>
>输出：`0`

**示例3：**
>输入：`capacities=[4,3,2,2],k=6`
>
>输出：`2`

**提示:**
+`1<=capacities.length<=200`
+`1<=capacities[i]<=200`
+`0<=k<=sum(capacities)`
",,1,2
47,981,2,0,LCP,2,0,0,0,0,2,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"小力正在通过残局练习来备战「力扣挑战赛」中的「五子棋」项目，他想请你能帮他预测当前残局的输赢情况。棋盘中的棋子分布信息记录于二维数组`pieces`中，其中`pieces[i]=[x,y,color]`表示第`i`枚棋子的横坐标为`x`，纵坐标为`y`，棋子颜色为`color`(`0`表示黑棋，`1`表示白棋)。假如黑棋先行，并且黑棋和白棋都按最优策略落子，请你求出当前棋局在三步（按**黑、白、黑**的落子顺序）之内的输赢情况（三步之内先构成同行、列或对角线连续同颜色的至少5颗即为获胜）：
-黑棋胜,请返回`""Black""`
-白棋胜,请返回`""White""`
-仍无胜者,请返回`""None""`

**注意：**
-和传统的五子棋项目不同，「力扣挑战赛」中的「五子棋」项目**不存在边界限制**，即可在**任意位置**落子；
-黑棋和白棋均按3步内的输赢情况进行最优策略的选择
-测试数据保证所给棋局目前无胜者；
-测试数据保证不会存在坐标一样的棋子。

**示例1：**
>输入：
>`pieces=[[0,0,1],[1,1,1],[2,2,0]]`
>
>输出：`""None""`
>
>解释：无论黑、白棋以何种方式落子，三步以内都不会产生胜者。

**示例2：**
>输入：
>`pieces=[[1,2,1],[1,4,1],[1,5,1],[2,1,0],[2,3,0],[2,4,0],[3,2,1],[3,4,0],[4,2,1],[5,2,1]]`
>
>输出：`""Black""`
>
>解释：三步之内黑棋必胜，以下是一种可能的落子情况：
>![902b87df29998b1c181146c8fdb3a4b6.gif](https://pic.leetcode-cn.com/1629800639-KabOfY-902b87df29998b1c181146c8fdb3a4b6.gif){:width=""300px""}



**提示：**
-`0<=pieces.length<=1000`
-`pieces[i].length=3`
-`-10^9<=pieces[i][0],pieces[i][1]<=10^9`
-`0<=pieces[i][2]<=1`
",,1,4
48,1033,3,0,LCP,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"「力扣挑战赛」中有一个由`N`个关卡组成的**环形**闯关游戏，关卡编号为`0`~`N-1`，编号`0`的关卡和编号`N-1`的关卡相邻。每个关卡均有积分要求，`challenge[i]`表示挑战编号`i`的关卡最少需要拥有的积分。
![图片.png](https://pic.leetcode-cn.com/1630392170-ucncVS-%E5%9B%BE%E7%89%87.png){:width=""240px""}


小扣想要挑战关卡，闯关具体规则如下：

-初始小扣可以指定其中一个关卡为「开启」状态，其余关卡将处于「未开启」状态。
-小扣可以挑战处于「开启」状态且**满足最少积分要求**的关卡，若小扣挑战该关卡前积分为`score`，挑战结束后，积分将增长为`score|challenge[i]`（即位运算中的`""OR""`运算）
-在挑战某个关卡后，该关卡两侧相邻的关卡将会开启（若之前未开启）

请帮助小扣进行计算，初始最少需要多少积分，可以挑战**环形闯关游戏**的所有关卡。

**示例1：**

>输入：`challenge=[5,4,6,2,7]`
>
>输出：`4`
>
>解释：初始选择编号3的关卡开启，积分为4
>挑战编号3的关卡，积分变为$4|2=6$，开启2、4处的关卡
>挑战编号2的关卡，积分变为$6|6=6$，开启1处的关卡
>挑战编号1的关卡，积分变为$6|4=6$，开启0处的关卡
>挑战编号0的关卡，积分变为$6|5=7$
>挑战编号4的关卡，顺利完成全部的关卡


**示例2：**

>输入：`challenge=[12,7,11,3,9]`
>
>输出：`8`
>
>解释：初始选择编号3的关卡开启，积分为8
>挑战编号3的关卡，积分变为$8|3=11$，开启2、4处的关卡
>挑战编号2的关卡，积分变为$11|11=11$，开启1处的关卡
>挑战编号4的关卡，积分变为$11|9=11$，开启0处的关卡
>挑战编号1的关卡，积分变为$11|7=15$
>挑战编号0的关卡，顺利完成全部的关卡

**示例3：**

>输入：`challenge=[1,1,1]`
>
>输出：`1`

**提示：**
-`1<=challenge.length<=5*10^4`
-`1<=challenge[i]<=10^14`",,0,4
49,1022,3,0,LCP,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"欢迎各位勇者来到力扣新手村，在开始试炼之前，请各位勇者先进行「宝石补给」。

每位勇者初始都拥有一些能量宝石，`gem[i]`表示第`i`位勇者的宝石数量。现在这些勇者们进行了一系列的赠送，`operations[j]=[x,y]`表示在第`j`次的赠送中第`x`位勇者将自己一半的宝石（需向下取整）赠送给第`y`位勇者。

在完成所有的赠送后，请找到拥有**最多**宝石的勇者和拥有**最少**宝石的勇者，并返回他们二者的宝石数量**之差**。

**注意：**
-赠送将按顺序逐步进行。

**示例1：**
>输入：`gem=[3,1,2],operations=[[0,2],[2,1],[2,0]]`
>
>输出：`2`
>
>解释：
>第1次操作，勇者`0`将一半的宝石赠送给勇者`2`，`gem=[2,1,3]`
>第2次操作，勇者`2`将一半的宝石赠送给勇者`1`，`gem=[2,2,2]`
>第3次操作，勇者`2`将一半的宝石赠送给勇者`0`，`gem=[3,2,1]`
>返回3-1=2

**示例2：**
>输入：`gem=[100,0,50,100],operations=[[0,2],[0,1],[3,0],[3,0]]`
>
>输出：`75`
>
>解释：
>第1次操作，勇者`0`将一半的宝石赠送给勇者`2`，`gem=[50,0,100,100]`
>第2次操作，勇者`0`将一半的宝石赠送给勇者`1`，`gem=[25,25,100,100]`
>第3次操作，勇者`3`将一半的宝石赠送给勇者`0`，`gem=[75,25,100,50]`
>第4次操作，勇者`3`将一半的宝石赠送给勇者`0`，`gem=[100,25,100,25]`
>返回100-25=75

**示例3：**
>输入：`gem=[0,0,0,0],operations=[[1,2],[3,1],[1,2]]`
>
>输出：`0`

**提示：**
-`2<=gem.length<=10^3`
-`0<=gem[i]<=10^3`
-`0<=operations.length<=10^4`
-`operations[i].length==2`
-`0<=operations[i][0],operations[i][1]<gem.length`",,0,2
50,947,2,0,LCP,2,1,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"欢迎各位勇者来到力扣城，城内设有烹饪锅供勇者制作料理，为自己恢复状态。

勇者背包内共有编号为`0~4`的五种食材，其中`materials[j]`表示第`j`种食材的数量。通过这些食材可以制作若干料理，`cookbooks[i][j]`表示制作第`i`种料理需要第`j`种食材的数量，而`attribute[i]=[x,y]`表示第`i`道料理的美味度`x`和饱腹感`y`。

在饱腹感不小于`limit`的情况下，请返回勇者可获得的最大美味度。如果无法满足饱腹感要求，则返回`-1`。

**注意：**
-每种料理只能制作一次。


**示例1：**
>输入：`materials=[3,2,4,1,2]`
>`cookbooks=[[1,1,0,1,2],[2,1,4,0,0],[3,2,4,1,0]]`
>`attribute=[[3,2],[2,4],[7,6]]`
>`limit=5`
>
>输出：`7`
>
>解释：
>食材数量可以满足以下两种方案：
>方案一：制作料理0和料理1，可获得饱腹感2+4、美味度3+2
>方案二：仅制作料理2，可饱腹感为6、美味度为7
>因此在满足饱腹感的要求下，可获得最高美味度7

**示例2：**
>输入：`materials=[10,10,10,10,10]`
>`cookbooks=[[1,1,1,1,1],[3,3,3,3,3],[10,10,10,10,10]]`
>`attribute=[[5,5],[6,6],[10,10]]`
>`limit=1`
>
>输出：`11`
>
>解释：通过制作料理0和1，可满足饱腹感，并获得最高美味度11

**提示：**
+`materials.length==5`
+`1<=cookbooks.length==attribute.length<=8`
+`cookbooks[i].length==5`
+`attribute[i].length==2`
+`0<=materials[i],cookbooks[i][j],attribute[i][j]<=20`
+`1<=limit<=100`
",,0,4
51,1064,2,0,LCP,1,1,4,1,0,0,0,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,"欢迎各位勇者来到力扣城，本次试炼主题为「二叉搜索树染色」。

每位勇士面前设有一个**二叉搜索树**的模型，模型的根节点为`root`，树上的各个节点值均不重复。初始时，所有节点均为蓝色。现在按顺序对这棵二叉树进行若干次操作，`ops[i]=[type,x,y]`表示第`i`次操作为：
+`type`等于0时，将节点值范围在`[x,y]`的节点均染蓝
+`type`等于1时，将节点值范围在`[x,y]`的节点均染红

请返回完成所有染色后，该二叉树中红色节点的数量。


**注意：**
+题目保证对于每个操作的`x`、`y`值定出现在二叉搜索树节点中

**示例1：**
>输入：`root=[1,null,2,null,3,null,4,null,5],ops=[[1,2,4],[1,1,3],[0,3,5]]`
>
>输出：`2`
>
>解释：
>第0次操作，将值为2、3、4的节点染红；
>第1次操作，将值为1、2、3的节点染红；
>第2次操作，将值为3、4、5的节点染蓝；
>因此，最终值为1、2的节点为红色节点，返回数量2
![image.png](https://pic.leetcode-cn.com/1649833948-arSlXd-image.png){:width=230px}


**示例2：**
>输入：`root=[4,2,7,1,null,5,null,null,null,null,6]`
>`ops=[[0,2,2],[1,1,5],[0,4,5],[1,5,7]]`
>
>输出：`5`
>
>解释：
>第0次操作，将值为2的节点染蓝；
>第1次操作，将值为1、2、4、5的节点染红；
>第2次操作，将值为4、5的节点染蓝；
>第3次操作，将值为5、6、7的节点染红；
>因此，最终值为1、2、5、6、7的节点为红色节点，返回数量5
![image.png](https://pic.leetcode-cn.com/1649833763-BljEbP-image.png){:width=230px}

**提示：**
+`1<=二叉树节点数量<=10^5`
+`1<=ops.length<=10^5`
+`ops[i].length==3`
+`ops[i][0]`仅为`0`or`1`
+`0<=ops[i][1]<=ops[i][2]<=10^9`
+`0<=节点值<=10^9`
",,1,7
52,794,2,0,LCP,1,1,0,0,2,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"各位勇者请注意，力扣太空城发布陨石雨红色预警。

太空城中的一些舱室将要受到陨石雨的冲击，这些舱室按照编号`0~N`的顺序依次排列。为了阻挡陨石损毁舱室，太空城可以使用能量展开防护屏障，具体消耗如下：

-选择一个舱室开启屏障，能量消耗为`2`
-选择相邻两个舱室开启联合屏障，能量消耗为`3`
-对于已开启的**一个**屏障，**多维持一时刻**，能量消耗为`1`

已知陨石雨的影响范围和到达时刻，`time[i]`和`position[i]`分别表示该陨石的到达时刻和冲击位置。请返回太空舱能够守护所有舱室所需要的最少能量。

**注意：**
-同一时间，一个舱室不能被多个屏障覆盖
-陨石雨仅在到达时刻对冲击位置处的舱室有影响


**示例1：**
>输入：`time=[1,2,1],position=[6,3,3]`
>
>输出：`5`
>
>解释：
>时刻1，分别开启编号3、6舱室的屏障，能量消耗2*2=4
>时刻2，维持编号3舱室的屏障，能量消耗1
>因此，最少需要能量5

**示例2：**
>输入：`time=[1,1,1,2,2,3,5],position=[1,2,3,1,2,1,3]`
>
>输出：`9`
>
>解释：
>时刻1，开启编号1、2舱室的联合屏障，能量消耗3
>时刻1，开启编号3舱室的屏障，能量消耗2
>时刻2，维持编号1、2舱室的联合屏障，能量消耗1
>时刻3，维持编号1、2舱室的联合屏障，能量消耗1
>时刻5，重新开启编号3舱室的联合屏障，能量消耗2
>因此，最少需要能量9

**提示：**
+`1<=time.length==position.length<=500`
+`1<=time[i]<=5`
+`0<=position[i]<=100`
",,0,4
53,1173,2,0,LCP,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"欢迎各位勇者来到力扣城，本次试炼主题为「夺回据点」。

魔物了占领若干据点，这些据点被若干条道路相连接，`roads[i]=[x,y]`表示编号`x`、`y`的两个据点通过一条道路连接。

现在勇者要将按照以下原则将这些据点逐一夺回：

-在开始的时候，勇者可以花费资源先夺回一些据点，初始夺回第`j`个据点所需消耗的资源数量为`cost[j]`

-接下来，勇者在不消耗资源情况下，每次可以夺回**一个**和「已夺回据点」相连接的魔物据点，并对其进行夺回

>注：为了防止魔物暴动，勇者在每一次夺回据点后（包括花费资源夺回据点后），需要保证剩余的所有魔物据点之间是相连通的（不经过「已夺回据点」）。

请返回勇者夺回所有据点需要消耗的最少资源数量。

**注意：**
-输入保证初始所有据点都是连通的，且不存在重边和自环

**示例1：**
>输入：
>`cost=[1,2,3,4,5,6]`
>`roads=[[0,1],[0,2],[1,3],[2,3],[1,2],[2,4],[2,5]]`
>
>输出：`6`
>
>解释：
>勇者消耗资源`6`夺回据点`0`和`4`，魔物据点`1、2、3、5`相连通；
>第一次夺回据点`1`，魔物据点`2、3、5`相连通；
>第二次夺回据点`3`，魔物据点`2、5`相连通；
>第三次夺回据点`2`，剩余魔物据点`5`；
>第四次夺回据点`5`，无剩余魔物据点；
>因此最少需要消耗资源为`6`，可占领所有据点。
![image.png](https://pic.leetcode-cn.com/1648706944-KJstUN-image.png){:height=170px}


**示例2：**
>输入：
>`cost=[3,2,1,4]`
>`roads=[[0,2],[2,3],[3,1]]`
>
>输出：`2`
>
>解释：
>勇者消耗资源`2`夺回据点`1`，魔物据点`0、2、3`相连通；
>第一次夺回据点`3`，魔物据点`2、0`相连通；
>第二次夺回据点`2`，剩余魔物据点`0`；
>第三次夺回据点`0`，无剩余魔物据点；
>因此最少需要消耗资源为`2`，可占领所有据点。
![image.png](https://pic.leetcode-cn.com/1648707186-LJRwzU-image.png){:height=60px}


**提示：**
-`1<=roads.length,cost.length<=10^5`
-`0<=roads[i][0],roads[i][1]<cost.length`
-`1<=cost[i]<=10^9`
",,0,3
54,879,2,0,LCP,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,EASY,"欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。

在新手村中，各位勇者需要采集一些果实来制作药剂。`time[i]`表示勇者每次采集`1～limit`颗第`i`种类型的果实需要的时间（即每次最多可以采集`limit`颗果实）。

当前勇者需要完成「采集若干批果实」的任务，`fruits[j]=[type,num]`表示第`j`批需要采集`num`颗`type`类型的果实。采集规则如下：
-按`fruits`给定的顺序**依次**采集每一批次
-采集完当前批次的果实才能开始采集下一批次
-勇者完成当前批次的采集后将**清空背包**（即多余的果实将清空）

请计算并返回勇者完成采集任务最少需要的时间。


**示例1：**
>输入：`time=[2,3,2],fruits=[[0,2],[1,4],[2,1]],limit=3`
>
>输出：`10`
>
>解释：
>由于单次最多采集3颗
>第0批需要采集2颗第0类型果实，需要采集1次，耗时为2\*1=2
>第1批需要采集4颗第1类型果实，需要采集2次，耗时为3\*2=6
>第2批需要采集1颗第2类型果实，需要采集1次，耗时为2\*1=2
>返回总耗时2+6+2=10

**示例2：**
>输入：`time=[1],fruits=[[0,3],[0,5]],limit=2`
>
>输出：`5`
>
>解释：
>由于单次最多采集2颗
>第0批需要采集3颗第0类型果实，需要采集2次，耗时为1\*2=2
>第1批需要采集5颗第0类型果实，需要采集3次，耗时为1\*3=3
>需按照顺序依次采集，返回2+3=5

**提示：**
-`1<=time.length<=100`
-`1<=time[i]<=100`
-`1<=fruits.length<=10^3`
-`0<=fruits[i][0]<time.length`
-`1<=fruits[i][1]<10^3`
-`1<=limit<=100`",,0,1
55,820,3,0,LCP,2,1,3,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。

本次试炼场地设有若干传送带，`matrix[i][j]`表示第`i`行`j`列的传送带运作方向，`""^"",""v"",""""`这四种符号分别表示**上、下、左、右**四个方向。信物会随传送带的方向移动。勇者**每一次**施法操作，可**临时**变更一处传送带的方向，在物品经过后传送带恢复原方向。
![lcp(2).gif](https://pic.leetcode-cn.com/1649835246-vfupSL-lcp%20\(2\).gif){:width=300px}

通关信物初始位于坐标`start`处，勇者需要将其移动到坐标`end`处，请返回勇者施法操作的最少次数。



**注意：**
-`start`和`end`的格式均为`[i,j]`

**示例1:**
>输入：`matrix=["">>v"",""v^
>输出：`1`
>
>解释：
>如上图所示
>当信物移动到`[1,1]`时，勇者施法一次将`[1,1]`的传送方向`^`从变更为`从而信物移动到`[1,0]`，后续到达`end`位置
>因此勇者最少需要施法操作1次

**示例2:**
>输入：`matrix=["">>v"","">>v"",""^<
>输出：`0`
>
>解释：勇者无需施法，信物将自动传送至`end`位置

**示例3:**
>输入：`matrix=["">^^>"","""",""^v^
>输出：`3`

**提示：**
-`matrix`中仅包含`'^'、'v'、''`
-`0<matrix.length<=100`
-`0<matrix[i].length<=100`
-`0<=start[0],end[0]<matrix.length`
-`0<=start[1],end[1]<matrix[i].length`

",,0,6
56,1123,3,0,LCP,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"欢迎各位勇者来到力扣城，本次试炼主题为「打地鼠」。
![middle_img_v2_d5d09656-0616-4a80-845e-ece461c5ba9g.png](https://pic.leetcode-cn.com/1650273183-nZIijm-middle_img_v2_d5d09656-0616-4a80-845e-ece461c5ba9g.png){:height=""200px""}
勇者面前有一个大小为`3*3`的打地鼠游戏机，地鼠将随机出现在各个位置，`moles[i]=[t,x,y]`表示在第`t`秒会有地鼠出现在`(x,y)`位置上，并于第`t+1`秒该地鼠消失。

勇者有一把可敲打地鼠的锤子，初始时刻（即第`0`秒）锤子位于正中间的格子`(1,1)`，锤子的使用规则如下：
-锤子每经过`1`秒可以往上、下、左、右中的一个方向移动一格，也可以不移动
-锤子只可敲击所在格子的地鼠，**敲击不耗时**

请返回勇者**最多**能够敲击多少只地鼠。

**注意：**
-输入用例保证在相同时间相同位置最多仅有一只地鼠


**示例1：**
>输入：`moles=[[1,1,0],[2,0,1],[4,2,2]]`
>
>输出：`2`
>
>解释：
>第0秒，锤子位于(1,1)
>第1秒，锤子移动至(1,0)并敲击地鼠
>第2秒，锤子移动至(2,0)
>第3秒，锤子移动至(2,1)
>第4秒，锤子移动至(2,2)并敲击地鼠
>因此勇者最多可敲击2只地鼠


**示例2：**
>输入：`moles=[[2,0,2],[5,2,0],[4,1,0],[1,2,1],[3,0,2]]`
>
>输出：`3`
>
>解释：
>第0秒，锤子位于(1,1)
>第1秒，锤子移动至(2,1)并敲击地鼠
>第2秒，锤子移动至(1,1)
>第3秒，锤子移动至(1,0)
>第4秒，锤子在(1,0)不移动并敲击地鼠
>第5秒，锤子移动至(2,0)并敲击地鼠
>因此勇者最多可敲击3只地鼠


**示例3：**
>输入：`moles=[[0,1,0],[0,0,1]]`
>
>输出：`0`
>
>解释：
>第0秒，锤子初始位于(1,1)，此时并不能敲击(1,0)、(0,1)位置处的地鼠


**提示：**
+`1<=moles.length<=10^5`
+`moles[i].length==3`
+`0<=moles[i][0]<=10^9`
+`0<=moles[i][1],moles[i][2]<3`
",,0,4
57,1354,2,0,LCP,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"欢迎各位勇者来到力扣城，本次试炼主题为「积木拼接」。
勇者面前有`6`片积木（厚度均为1），每片积木的形状记录于二维字符串数组`shapes`中，`shapes[i]`表示第`i`片积木，其中`1`表示积木对应位置无空缺，`0`表示积木对应位置有空缺。
例如`[""010"",""111"",""010""]`对应积木形状为
![image.png](https://pic.leetcode-cn.com/1616125620-nXMCxX-image.png)

拼接积木的规则如下：
-积木片可以旋转、翻面
-积木片边缘必须完全吻合才能拼接在一起
-**每片积木片`shapes[i]`的中心点在拼接时必须处于正方体对应面的中心点**

例如`3*3`、`4*4`的积木片的中心点如图所示（红色点）：
![middle_img_v2_c2d91eb5-9beb-4c06-9726-f7dae149d86g.png](https://pic.leetcode-cn.com/1650509082-wObiEp-middle_img_v2_c2d91eb5-9beb-4c06-9726-f7dae149d86g.png){:height=""150px""}


请返回这6片积木能否拼接成一个**严丝合缝的正方体**且每片积木正好对应正方体的一个面。

**注意：**
-输入确保每片积木均无空心情况（即输入数据保证对于大小`N*N`的`shapes[i]`，内部的`(N-2)*(N-2)`的区域必然均为1）
-输入确保每片积木的所有`1`位置均连通

**示例1：**
>输入：`shapes=[[""000"",""110"",""000""],[""110"",""011"",""000""],[""110"",""011"",""110""],[""000"",""010"",""111""],[""011"",""111"",""011""],[""011"",""010"",""000""]]`
>
>输出：`true`
>
>解释：
![cube.gif](https://pic.leetcode-cn.com/1616125823-hkXAeN-cube.gif)

**示例2：**
>输入：`shapes=[[""101"",""111"",""000""],[""000"",""010"",""111""],[""010"",""011"",""000""],[""010"",""111"",""010""],[""101"",""111"",""010""],[""000"",""010"",""011""]]`
>
>输出：`false`
>
>解释：
>由于每片积木片的中心点在拼接时必须处于正方体对应面的中心点，积木片`[""010"",""011"",""000""]`不能作为`[""100"",""110"",""000""]`使用，因此无法构成正方体


**提示：**
-`shapes.length==6`
-`shapes[i].length==shapes[j].length`
-`shapes[i].length==shapes[i][j].length`
-`3<=shapes[i].length<=10`





",,0,3
58,959,3,0,LCP,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"欢迎各位勇者来到力扣城，本次试炼主题为「搭桥过河」。

勇者面前有一段长度为`num`的河流，河流可以划分为若干河道。每条河道上恰有一块浮木，`wood[i]`记录了第`i`条河道上的浮木初始的覆盖范围。

-当且仅当浮木与相邻河道的浮木覆盖范围有重叠时，勇者才可以在两条浮木间移动
-勇者**仅能在岸上**通过花费一点「自然之力」，使任意一条浮木沿着河流移动一个单位距离

请问勇者跨越这条河流，最少需要花费多少「自然之力」。


**示例1：**
>输入：`num=10,wood=[[1,2],[4,7],[8,9]]`
>输出：`3`
>解释：如下图所示，
>将[1,2]浮木移动至[3,4]，花费2「自然之力」，
>将[8,9]浮木移动至[7,8]，花费1「自然之力」，
>此时勇者可以顺着[3,4]->[4,7]->[7,8]跨越河流，
>因此，勇者最少需要花费3点「自然之力」跨越这条河流
![wood(2).gif](https://pic.leetcode-cn.com/1648196478-ophADL-wood%20\(2\).gif){:width=650px}


**示例2：**
>输入：`num=10,wood=[[1,5],[1,1],[10,10],[6,7],[7,8]]`
>输出：`10`
>解释：
>将[1,5]浮木移动至[2,6]，花费1「自然之力」，
>将[1,1]浮木移动至[6,6]，花费5「自然之力」，
>将[10,10]浮木移动至[6,6]，花费4「自然之力」，
>此时勇者可以顺着[2,6]->[6,6]->[6,6]->[6,7]->[7,8]跨越河流，
>因此，勇者最少需要花费10点「自然之力」跨越这条河流


**示例3：**
>输入：`num=5,wood=[[1,2],[2,4]]`
>输出：`0`
>解释：勇者不需要移动浮木，仍可以跨越这条河流

**提示:**
-`1<=num<=10^9`
-`1<=wood.length<=10^5`
-`wood[i].length==2`
-`1<=wood[i][0]<=wood[i][1]<=num`

",,1,2
59,726,3,0,LCP,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"欢迎各位勇者来到力扣城，本次试炼主题为「力扣泡泡龙」。

游戏初始状态的泡泡形如二叉树`root`，每个节点值对应了该泡泡的分值。勇者最多可以击破一个节点泡泡，要求满足：
-被击破的节点泡泡**至多**只有一个子节点泡泡
-当被击破的节点泡泡有子节点泡泡时，则子节点泡泡将取代被击破泡泡的位置
>注：即整棵子树泡泡上移

请问在击破一个节点泡泡操作或无击破操作后，二叉泡泡树的最大「层和」是多少。

**注意：**
-「层和」为同一高度的所有节点的分值之和

**示例1：**
>输入：`root=[6,0,3,null,8]`
>
>输出：`11`
>
>解释：勇者的最佳方案如图所示
>![image.png](https://pic.leetcode-cn.com/1648180809-XSWPLu-image.png){:height=""100px""}



**示例2：**
>输入：`root=[5,6,2,4,null,null,1,3,5]`
>
>输出：`9`
>
>解释：勇者击破6节点，此时「层和」最大为3+5+1=9
>![image.png](https://pic.leetcode-cn.com/1648180769-TLpYop-image.png){:height=""200px""}



**示例3：**
>输入：`root=[-5,1,7]`
>
>输出：`8`
>
>解释：勇者不击破节点，「层和」最大为1+7=8


**提示**：
-`2<=树中节点个数<=10^5`
-`-10000<=树中节点的值<=10000`
",,0,3
60,795,2,0,LCP,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"力扣城计划在两地设立「力扣嘉年华」的分会场，气象小组正在分析两地区的气温变化趋势，对于第`i~(i+1)`天的气温变化趋势，将根据以下规则判断：
-若第`i+1`天的气温**高于**第`i`天，为**上升**趋势
-若第`i+1`天的气温**等于**第`i`天，为**平稳**趋势
-若第`i+1`天的气温**低于**第`i`天，为**下降**趋势

已知`temperatureA[i]`和`temperatureB[i]`分别表示第`i`天两地区的气温。
组委会希望找到一段天数尽可能多，且两地气温变化趋势相同的时间举办嘉年华活动。请分析并返回两地气温变化趋势**相同的最大连续天数**。
>即最大的`n`，使得第`i~i+n`天之间，两地气温变化趋势相同

**示例1：**
>输入：
>`temperatureA=[21,18,18,18,31]`
>`temperatureB=[34,32,16,16,17]`
>
>输出：`2`
>
>解释：如下表所示，第`2～4`天两地气温变化趋势相同，且持续时间最长，因此返回`4-2=2`
![image.png](https://pic.leetcode-cn.com/1663902654-hlrSvs-image.png){:width=1000px}


**示例2：**
>输入：
>`temperatureA=[5,10,16,-6,15,11,3]`
>`temperatureB=[16,22,23,23,25,3,-16]`
>
>输出：`3`

**提示：**
-`2<=temperatureA.length==temperatureB.length<=1000`
-`-20<=temperatureA[i],temperatureB[i]<=40`
",,0,1
61,770,2,0,LCP,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,"为了缓解「力扣嘉年华」期间的人流压力，组委会在活动期间开设了一些交通专线。`path[i]=[a,b]`表示有一条从地点`a`通往地点`b`的**单向**交通专线。
若存在一个地点，满足以下要求，我们则称之为**交通枢纽**：
-所有地点（除自身外）均有一条**单向**专线**直接**通往该地点；
-该地点不存在任何**通往其他地点**的单向专线。

请返回交通专线的**交通枢纽**。若不存在，则返回`-1`。

**注意：**
-对于任意一个地点，至少被一条专线连通。

**示例1：**
>输入：`path=[[0,1],[0,3],[1,3],[2,0],[2,3]]`
>
>输出：`3`
>
>解释：如下图所示：
>地点`0,1,2`各有一条通往地点`3`的交通专线，
>且地点`3`不存在任何**通往其他地点**的交通专线。
>![image.png](https://pic.leetcode-cn.com/1663902572-yOlUCr-image.png){:width=200px}


**示例2：**
>输入：`path=[[0,3],[1,0],[1,3],[2,0],[3,0],[3,2]]`
>
>输出：`-1`
>
>解释：如下图所示：不存在满足**交通枢纽**的地点。
>![image.png](https://pic.leetcode-cn.com/1663902595-McsEkY-image.png){:width=200px}

**提示：**
-`1<=path.length<=1000`
-`0<=path[i][0],path[i][1]<=1000`
-`path[i][0]`与`path[i][1]`不相等",,0,1
62,1384,3,0,LCP,2,4,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"欢迎各位来到「力扣嘉年华」，接下来将为各位介绍在活动中广受好评的弹珠游戏。

`N*M`大小的弹珠盘的初始状态信息记录于一维字符串型数组`plate`中，数组中的每个元素为仅由`""O""`、`""W""`、`""E""`、`"".""`组成的字符串。其中：
-`""O""`表示弹珠洞（弹珠到达后会落入洞中，并停止前进）；
-`""W""`表示逆时针转向器（弹珠经过时方向将逆时针旋转90度）；
-`""E""`表示顺时针转向器（弹珠经过时方向将顺时针旋转90度）；
-`"".""`表示空白区域（弹珠可通行）。

游戏规则要求仅能在边缘位置的**空白区域**处（弹珠盘的四角除外）沿**与边缘垂直**的方向打入弹珠，并且打入后的每颗弹珠最多能**前进**`num`步。请返回符合上述要求且可以使弹珠最终入洞的所有打入位置。你可以**按任意顺序**返回答案。

**注意：**
-若弹珠已到达弹珠盘边缘并且仍沿着出界方向继续前进，则将直接出界。

**示例1：**
>输入：
>`num=4`
>`plate=[""..E."","".EOW"",""..W.""]`
>
>输出：`[[2,1]]`
>
>解释：
>在`[2,1]`处打入弹珠，弹珠前进1步后遇到转向器，前进方向顺时针旋转90度，再前进1步进入洞中。
![b054955158a99167b8d51da0e22a54da.gif](https://pic.leetcode-cn.com/1630392649-BoQncz-b054955158a99167b8d51da0e22a54da.gif){:width=""300px""}

**示例2：**
>输入：
>`num=5`
>`plate=[""....."",""..E.."","".WO.."","".....""]`
>
>输出：`[[0,1],[1,0],[2,4],[3,2]]`
>
>解释：
>在`[0,1]`处打入弹珠，弹珠前进2步，遇到转向器后前进方向逆时针旋转90度，再前进1步进入洞中。
>在`[1,0]`处打入弹珠，弹珠前进2步，遇到转向器后前进方向顺时针旋转90度，再前进1步进入洞中。
>在`[2,4]`处打入弹珠，弹珠前进2步后进入洞中。
>在`[3,2]`处打入弹珠，弹珠前进1步后进入洞中。
![b44e9963239ae368badf3d00b7563087.gif](https://pic.leetcode-cn.com/1630392625-rckbdy-b44e9963239ae368badf3d00b7563087.gif){:width=""350px""}


**示例3：**
>输入：
>`num=3`
>`plate=[""....."",""....O"",""....O"","".....""]`
>
>输出：`[]`
>
>解释：
>由于弹珠被击中后只能前进3步，且不能在弹珠洞和弹珠盘四角打入弹珠，故不存在能让弹珠入洞的打入位置。


**提示：**
-`1<=num<=10^6`
-`1<=plate.length,plate[i].length<=1000`
-`plate[i][j]`仅包含`""O""`、`""W""`、`""E""`、`"".""`",,1,8
63,819,3,0,LCP,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"「力扣嘉年华」的中心广场放置了一个巨型的二叉树形状的装饰树。每个节点上均有一盏灯和三个开关。节点值为`0`表示灯处于「关闭」状态，节点值为`1`表示灯处于「开启」状态。每个节点上的三个开关各自功能如下：
-开关`1`：切换当前节点的灯的状态；
-开关`2`：切换**以当前节点为根**的子树中，所有节点上的灯的状态，；
-开关`3`：切换**当前节点及其左右子节点**（若存在的话）上的灯的状态；

给定该装饰的初始状态`root`，请返回最少需要操作多少次开关，可以关闭所有节点的灯。

**示例1：**
>输入：`root=[1,1,0,null,null,null,1]`
>
>输出：`2`
>
>解释：以下是最佳的方案之一，如图所示
![b71b95bf405e3b223e00b2820a062ba4.gif](https://pic.leetcode-cn.com/1629357030-GSbzpY-b71b95bf405e3b223e00b2820a062ba4.gif){:width=""300px""}

**示例2：**
>输入：`root=[1,1,1,1,null,null,1]`
>
>输出：`1`
>
>解释：以下是最佳的方案，如图所示
![a4091b6448a0089b4d9e8f0390ff9ac6.gif](https://pic.leetcode-cn.com/1629356950-HZsKZC-a4091b6448a0089b4d9e8f0390ff9ac6.gif){:width=""300px""}

**示例3：**
>输入：`root=[0,null,0]`
>
>输出：`0`
>
>解释：无需操作开关，当前所有节点上的灯均已关闭

**提示：**
-`1<=节点个数<=10^5`
-`0<=Node.val<=1`",,0,4
64,727,2,0,LCP,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"力扣嘉年华为了确保更舒适的游览环境条件，在会场的各处设置了湿度调节装置，这些调节装置受控于总控室中的一台控制器。
控制器中已经预设了一些调节指令，整数数组`operate[i]`表示第`i`条指令增加空气湿度的大小。现在你可以将任意数量的指令修改为降低湿度（变化的数值不变），以确保湿度尽可能的适宜：
-控制器会选择**一段连续的指令**，从而进行湿度调节的操作；
-这段指令最终对湿度影响的绝对值，即为当前操作的「不适宜度」
-在控制器所有可能的操作中，**最大**的「不适宜度」即为「整体不适宜度」

请返回在所有修改指令的方案中，可以得到的**最小**「整体不适宜度」。

**示例1：**
>输入：`operate=[5,3,7]`
>
>输出：`8`
>
>解释：对于方案`2`的`[5,3,-7]`
>操作指令`[5],[3],[-7]`的「不适宜度」分别为`5,3,7`
>操作指令`[5,3],[3,-7]`的「不适宜度」分别为`8,4`
>操作指令`[5,3,-7]`的「不适宜度」为`1`，
>因此对于方案`[5,3,-7]`的「整体不适宜度」为`8`，其余方案的「整体不适宜度」均不小于`8`，如下表所示：
![image.png](https://pic.leetcode-cn.com/1663902759-dgDCxn-image.png){:width=650px}

**示例2：**
>输入：`operate=[20,10]`
>
>输出：`20`

**提示：**
-`1<=operate.length<=1000`
-`1<=operate[i]<=1000`",,1,2
65,477,2,0,LCP,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"力扣嘉年华将举办一系列展览活动，后勤部将负责为每场展览提供所需要的展台。
已知后勤部得到了一份需求清单，记录了近期展览所需要的展台类型，`demand[i][j]`表示第`i`天展览时第`j`个展台的类型。
在满足每一天展台需求的基础上，请返回后勤部需要准备的**最小**展台数量。

**注意：**
-同一展台在不同天中可以重复使用。

**示例1：**
>输入：`demand=[""acd"",""bed"",""accd""]`
>
>输出：`6`
>
>解释：
>第`0`天需要展台`a、c、d`；
>第`1`天需要展台`b、e、d`；
>第`2`天需要展台`a、c、c、d`；
>因此，后勤部准备`abccde`的展台，可以满足每天的展览需求;

**示例2：**
>输入：`demand=[""abc"",""ab"",""ac"",""b""]`
>
>输出：`3`


**提示：**
-`1<=demand.length,demand[i].length<=100`
-`demand[i][j]`仅为小写字母",,0,4
66,715,2,0,LCP,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"力扣嘉年华上的DIY手工展位准备了一棵缩小版的**二叉**装饰树`root`和灯饰，你需要将灯饰逐一插入装饰树中，要求如下：

-完成装饰的二叉树根结点与`root`的根结点值相同
-若一个节点拥有父节点，则在该节点和他的父节点之间插入一个灯饰（即插入一个值为`-1`的节点）。具体地：
-在一个父节点x与其左子节点y之间添加-1节点，节点-1、节点y为各自父节点的左子节点，
-在一个父节点x与其右子节点y之间添加-1节点，节点-1、节点y为各自父节点的右子节点，

现给定二叉树的根节点`root`，请返回完成装饰后的树的根节点。
**示例1：**
>输入：
>`root=[7,5,6]`
>
>输出：`[7,-1,-1,5,null,null,6]`
>
>解释：如下图所示，
>![image.png](https://pic.leetcode-cn.com/1663575757-yRLGaq-image.png){:width=400px}

**示例2：**
>输入：
>`root=[3,1,7,3,8,null,4]`
>
>输出：`[3,-1,-1,1,null,null,7,-1,-1,null,-1,3,null,null,8,null,4]`
>
>解释：如下图所示
![image.png](https://pic.leetcode-cn.com/1663577920-sjrAYH-image.png){:width=500px}

**提示：**
>`0<=root.Val<=1000`
>`root`节点数量范围为`[1,10^5]`",,0,4
67,723,2,0,LCP,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,MEDIUM,"力扣嘉年华的花店中从左至右摆放了一排鲜花，记录于整型一维矩阵`flowers`中每个数字表示该位置所种鲜花的品种编号。你可以选择一段区间的鲜花做成插花，且不能丢弃。
在你选择的插花中，如果每一品种的鲜花数量都不超过`cnt`朵，那么我们认为这束插花是「美观的」。
>-例如：`[5,5,5,6,6]`中品种为`5`的花有`3`朵，品种为`6`的花有`2`朵，**每一品种**的数量均不超过`3`

请返回在这一排鲜花中，共有多少种可选择的区间，使得插花是「美观的」。

**注意：**
-答案需要以`1e9+7(1000000007)`为底取模，如：计算初始结果为：`1000000008`，请返回`1`

**示例1：**
>输入：`flowers=[1,2,3,2],cnt=1`
>
>输出：`8`
>
>解释：相同的鲜花不超过`1`朵，共有`8`种花束是美观的；
>长度为`1`的区间`[1]、[2]、[3]、[2]`均满足条件，共`4`种可选择区间
>长度为`2`的区间`[1,2]、[2,3]、[3,2]`均满足条件，共`3`种可选择区间
>长度为`3`的区间`[1,2,3]`满足条件，共`1`种可选择区间。
>区间`[2,3,2],[1,2,3,2]`都包含了`2`朵鲜花`2`，不满足条件。
>返回总数`4+3+1=8`

**示例2：**
>输入：`flowers=[5,3,3,3],cnt=2`
>
>输出：`8`

**提示：**
-`1<=flowers.length<=10^5`
-`1<=flowers[i]<=10^5`
-`1<=cnt<=10^5`",,0,2
68,881,2,0,LCP,2,1,0,0,2,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"力扣嘉年华同样准备了纪念品展位，参观者只需要集齐`helloleetcode`的`13`张字母卡片即可获得力扣纪念章。

在展位上有一些由字母卡片拼成的单词，`words[i][j]`表示第`i`个单词的第`j`个字母。

你可以从这些单词中取出一些卡片，但每次拿取卡片都需要消耗游戏代币，规则如下：

-从一个单词中取一个字母所需要的代币数量，为该字母左边和右边字母数量之积

-可以从一个单词中多次取字母，每个字母仅可被取一次

>例如：从`example`中取出字母`a`，需要消耗代币`2*4=8`，字母取出后单词变为`exmple`；
再从中取出字母`m`，需要消耗代币`2*3=6`，字母取出后单词变为`exple`；

请返回取得`helloleetcode`这些字母需要消耗代币的**最少**数量。如果无法取得，返回`-1`。

**注意：**
-取出字母的顺序没有要求
-取出的所有字母恰好可以拼成`helloleetcode`

**示例1：**
>输入：`words=[""hold"",""engineer"",""cost"",""level""]`
>
>输出：`5`
>
>解释：最优方法为：
>从`hold`依次取出`h`、`o`、`l`、`d`，代价均为`0`
>从`engineer`依次取出第`1`个`e`与最后一个`e`，代价为`0`和`5*1=5`
>从`cost`取出`c`、`o`、`t`，代价均为`0`
>从`level`依次取出`l`、`l`、`e`、`e`，代价均为`0`
>所有字母恰好可以拼成`helloleetcode`，因此最小的代价为`5`

**示例2：**
>输入：`words=[""hello"",""leetcode""]`
>
>输出：`0`

**提示：**
+`n==words.length`
+`m==words[i].length`
+`1<=n<=24`
+`1<=m<=8`
+`words[i][j]`仅为小写字母",,0,5
69,919,2,0,LCP,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"在力扣城的沙漠分会场展示了一种沙柳树，这种沙柳树能够将沙地转化为坚实的绿地。
展示的区域为正三角形，这片区域可以拆分为若干个子区域，每个子区域都是边长为`1`的小三角形，其中第`i`行有`2i-1`个小三角形。

初始情况下，区域中的所有位置都为沙地，你需要指定一些子区域种植沙柳树成为绿地，以达到转化整片区域为绿地的最终目的，规则如下：
-若两个子区域共用一条边，则视为相邻；
>如下图所示，(1,1)和(2,2)相邻，(3,2)和(3,3)相邻；(2,2)和(3,3)不相邻，因为它们没有共用边。
-若至少有两片绿地与同一片沙地相邻，则这片沙地也会转化为绿地
-转化为绿地的区域会影响其相邻的沙地
![image.png](https://pic.leetcode-cn.com/1662692397-VlvErS-image.png)

现要将一片边长为`size`的沙地全部转化为绿地，请找到任意一种初始指定**最少**数量子区域种植沙柳的方案，并返回所有初始种植沙柳树的绿地坐标。

**示例1：**
>输入：`size=3`
>输出：`[[1,1],[2,1],[2,3],[3,1],[3,5]]`
>解释：如下图所示，一种方案为：
>指定所示的5个子区域为绿地。
>相邻至少两片绿地的(2,2)，(3,2)和(3,4)演变为绿地。
>相邻两片绿地的(3,3)演变为绿地。
![image.png](https://pic.leetcode-cn.com/1662692503-ncjywh-image.png){:width=500px}


**示例2：**
>输入：`size=2`
>输出：`[[1,1],[2,1],[2,3]]`
>解释：如下图所示：
>指定所示的3个子区域为绿地。
>相邻三片绿地的(2,2)演变为绿地。
![image.png](https://pic.leetcode-cn.com/1662692507-mgFXRj-image.png){:width=276px}



**提示：**
-`1<=size<=1000`",,0,2
70,1287,4,0,LCP,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"字符串数组`shape`描述了一个二维平面中的矩阵形式的集水器，`shape[i][j]`表示集水器的第`i`行`j`列为：
-`'l'`表示向左倾斜的隔板（即从左上到右下）；
-`'r'`表示向右倾斜的隔板（即从左下到右上）；
-`'.'`表示此位置没有隔板
![image.png](https://pic.leetcode-cn.com/1664424667-wMnPja-image.png){:width=200px}

已知当隔板构成存储容器可以存水，每个方格代表的蓄水量为`2`。集水器初始浸泡在水中，除内部密闭空间外，所有位置均被水填满。
现将其从水中竖直向上取出，请返回集水器最终的蓄水量。

**注意：**
-隔板具有良好的透气性，因此空气可以穿过隔板，但水无法穿过

**示例1：**
>输入：
>`shape=[""....rl"",""l.lr.r"","".l..r."",""..lr..""]`
>
>输出：`18`
>
>解释：如下图所示，由于空气会穿过隔板，因此红框区域没有水
![image.png](https://pic.leetcode-cn.com/1664436239-eyYxeP-image.png){:width=""280px""}


**示例2：**
>输入：
>`shape=["".rlrlrlrl"",""ll..rl..r"","".llrrllrr"",""..lr..lr.""]`
>输出：`18`
>
>解释：如图所示。由于红框右侧未闭合，因此多余的水会从该处流走。
![image.png](https://pic.leetcode-cn.com/1664436082-SibVMv-image.png){:width=""400px""}


**示例3：**
>输入：
>`shape=[""rlrr"",""llrl"",""llr.""]`
>输出：`6`
>
>解释：如图所示。
![image.png](https://pic.leetcode-cn.com/1664424855-dwpUHO-image.png){:width=""230px""}




**示例4：**
>输入：
>`shape=[""...rl..."",""..r..l.."","".r.rl.l."",""r.r..l.l"",""l.l..rl."","".l.lr.r."",""..l..r.."",""...lr...""]`
>
>输出：`30`
>
>解释：如下图所示。由于中间为内部密闭空间，无法蓄水。
![image.png](https://pic.leetcode-cn.com/1664424894-mClEXh-image.png){:width=""350px""}


**提示**：
-`1<=shape.length<=50`
-`1<=shape[i].length<=50`
-`shape[i][j]`仅为`'l'`、`'r'`或`'.'`
",,0,3
71,571,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"远征队即将开启未知的冒险之旅，不过在此之前，将对补给车队进行最后的检查。`supplies[i]`表示编号为`i`的补给马车装载的物资数量。
考虑到车队过长容易被野兽偷袭，他们决定将车队的长度变为原来的一半（向下取整），计划为：
-找出车队中**物资之和最小**两辆**相邻**马车，将它们车辆的物资整合为一辆。若存在多组物资之和相同的马车，则取编号最小的两辆马车进行整合；
-重复上述操作直到车队长度符合要求。

请返回车队长度符合要求后，物资的分布情况。

**示例1：**
>输入：`supplies=[7,3,6,1,8]`
>
>输出：`[10,15]`
>
>解释：
>第1次合并，符合条件的两辆马车为6,1，合并后的车队为[7,3,7,8]；
>第2次合并，符合条件的两辆马车为(7,3)和(3,7)，取编号最小的(7,3)，合并后的车队为[10,7,8]；
>第3次合并，符合条件的两辆马车为7,8，合并后的车队为[10,15]；
>返回`[10,15]`

**示例2：**
>输入：`supplies=[1,3,1,5]`
>
>输出：`[5,5]`

**解释：**
-`2<=supplies.length<=1000`
-`1<=supplies[i]<=1000`",,0,0
72,1283,3,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"探险家小扣的行动轨迹，都将保存在记录仪中。`expeditions[i]`表示小扣第`i`次探险记录，用一个字符串数组表示。其中的每个「营地」由大小写字母组成，通过子串`->`连接。
>例：""Leet->code->Campsite""，表示到访了""Leet""、""code""、""Campsite""三个营地。

`expeditions[0]`包含了初始小扣已知的所有营地；对于之后的第`i`次探险(即`expeditions[i]`且i>0)，如果记录中包含了之前均没出现的营地，则表示小扣**新发现**的营地。

请你找出小扣发现新营地最多且索引最小的那次探险，并返回对应的记录索引。如果所有探险记录都没有发现新的营地，返回`-1`

**注意：**
-大小写不同的营地视为不同的营地；
-营地的名称长度均大于`0`。

**示例1：**
>输入：`expeditions=[""leet->code"",""leet->code->Campsite->Leet"",""leet->code->leet->courier""]`
>
>输出：`1`
>
>解释：
>初始已知的所有营地为""leet""和""code""
>第1次，到访了""leet""、""code""、""Campsite""、""Leet""，新发现营地2处：""Campsite""、""Leet""
>第2次，到访了""leet""、""code""、""courier""，新发现营地1处：""courier""
>第1次探险发现的新营地数量最多，因此返回`1`

**示例2：**
>输入：`expeditions=[""Alice->Dex"","""",""Dex""]`
>
>输出：`-1`
>
>解释：
>初始已知的所有营地为""Alice""和""Dex""
>第1次，未到访任何营地；
>第2次，到访了""Dex""，未新发现营地；
>因为两次探险均未发现新的营地，返回`-1`

**示例3：**
>输入：`expeditions=["""",""Gryffindor->Slytherin->Gryffindor"",""Hogwarts->Hufflepuff->Ravenclaw""]`
>
>输出：`2`
>
>解释：
>初始未发现任何营地；
>第1次，到访""Gryffindor""、""Slytherin""营地，其中重复到访""Gryffindor""两次，
>因此新发现营地为2处：""Gryffindor""、""Slytherin""
>第2次，到访""Hogwarts""、""Hufflepuff""、""Ravenclaw""营地；
>新发现营地3处：""Hogwarts""、""Hufflepuff""、""Ravenclaw""；
>第2次探险发现的新营地数量最多，因此返回`2`

**提示：**
-`1<=expeditions.length<=1000`
-`0<=expeditions[i].length<=1000`
-探险记录中只包含大小写字母和子串""->""",,0,0
73,842,2,0,LCP,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"小扣在探索丛林的过程中，无意间发现了传说中“落寞的黄金之都”。而在这片建筑废墟的地带中，小扣使用探测仪监测到了存在某种带有「祝福」效果的力场。
经过不断的勘测记录，小扣将所有力场的分布都记录了下来。`forceField[i]=[x,y,side]`表示第`i`片力场将覆盖以坐标`(x,y)`为中心，边长为`side`的正方形区域。

若任意一点的**力场强度**等于覆盖该点的力场数量，请求出在这片地带中**力场强度**最强处的**力场强度**。

**注意：**
-力场范围的边缘同样被力场覆盖。

**示例1：**
>输入：
>`forceField=[[0,0,1],[1,0,1]]`
>
>输出：`2`
>
>解释：如图所示，（0.5,0)处力场强度最强为2，（0.5，-0.5）处力场强度同样是2。
![image.png](https://pic.leetcode.cn/1681805536-zGfghe-image.png){:width=400px}


**示例2：**
>输入：
>`forceField=[[4,4,6],[7,5,3],[1,6,2],[5,6,3]]`
>
>输出：`3`
>
>解释：如下图所示，
>`forceField[0]、forceField[1]、forceField[3]`重叠的区域力场强度最大，返回`3`
![image.png](https://pic.leetcode.cn/1681805437-HQkyZS-image.png){:width=500px}



**提示：**
-`1<=forceField.length<=100`
-`forceField[i].length==3`
-`0<=forceField[i][0],forceField[i][1]<=10^9`
-`1<=forceField[i][2]<=10^9`",,1,0
74,1591,3,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"随着不断的深入，小扣来到了守护者之森寻找的魔法水晶。首先，他必须先通过守护者的考验。

考验的区域是一个正方形的迷宫，`maze[i][j]`表示在迷宫`i`行`j`列的地形：
-若为`.`，表示可以到达的空地；
-若为`#`，表示不可到达的墙壁；
-若为`S`，表示小扣的初始位置；
-若为`T`，表示魔法水晶的位置。

小扣每次可以向上、下、左、右相邻的位置移动一格。而守护者拥有一份「传送魔法卷轴」，使用规则如下：
-魔法需要在小扣位于**空地**时才能释放，发动后卷轴消失；；
-发动后，小扣会被传送到水平或者竖直的镜像位置，且目标位置不得为墙壁(如下图所示)；
![image.png](https://pic.leetcode.cn/1681789509-wTekFu-image.png){:width=400px}

在使用卷轴后，小扣将被「附加负面效果」，因此小扣需要尽可能缩短传送后到达魔法水晶的距离。而守护者的目标是阻止小扣到达魔法水晶的位置；如果无法阻止，则尽可能**增加**小扣传送后到达魔法水晶的距离。
假设小扣和守护者都按最优策略行事，返回小扣需要在「附加负面效果」的情况下**最少**移动多少次才能到达魔法水晶。如果无法到达，返回`-1`。

**注意：**
-守护者可以不使用卷轴；
-传送后的镜像位置可能与原位置相同。

**示例1：**
>输入：`maze=[""....."",""##S.."",""...#."",""T.#.."",""###..""]`
>
>输出：`7`
>
>解释：如下图所示：
>守护者释放魔法的两个最佳的位置为[2,0]或[3,1]：
>若小扣经过[2,0]，守护者在该位置释放魔法，
>小扣被传送至[2,4]处且加上负面效果，此时小扣还需要移动7次才能到达魔法水晶；
>若小扣经过[3,1]，守护者在该位置释放魔法，
>小扣被传送至[3,3]处且加上负面效果，此时小扣还需要移动9次才能到达魔法水晶；
>因此小扣负面效果下最少需要移动7次才能到达魔法水晶。
![image.png](https://pic.leetcode.cn/1681714676-gksEMT-image.png){:width=300px}


**示例2：**
>输入：`maze=["".#.."",""..##"","".#S."","".#.T""]`
>
>输出：`-1`
>
>解释：如下图所示。
>若小扣向下移动至[3,2]，守护者使其传送至[0,2]，小扣将无法到达魔法水晶；
>若小扣向右移动至[2,3]，守护者使其传送至[2,0]，小扣将无法到达魔法水晶；
![image.png](https://pic.leetcode.cn/1681714693-LsxKAh-image.png){:width=300px}


**示例3：**
>输入：`maze=[""S###."",""..###"",""#..##"",""##..#"",""###.T""]`
>
>输出：`5`
>
>解释：如下图所示：
>守护者需要小扣在空地才能释放，因此初始无法将其从[0,0]传送至[0,4];
>当小扣移动至[2,1]时，释放卷轴将其传送至水平方向的镜像位置[2,1]（为原位置）
>而后小扣需要移动5次到达魔法水晶
![image.png](https://pic.leetcode.cn/1681800985-KrSdru-image.png){:width=300px}

**提示：**
-`4<=maze.length==maze[i].length<=200`
-`maze[i][j]`仅包含`"".""`、`""#""`、`""S""`、`""T""`",,0,0
75,798,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"在大小为`n*m`的棋盘中，有两种不同的棋子：黑色，红色。当两颗颜色不同的棋子同时满足以下两种情况时，将会产生魔法共鸣：
-两颗异色棋子在同一行或者同一列
-两颗异色棋子之间恰好只有一颗棋子
>注：异色棋子之间可以有空位

由于棋盘上被施加了魔法禁制，棋盘上的部分格子变成问号。`chessboard[i][j]`表示棋盘第`i`行`j`列的状态：
-若为`.`，表示当前格子确定为空
-若为`B`，表示当前格子确定为黑棋
-若为`R`，表示当前格子确定为红棋
-若为`?`，表示当前格子待定

现在，探险家小扣的任务是确定所有问号位置的状态（留空/放黑棋/放红棋），使最终的棋盘上，任意两颗棋子间都**无法**产生共鸣。请返回可以满足上述条件的放置方案数量。

**示例1：**
>输入：`n=3,m=3,chessboard=[""..R"",""..B"",""?R?""]`
>
>输出：`5`
>
>解释：给定的棋盘如图：
>![image.png](https://pic.leetcode.cn/1681714583-unbRox-image.png){:height=150px}
>所有符合题意的最终局面如图：
>![image.png](https://pic.leetcode.cn/1681714596-beaOHK-image.png){:height=150px}

**示例2：**
>输入：`n=3,m=3,chessboard=[""?R?"",""B?B"",""?R?""]`
>
>输出：`105`

**提示：**
-`n==chessboard.length`
-`m==chessboard[i].length`
-`1<=n*m<=30`
-`chessboard`中仅包含`"".""、""B""、""R""、""?""`",,0,0
76,452,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"远征队在出发前需要携带一些「符文」，作为后续的冒险储备。`runes[i]`表示第`i`枚符文的魔力值。

他们将从中选取若干符文进行携带，并对这些符文进行重新排列，以确保任意相邻的两块符文之间的魔力值相差不超过`1`。

请返回他们能够携带的符文**最大数量**。

**示例1：**
>输入：`runes=[1,3,5,4,1,7]`
>
>输出：`3`
>
>解释：最佳的选择方案为[3,5,4]
>将其排列为[3,4,5]后，任意相邻的两块符文魔力值均不超过`1`，携带数量为`3`
>其他满足条件的方案为[1,1]和[7]，数量均小于3。
>因此返回可携带的最大数量`3`。

**示例2：**
>输入：`runes=[1,1,3,3,2,4]`
>
>输出：`6`
>
>解释：排列为[1,1,2,3,3,4]，可携带所有的符文

**提示：**
-`1<=runes.length<=10^4`
-`0<=runes[i]<=10^4`
",,0,0
77,754,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"在探险营地间，小扣意外发现了一片城墙遗迹，在探索期间，却不巧遇到迁徙中的兽群向他迎面冲来。情急之下小扣吹响了他的苍蓝笛，随着笛声响起，遗迹中的城墙逐渐发生了横向膨胀。
已知`rampart[i]=[x,y]`表示第`i`段城墙的初始所在区间。当城墙发生膨胀时，将遵循以下规则：
-所有的城墙会同时膨胀相等的长度；
-每个城墙可以向左、向右或向两个方向膨胀。

小扣为了确保自身的安全，需要在所有城墙均无重叠的情况下，让城墙尽可能的膨胀。请返回城墙可以膨胀的**最大值**。

**注意：**
-初始情况下，所有城墙均不重叠，且`rampart`中的元素升序排列；
-两侧的城墙可以向外无限膨胀。

**示例1：**
>输入：`rampart=[[0,3],[4,5],[7,9]]`
>
>输出：`3`
>
>解释：如下图所示：
>`rampart[0]`向左侧膨胀3个单位；
>`rampart[2]`向右侧膨胀3个单位；
>`rampart[1]`向左侧膨胀1个单位，向右膨胀2个单位。
>不存在膨胀更多的方案，返回3。
![image.png](https://pic.leetcode.cn/1681717918-tWywrp-image.png){:width=750px}

**示例2：**
>输入：`rampart=[[1,2],[5,8],[11,15],[18,25]]`
>
>输出：`4`

**提示：**
-`3<=rampart.length<=10^4`
-`rampart[i].length==2`
-`0<=rampart[i][0]<rampart[i][1]<=rampart[i+1][0]<=10^8`",,0,0
78,740,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"随着兽群逐渐远去，一座大升降机缓缓的从地下升到了远征队面前。借由这台升降机，他们将能够到达地底的永恒至森。
在升降机的操作台上，是一个由魔法符号组成的矩阵，为了便于辨识，我们用小写字母来表示。`matrix[i][j]`表示矩阵第`i`行`j`列的字母。该矩阵上有一个提取装置，可以对所在位置的字母提取。
提取装置初始位于矩阵的左上角`[0,0]`，可以通过每次操作移动到上、下、左、右相邻的1格位置中。提取装置每次移动或每次提取均记为一次操作。

远征队需要按照顺序，从矩阵中逐一取出字母以组成`mantra`，才能够成功的启动升降机。请返回他们**最少**需要消耗的操作次数。如果无法完成提取，返回`-1`。

**注意：**
-提取装置可对同一位置的字母重复提取，每次提取一个
-提取字母时，需按词语顺序依次提取

**示例1：**
>输入：`matrix=[""sd"",""ep""],mantra=""speed""`
>
>输出：`10`
>
>解释：如下图所示
![矩阵(2).gif](https://pic.leetcode-cn.com/1646288670-OTlvAl-%E7%9F%A9%E9%98%B5%20\(2\).gif)

**示例2：**
>输入：`matrix=[""abc"",""daf"",""geg""]，mantra=""sad""`
>
>输出：`-1`
>
>解释：矩阵中不存在`s`，无法提取词语

**提示：**
-`0<matrix.length,matrix[i].length<=100`
-`0<mantra.length<=100`
-`matrix和mantra`仅由小写字母组成",,0,0
79,920,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"在永恒之森中，存在着一本生物进化录，以**一个树形结构**记载了所有生物的演化过程。经过观察并整理了各节点间的关系，`parents[i]`表示编号`i`节点的父节点编号(根节点的父节点为`-1`)。

为了探索和记录其中的演化规律，队伍中的炼金术师提出了一种方法，可以以字符串的形式将其复刻下来，规则如下：
-初始只有一个根节点，表示演化的起点，依次记录`01`字符串中的字符，
-如果记录`0`，则在当前节点下添加一个子节点，并将指针指向新添加的子节点；
-如果记录`1`，则将指针回退到当前节点的父节点处。

现在需要应用上述的记录方法，复刻下它的演化过程。请返回能够复刻演化过程的字符串中，**字典序最小**的`01`字符串。

**注意：**
-节点指针最终可以停在任何节点上，不一定要回到根节点。

**示例1：**
>输入：`parents=[-1,0,0,2]`
>
>输出：`""00110""`
>
>解释：树结构如下图所示，共存在2种记录方案：
>第1种方案为：0(记录编号1的节点)->1(回退至节点0)->0(记录编号2的节点)->0((记录编号3的节点))
>第2种方案为：0(记录编号2的节点)->0(记录编号3的节点)->1(回退至节点2)->1(回退至节点0)->0(记录编号1的节点)
>返回字典序更小的`""00110""`
![image.png](https://pic.leetcode.cn/1682319485-cRVudI-image.png){:width=120px}![进化(3).gif](https://pic.leetcode.cn/1682412701-waHdnm-%E8%BF%9B%E5%8C%96%20\(3\).gif){:width=320px}



**示例2：**
>输入：`parents=[-1,0,0,1,2,2]`
>
>输出：`""00101100""`

**提示：**

-`1<=parents.length<=10^4`
-`-1<=parents[i]<i`(即父节点编号小于子节点)",,0,0
80,1386,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"在永恒之森中，封存着有关万灵之树线索的卷轴，只要探险队通过最后的考验，便可以获取前往万灵之树的线索。

探险队需要从一段不断变化的谜题数组中找到最终的密码，初始的谜题为长度为`n`的数组`arr`（下标从0开始），数组中的数字代表了`k`位二进制数。
破解谜题的过程中，需要使用`与非（NAND）`运算方式，`operations[i]=[type,x,y]`表示第`i`次进行的谜题操作信息：
-若`type=0`，表示修改操作，将谜题数组中下标`x`的数字变化为`y`；
-若`type=1`，表示运算操作，将数字`y`进行`x*n`次「与非」操作，第`i`次与非操作为`y=yNANDarr[i%n]`；
>运算操作结果即：`yNANDarr[0%n]NANDarr[1%n]NANDarr[2%n]...NANDarr[(x*n-1)%n]`

最后，将所有运算操作的结果按顺序逐一进行`异或（XOR）`运算，从而得到最终解开封印的密码。请返回最终解开封印的密码。

**注意:**
-「与非」（NAND）的操作为：先进行`与`操作，后进行`非`操作。
>例如：两个三位二进制数`2`和`3`，其与非结果为`NOT((010)AND(011))=(101)=5`

**示例1：**
>输入:
>`k=3`
>`arr=[1,2]`
>`operations=[[1,2,3],[0,0,3],[1,2,2]]`
>
>输出:`2`
>
>解释：
>初始的谜题数组为[1,2]，二进制位数为3，
>第0次进行运算操作，将数字3(011)进行2\*2次「与非」运算，
>运算操作结果为`3NAND1NAND2NAND1NAND2=5`
>第1次进行修改操作，谜题数组的第`0`个数字变化为`3`，谜题变成`[3,2]`
>第2次进行运算操作，将数字2(010)进行2\*2次「与非」运算，
>运算操作结果为`2NAND3NAND2NAND3NAND2=7`
>所有运算操作结果进行「异或」运算为`5XOR7=2`
>因此得到的最终密码为`2`。

**示例2：**
>输入:
>`k=4`
>`arr=[4,6,4,7,10,9,11]`
>`operations=[[1,5,7],[1,7,14],[0,6,7],[1,6,5]]`
>输出:`9`
>解释:
>初始的谜题数组为[4,6,4,7,10,9,11],
>第0次进行运算操作，运算操作结果为5；
>第1次进行运算操作，运算操作结果为5；
>第2次进行修改操作，修改后谜题数组为[4,6,4,7,10,9,7]；
>第3次进行运算操作，运算操作结果为9；
>所有运算操作结果进行「异或」运算为`5XOR5XOR9=9`；
>因此得到的最终密码为`9`。

**提示:**
-`1<=arr.length,operations.length<=10^4`
-`1<=k<=30`
-`0<=arr[i]<2^k`
-若`type=0`，`0<=x<arr.length`且`0<=y<2^k`
-若`type=1`，`1<=x<10^9`且`0<=y<2^k`
-保证存在`type=1`的操作
",,0,0
81,1342,2,0,LCP,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"探险家小扣终于来到了万灵之树前，挑战最后的谜题。
已知小扣拥有足够数量的链接节点和`n`颗幻境宝石，`gem[i]`表示第`i`颗宝石的数值。现在小扣需要使用这些链接节点和宝石组合成一颗二叉树，其组装规则为：
-链接节点将作为二叉树中的非叶子节点，且每个链接节点必须拥有`2`个子节点；
-幻境宝石将作为二叉树中的叶子节点，所有的幻境宝石都必须被使用。

能量首先进入根节点，而后将按如下规则进行移动和记录：
-若能量首次到达该节点时：
-记录数字`1`；
-若该节点为叶节点，将额外记录该叶节点的数值；
-若存在未到达的子节点，则选取未到达的一个子节点（优先选取左子节点）进入；
-若无子节点或所有子节点均到达过，此时记录`9`，并回到当前节点的父节点（若存在）。

如果最终记下的数依序连接成一个整数`num`，满足$num\mod~p=target$，则视为解开谜题。
请问有多少种二叉树的组装方案，可以使得最终记录下的数字可以解开谜题

**注意：**
-两棵结构不同的二叉树，作为不同的组装方案
-两棵结构相同的二叉树且存在某个相同位置处的宝石编号不同，也作为不同的组装方案
-可能存在数值相同的两颗宝石

**示例1：**
>输入：`gem=[2,3]`
>`p=100000007`
>`target=11391299`
>
>输出：`1`
>
>解释：
>包含`2`个叶节点的结构只有一种。
>假设B、C节点的值分别为3、2，对应target为11391299，如下图所示。
>11391299%100000007=11391299，满足条件;
>假设B、C节点的值分别为2、3，对应target为11291399;
>11291399%100000007=11291399，不满足条件；
>因此只存在1种方案，返回1
![万灵(1).gif](https://pic.leetcode.cn/1682397079-evMssw-%E4%B8%87%E7%81%B5%20\(1\).gif){:height=300px}


**示例2：**
>输入：`gem=[3,21,3]`
>`p=7`
>`target=5`
>
>输出：`4`
>
>解释：
包含`3`个叶节点树结构有两种，列举如下：
满足条件的组合有四种情况：
>当结构为下图（1）时：叶子节点的值为[3,3,21]或[3,3,21]，得到的整数为`11139139912199`。
>当结构为下图（2）时：叶子节点的值为[21,3,3]或[21,3,3]，得到的整数为`11219113913999`。
![image.png](https://pic.leetcode.cn/1682322894-vfqJIV-image.png){:width=500px}


**提示：**
-`1<=gem.length<=9`
-`0<=gem[i]<=10^9`
-`1<=p<=10^9`，保证$p$为素数。
-`0<=target<p`
-存在2组`gem.length==9`的用例",,0,0
0,49,4,138,LCR,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个整数和，求它们的除法的商，要求不得使用乘号、除号以及求余符号。注意：本题与主站29题相同：,"整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345)=8以及truncate(-2.7335)=-2假设我们的环境只能存储32位有符号整数，其数值范围是[−2,2−1]。本题中，如果除法结果溢出，则返回31−1<=a,b<=2-1b!=0",1,1
1,61,2,64,LCR,2,0,0,0,1,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个01字符串和，请计算它们的和，并以二进制字符串的形式输出。输入为字符串且只包含数字和。注意：本题与主站67题相同：,"每个字符串仅由字符'0'或'1'组成。1<=a.length,b.length<=10^4字符串如果不是""0""，就都不含前导零。",1,4
2,55,2,149,LCR,0,1,0,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非负整数，请计算到之间的每个数字的二进制表示中1的个数，并输出一个数组。注意：本题与主站338题相同：,0<=n<=10给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如C++中的__builtin_popcount）来执行此操作。,1,2
3,94,2,60,LCR,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组，除某个元素仅出现外，其余每个元素都恰出现请你找出并返回那个只出现了一次的元素。你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？注意：本题与主站137题相同：,1<=nums.length<=3*10<=nums[i]<=2-1nums中，除某个元素仅出现外，其余每个元素都恰出现,1,2
4,95,3,60,LCR,2,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串数组，请计算当两个字符串和不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回0。注意：本题与主站318题相同：,2<=words.length<=10001<=words[i].length<=1000words[i]仅包含小写字母,1,3
5,134,3,89,LCR,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个已按照的整数数组，请你从数组中找出两个数满足相加之和等于目标数。函数应该以长度为的整数数组的形式返回这两个数的下标值的下标，所以答案数组应当满足。假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。注意：本题与主站167题相似（下标起点不同）：,2<=numbers.length<=3*10-1000<=numbers[i]<=1000numbers按非递减顺序排列-1000<=target<=1000仅存在一个有效答案,1,3
6,56,3,36,LCR,2,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给定一个包含个整数的数组，判断中是否存在三个元素，，使得？请找出所有和为且的三元组。注意：本题与主站15题相同：,0<=nums.length<=3000-10<=nums[i]<=10,1,3
7,80,3,91,LCR,1,1,0,0,2,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个含有个正整数的数组和一个正整数找出该数组中满足其和的长度最小的，并返回其长度如果不存在符合条件的子数组，返回。提示：进阶：注意：本题与主站209题相同：,"1<=target<=101<=nums.length<=101<=nums[i]<=10如果你已经实现O(n)时间复杂度的解法,请尝试设计一个O(nlog(n))时间复杂度的解法。",1,4
8,50,2,44,LCR,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给定一个正整数数组和整数，请找出该数组内乘积小于的连续的子数组的个数。注意：本题与主站713题相同：,1<=nums.length<=3*101<=nums[i]<=10000<=k<=10,1,2
9,47,2,50,LCR,1,0,1,0,1,0,0,0,1,1,1,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给定一个整数数组和一个整数请找到该数组中和为的连续子数组的个数。注意：本题与主站560题相同：,1<=nums.length<=2*10-1000<=nums[i]<=1000-10<=k<=10,1,3
10,55,2,29,LCR,1,0,1,0,1,0,0,1,0,1,0,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,"给定一个二进制数组,找到含有相同数量的和的最长连续子数组，并返回该子数组的长度。注意：本题与主站525题相同：",1<=nums.length<=10nums[i]不是就是,1,3
11,161,3,38,LCR,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,给你一个整数数组，请计算数组的。数组是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果中心下标位于数组最左端，那么左侧数之和视为，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。如果数组有多个中心下标，应该返回的那一个。如果数组不存在中心下标，返回。注意：本题与主站724题相同：,1<=nums.length<=10-1000<=nums[i]<=1000,1,2
12,29,1,291,LCR,2,0,0,0,1,0,1,0,1,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,以下类型的多个请求：实现类：注意：本题与主站304题相同：,"计算其子矩形范围内元素的总和，该子矩阵的左上角为(row1,col1)，右下角为(row2,col2)NumMatrix(int[][]matrix)给定整数矩阵matrix进行初始化intsumRegion(introw1,intcol1,introw2,intcol2)返回左上角(row1,col1)、右下角(row2,col2)的子矩阵的元素总和。m==matrix.lengthn==matrix[i].length1<=m,n<=200-10<=matrix[i][j]<=100<=row1<=row2<m0<=col1<=col2<n最多调用次sumRegion方法",1,4
13,68,2,34,LCR,1,0,1,0,2,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和，写一个函数来判断是否包含的某个变位词。换句话说，第一个字符串的排列之一是第二个字符串的。注意：本题与主站567题相同：,"1<=s1.length,s2.length<=10和仅包含小写字母",1,4
14,73,2,34,LCR,1,0,1,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和，找到中所有的的子串，返回这些子串的起始索引。不考虑答案输出的顺序。指字母相同，但排列不同的字符串。注意：本题与主站438题相同：,"1<=s.length,p.length<=3*10和仅包含小写字母",1,3
15,39,4,33,LCR,1,0,1,0,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串，请你找出其中不含有重复字符的的长度。注意：本题与主站3题相同：,0<=s.length<=5*10由英文字母、数字、符号和空格组成,1,3
16,153,3,32,LCR,1,0,1,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定两个字符串和。返回中包含的所有字符的最短子字符串。如果中不存在符合条件的子字符串，则返回空字符串。如果中存在多个符合条件的子字符串，返回任意一个。对于中重复字符，我们寻找的子字符串中该字符数量必须不少于中该字符数量。你能设计一个在时间内解决此问题的算法吗？注意：本题与主站76题相似（本题答案不唯一）：,"1<=s.length,t.length<=10和由英文字母组成",1,3
17,67,2,30,LCR,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个字符串，验证是否是，只考虑字母和数字字符，可以忽略字母的大小写。本题中，将空字符串定义为有效的。注意：本题与主站125题相同：,1<=s.length<=2*10字符串由ASCII字符组成,1,2
18,53,3,24,LCR,1,1,0,0,1,0,0,0,1,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非空字符串，请判断如果从字符串中删除一个字符能否得到一个回文字符串。注意：本题与主站680题相同：,1<=s.length<=10由小写英文字母组成,1,3
19,82,2,26,LCR,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串，请计算这个字符串中有多少个回文子字符串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。注意：本题与主站70题相同：,1<=s.length<=1000由小写英文字母组成,1,2
20,57,3,42,LCR,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个链表，删除链表的倒数第个结点，并且返回链表的头结点。能尝试使用一趟扫描实现吗？注意：本题与主站19题相同：,链表中结点的数目为1<=sz<=300<=Node.val<=1001<=n<=sz,1,2
21,158,3,53,LCR,0,0,2,0,1,0,0,1,0,1,0,0,0,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个链表，返回链表开始入环的第一个节点。从链表的头节点开始沿着指针进入环的第一个节点为环的入口节点。如果链表无环，则返回。为了表示给定链表中的环，我们使用整数来表示链表尾连接到链表中的位置（索引从0开始）。如果是，则在该链表中没有环。不允许修改给定的链表。是否可以使用空间解决此题？注意：本题与主站142题相同：,"链表中节点的数目范围在范围[0,10-10<=Node.val<=10pos的值为或者链表中的一个有效索引",1,3
22,126,3,163,LCR,0,0,2,0,1,0,0,1,0,1,0,0,0,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个单链表的头节点和，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回。图示两个链表在节点开始相交题目数据整个链式结构中不存在环。，函数返回结果后，链表必须。能否设计一个时间复杂度、仅用内存的解决方案？注意：本题与主站160题相同：,"listA中节点数目为listB中节点数目为0<=m,n<=3*101<=Node.val<=100<=skipA<=m0<=skipB<=n如果listA和listB没有交点，intersectVal为如果listA和listB有交点，intersectVal==listA[skipA+1]==listB[skipB+1]",1,3
23,77,3,40,LCR,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定单链表的头节点，请反转链表，并返回反转后的链表的头节点。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？注意：本题与主站206题相同：,"链表中节点的数目范围是[0,5000]-5000<=Node.val<=5000",1,2
24,135,3,46,LCR,0,0,2,0,0,1,0,1,0,1,1,0,0,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个和来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。可以假设除了数字0之外，这两个数字都不会以零开头。如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。注意：本题与主站445题相同：,"链表的长度范围为[1,100]0<=node.val<=9输入数据保证链表代表的数字无前导0",1,3
25,77,2,32,LCR,0,1,2,0,1,0,0,1,0,1,0,0,0,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个单链表的头节点，单链表表示为：
请将其重新排列后变为：不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。注意：本题与主站143题相同：","链表的长度范围为[1,5*101<=node.val<=1000",1,4
26,95,2,28,LCR,0,1,2,0,1,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个链表的请判断其是否为回文链表。如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。能否用O(n)时间复杂度和O(1)空间复杂度解决此题？注意：本题与主站234题相同：,"链表L的长度范围为[1,100<=node.val<=9",1,4
27,258,4,28,LCR,0,1,2,0,0,0,0,1,0,0,0,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。以为例：序列化其中的每一级之后：为了将每一级都序列化到一起，我们需要每一级中添加值为null的元素，以表示没有节点连接到上一级的上级节点。合并所有序列化结果，并去除末尾的null。注意：本题与主站430题相同：,节点数目不超过10001<=Node.val<=10^5,1,3
28,191,3,67,LCR,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定中的一个点，写一个函数向这个列表中插入一个新元素，使这个列表仍然是循环升序的。给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。如果列表为空（给定的节点是），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。
注意：本题与主站708题相同：",0<=NumberofNodes<=5*10^4-10^6<=Node.val<=10^6-10^6<=insertVal<=10^6,1,1
29,41,1,206,LCR,1,0,1,0,0,2,1,0,0,1,0,0,0,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个支持在时间复杂度下，执行以下操作的数据结构：注意：本题与主站380题相同：,insert(val)：当元素val不存在时返回true，并向集合中插入该项，否则返回falseremove(val)：当元素val存在时返回true，并从集合中移除该项，否则返回falsegetRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。<=val<=2-1最多进行2*10次insert，remove和getRandom方法调用当调用getRandom方法时，集合中至少有一个元素,1,5
30,58,1,256,LCR,0,0,3,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,运用所掌握的数据结构，设计和实现一个。实现类：：是否可以在时间复杂度内完成这两种操作？注意：本题与主站146题相同：,"LRUCache(intcapacity)以正整数作为容量capacity初始化LRU缓存intget(intkey)如果关键字key存在于缓存中，则返回关键字的值，否则返回voidput(intkey,intvalue)如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。1<=capacity<=30000<=key<=100000<=value<=10最多调用2*10次get和put",1,4
31,134,3,36,LCR,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个字符串和，编写一个函数来判断它们是不是一组变位词（字母异位词）。若和中每个字符出现的次数都相同且，则称和互为变位词（字母异位词）。如果输入字符串包含unicode字符怎么办？你能否调整你的解法来应对这种情况？注意：本题与主站242题相似（字母异位词定义不同）：,"1<=s.length,t.length<=5*10and仅包含小写字母",0,3
32,75,3,54,LCR,3,0,1,0,0,0,0,0,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串数组，将组合在一起。可以按任意顺序返回结果列表。若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。注意：本题与主站49题相同：,1<=strs.length<=100<=strs[i].length<=100strs[i]仅包含小写字母,1,4
33,113,3,87,LCR,2,0,1,0,0,0,0,0,0,1,0,0,1,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,某种外星语也使用英文小写字母，但可能顺序不同。字母表的顺序（）是一些小写字母的排列。给定一组用外星语书写的单词，以及其字母表的顺序，只有当给定的单词在这种外星语中按字典序排列时，返回；否则，返回。注意：本题与主站953题相同：,1<=words.length<=1001<=words[i].length<=20order.length==26words[i]和order中的所有字符都是英文小写字母。,1,3
34,62,2,42,LCR,3,0,0,0,0,1,0,1,0,0,1,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个24小时制（小时:分钟）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。注意：本题与主站539题相同：,"2<=timePoints<=2*10timePoints[i]格式为""HH:MM""",1,4
35,113,3,267,LCR,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,根据，求该后缀表达式的计算结果。有效的算符包括、、、。每个运算对象可以是整数，也可以是另一个逆波兰表达式。逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。逆波兰表达式主要有以下两个优点：注意：本题与主站150题相同：,"整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为0的情况。1<=tokens.length<=10tokens[i]要么是一个算符（""+""""-""""*""或""/""），要么是一个在范围[-200,200]内的整数平常使用的算式则是一种中缀表达式，如(1+2)*(3+4)该算式的逆波兰表达式写法为((12+)(34+)*)去掉括号后表达式无歧义，上式即便写成12+34+*也可以依据次序计算出正确结果。适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。",1,3
36,184,4,63,LCR,2,0,1,0,0,0,0,0,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，表示在同一行的小行星。对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。注意：本题与主站735题相同：,2<=asteroids.length<=10-1000<=asteroids[i]<=1000asteroids[i]!=0,1,3
37,89,3,50,LCR,1,0,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请根据每日列表，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用来代替。注意：本题与主站739题相同：,1<=temperatures.length<=1030<=temperatures[i]<=100,1,3
38,82,2,38,LCR,1,0,2,0,0,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定非负整数数组，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为。求在该柱状图中，能够勾勒出来的矩形的最大面积。注意：本题与主站84题相同：,1<=heights.length<=100<=heights[i]<=10,1,3
39,69,5,77,LCR,2,1,2,0,0,0,0,1,1,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个由和组成的矩阵，找出只包含的最大矩形，并返回其面积。此题输入格式为一维字符串数组。注意：本题与主站85题相同（输入参数格式不同）：,"rows==matrix.lengthcols==matrix[0].length0<=row,cols<=200matrix[i][j]为'0'或'1'",1,5
40,63,1,159,LCR,1,0,1,0,0,0,2,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。实现类：注意：本题与主站346题相同：,MovingAverage(intsize)用窗口大小size初始化对象。doublenext(intval)成员函数next每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后size个值的移动平均值，即滑动窗口里所有数字的平均值。1<=size<=1000-10<=val<=10最多调用next方法,1,4
41,57,1,161,LCR,0,0,1,0,0,0,2,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,写一个类来计算特定时间范围内最近的请求。请实现类：每次对的调用都使用比之前更大的值。注意：本题与主站933题相同：,"RecentCounter()初始化计数器，请求数为0。intping(intt)在时间添加一个新请求，其中表示以毫秒为单位的某个时间，并返回过去3000毫秒内发生的所有请求数（包括新请求）。确切地说，返回在[t-3000,t]内发生的请求数。1<=t<=10保证每次对ping调用所使用的值都严格递增至多调用ping方法",0,3
42,105,2,244,LCR,0,1,2,0,0,0,1,0,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第层有个节点）的，并且所有的节点都尽可能地集中在左侧。设计一个用完全二叉树初始化的数据结构，它支持以下几种操作：注意：本题与主站919题相同：,CBTInserter(TreeNoderoot)使用根节点为root的给定树初始化该数据结构；CBTInserter.insert(intv)向树中插入一个新节点，节点类型为TreeNode，值为。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值CBTInserter.get_root()将返回树的根节点。最初给定的树是完全二叉树，且包含到1000个节点。每个测试用例最多调用CBTInserter.insert操作10000次。给定节点或插入节点的每个值都在到5000之间。,1,4
43,43,5,32,LCR,0,2,2,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一棵二叉树的根节点，请找出该二叉树中每一层的最大值。注意：本题与主站515题相同：,"二叉树的节点个数的范围是[0,10<=Node.val<=2-1",1,4
44,51,2,32,LCR,0,2,2,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的，请找出该二叉树的节点的值。假设二叉树中至少有一个节点。注意：本题与主站513题相同：,"二叉树的节点个数的范围是[1,10<=Node.val<=2-1",1,4
45,61,3,38,LCR,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。注意：本题与主站199题相同：,"二叉树的节点个数的范围是[0,100]-100<=Node.val<=100",1,4
46,75,3,30,LCR,0,1,2,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树，树的每个节点的值要么是，要么是。请剪除该二叉树中所有节点的值为的子树。节点的子树为本身，以及所有的后代。注意：本题与主站814题相同：,"二叉树的节点个数的范围是[1,200]二叉树节点的值只会是或",1,3
47,188,4,111,LCR,1,2,2,0,0,0,1,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列/反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。注意：本题与主站297题相同：,"输入输出格式与LeetCode目前使用的方式一致，详情请参阅LeetCode序列化二叉树的格式。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。树中结点数在范围[0,10-1000<=Node.val<=1000",1,6
48,92,2,67,LCR,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的根节点，树中每个节点都存放有一个到之间的数字。每条从根节点到叶节点的路径都代表一个数字：计算从根节点到叶节点生成的。是指没有子节点的节点。注意：本题与主站129题相同：,"例如，从根节点到叶节点的路径1->2->3表示数字123树中节点的数目在范围[1,1000]0<=Node.val<=9树的深度不超过",1,3
49,98,2,59,LCR,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二叉树的根节点，和一个整数，求该二叉树里节点值之和等于的的数目。不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。注意：本题与主站437题相同：,"二叉树的节点个数的范围是[0,1000]-10<=Node.val<=10-1000<=targetSum<=1000",0,3
50,126,2,37,LCR,0,2,2,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中。该路径节点，且不一定经过根节点。是路径中各节点值的总和。给定一个二叉树的根节点，返回其，即所有路径上节点值之和的最大值。注意：本题与主站124题相同：,"树中节点数目范围是[1,3*10-1000<=Node.val<=1000",1,4
51,82,2,35,LCR,0,1,4,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你一棵二叉搜索树，请将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。注意：本题与主站897题相同：,"树中节点数的取值范围是[1,100]0<=Node.val<=1000",1,5
52,101,2,47,LCR,0,1,3,0,0,0,0,0,1,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一棵二叉搜索树和其中的一个节点，找到该节点在树中的中序后继。如果节点没有中序后继，请返回。节点的后继是值比大的节点中键值最小的节点，即按中序遍历的顺序节点的下一个节点。注意：本题与主站285题相同：,"树中节点的数目在范围[1,10内。-10<=Node.val<=10树中各节点的值均保证唯一。",1,4
53,28,4,258,LCR,0,1,3,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,节点节点节点提醒一下，二叉搜索树满足下列约束条件：注意：,节点的左子树仅包含键小于节点键的节点。节点的右子树仅包含键大于节点键的节点。左右子树也必须是二叉搜索树。树中的节点数介于和之间。每个节点的值介于-10和之间。树中的所有值互不相同给定的树为二叉搜索树。本题与主站538题相同：https://leetcode-cn.com/problems/convert-bst-to-greater-tree/本题与主站1038题相同：https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/,0,4
54,140,1,301,LCR,0,0,4,0,0,0,2,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,实现一个二叉搜索树迭代器类，表示一个按中序遍历二叉搜索树（BST）的迭代器：注意，指针初始化为一个不存在于BST中的数字，所以对的首次调用将返回BST中的最小元素。可以假设调用总是有效的，也就是说，当调用时，BST的中序遍历中至少存在一个下一个数字。注意：本题与主站173题相同：,"BSTIterator(TreeNoderoot)初始化BSTIterator类的一个对象。BST的根节点root会作为构造函数的一部分给出。指针应初始化为一个不存在于BST中的数字，且该数字小于BST中的任何元素。booleanhasNext()如果向指针右侧遍历存在数字，则返回true；否则返回falseintnext()将指针向右移动，然后返回指针处的数字。树中节点的数目在范围[1,100<=Node.val<=10最多调用次hasNext和next操作你可以设计一个满足下述条件的解决方案吗？next()和hasNext()操作均摊时间复杂度为O(1)，并使用O(h)内存。其中是树的高度。",0,6
55,74,2,54,LCR,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定一个二叉搜索树的和一个整数,请判断该二叉搜索树中是否存在两个节点它们的值之和等于。假设二叉搜索树中节点的值均唯一。注意：本题与主站653题相同：","二叉树的节点个数的范围是[1,10-10<=Node.val<=10root为二叉搜索树-10<=k<=10",1,2
56,63,3,51,LCR,3,0,1,0,1,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个整数数组和两个整数和。请你判断是否存在和，使得，同时又满足。如果存在则返回，不存在返回。注意：本题与主站220题相同：,0<=nums.length<=2*10<=nums[i]<=2-10<=k<=100<=t<=2-1,1,5
57,232,1,51,LCR,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"请实现一个类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。有一个方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即,实数的范围为，。当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。每次调用方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回。否则，返回并且不要将该日程安排添加到日历中。请按照以下步骤调用类:注意：本题与主站729题相同：",每个测试用例，调用MyCalendar.book函数最多不超过10000<=start<end<=10,1,4
58,66,1,175,LCR,0,0,4,0,0,0,2,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,设计一个找到数据流中第大元素的类（class）。注意是排序后的第大元素，不是第个不同的元素。请实现类：注意：本题与主站703题相同：,"KthLargest(intk,int[]nums)使用整数和整数流nums初始化对象。intadd(intval)将val插入数据流nums后，返回当前数据流中第大的元素。1<=k<=100<=nums.length<=10-10<=nums[i]<=10-10<=val<=10最多调用add方法题目数据保证，在查找第大元素时，数组中至少有个元素",0,6
59,74,2,72,LCR,3,2,2,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组和一个整数，请返回其中出现频率前高的元素。可以按返回答案。所设计算法的时间复杂度优于，其中是数组大小。注意：本题与主站347题相同：,"1<=nums.length<=10的取值范围是[1,数组中不相同的元素的个数]题目数据保证答案唯一，换句话说，数组中前个高频元素的集合是唯一的",1,8
60,77,3,84,LCR,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定两个以升序排列的整数数组和,以及一个整数。定义一对值，其中第一个元素来自，第二个元素来自。请找到和最小的个数对,...。注意：本题与主站373题相同：","1<=nums1.length,nums2.length<=10-10<=nums1[i],nums2[i]<=10nums1nums2均为升序排列1<=k<=1000",1,2
61,97,1,287,LCR,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"（发音类似""try""）或者说是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现Trie类：注意：本题与主站208题相同：","Trie()初始化前缀树对象。voidinsert(Stringword)向前缀树中插入字符串wordbooleansearch(Stringword)如果字符串word在前缀树中，返回true（即，在检索之前已经插入）；否则，返回falsebooleanstartsWith(Stringprefix)如果之前已经插入的字符串word的前缀之一为prefix，返回true；否则，返回false1<=word.length,prefix.length<=2000word和prefix仅由小写英文字母组成insertsearch和startsWith调用次数不超过3*10",1,4
62,161,5,215,LCR,2,0,1,1,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在英语中，有一个叫做的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为。例如，词根，跟随着单词(其他)，可以形成新的单词(另一个)。现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有用替换掉。如果有许多可以形成它的，则用最短的词根替换它。需要输出替换之后的句子。注意：本题与主站648题相同：,"1<=dictionary.length<=10001<=dictionary[i].length<=100dictionary[i]仅由小写字母组成。1<=sentence.length<=10^6sentence仅由小写字母和空格组成。sentence中单词的总量在范围[1,1000]内。sentence中每个单词的长度在范围[1,1000]内。sentence中单词之间由一个空格隔开。sentence没有前导或尾随空格。",1,4
63,102,1,393,LCR,1,0,1,1,0,0,1,1,0,0,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个使用单词列表进行初始化的数据结构，单词列表中的单词。如果给出一个单词，请判定能否只将这个单词中字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。实现类：注意：本题与主站676题相同：,MagicDictionary()初始化对象voidbuildDict(String[]dictionary)使用字符串数组dictionary设定该数据结构，dictionary中的字符串互不相同boolsearch(StringsearchWord)给定一个字符串searchWord，判定能否只将字符串中一个字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回true；否则，返回false1<=dictionary.length<=1001<=dictionary[i].length<=100dictionary[i]仅由小写英文字母组成dictionary中的所有字符串互不相同1<=searchWord.length<=100searchWord仅由小写英文字母组成buildDict仅在search之前调用一次最多调用100次search,1,4
64,70,2,170,LCR,2,0,1,1,0,0,0,0,1,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,单词数组的由任意助记字符串和下标数组组成，且满足：给定一个单词数组，返回成功对进行编码的最小助记字符串的长度。注意：本题与主站820题相同：,words.length==indices.length助记字符串以'#'字符结尾对于每个下标indices[i]的一个从indices[i]开始、到下一个'#'字符结束（但不包括'#'）的子字符串恰好与words[i]相等1<=words.length<=20001<=words[i].length<=7words[i]仅由小写字母组成,1,4
65,30,1,234,LCR,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,实现一个类，支持两个方法，和：注意：本题与主站677题相同：,"MapSum()初始化MapSum对象voidinsert(Stringkey,intval)插入key-val键值对，字符串表示键key，整数表示值val。如果键key已经存在，那么原来的键值对将被替代成新的键值对。intsum(stringprefix)返回所有以该前缀prefix开头的键key的值的总和。1<=key.length,prefix.length<=50key和prefix仅由小写英文字母组成1<=val<=1000最多调用次insert和sum",0,4
66,52,5,35,LCR,1,0,1,1,1,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，返回的最大运算结果，其中。你可以在的时间解决这个问题吗？注意：本题与主站421题相同：,1<=nums.length<=2*100<=nums[i]<=2-1,1,4
67,92,5,62,LCR,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个排序的整数数组和一个整数目标值，请在数组中找到，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为的算法。注意：本题与主站35题相同：,1<=nums.length<=10-10<=nums[i]<=10nums无重复元素排列数组-10<=target<=10,0,2
68,87,5,146,LCR,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,符合下列属性的数组称为（：给定由整数组成的山峰数组，返回任何满足的下标，即山峰顶部。很容易想到时间复杂度的解决方案，你可以设计一个的解决方案吗？注意：本题与主站852题相同：,arr.length>=3存在0<i<arr.length-1arr[0]<arr[1]<...arr[i-1]<arr[i]arr[i]>arr[i+1]>...>arr[arr.length-1]3<=arr.length<=100<=arr[i]<=10题目数据保证arr是一个山脉数组,1,2
69,88,2,32,LCR,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。采用的方案可以在时间复杂度和空间复杂度中运行吗？注意：本题与主站540题相同：,1<=nums.length<=100<=nums[i]<=10,1,2
70,125,2,52,LCR,1,1,0,0,1,2,0,0,0,0,0,0,0,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个正整数数组，其中代表下标的权重（下标从开始），请写一个函数，它可以随机地获取下标，选取下标的概率与成正比。例如，对于，挑选下标的概率为（即，25%），而选取下标的概率为（即，75%）。也就是说，选取下标的概率为。注意：本题与主站528题相同：,1<=w.length<=100001<=w[i]<=10^5pickIndex将被调用不超过10000,0,5
71,91,2,9,LCR,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非负整数，计算并返回的平方根，即实现函数。正数的平方根有两个，只输出其中的正数平方根。如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。注意：本题与主站69题相同：,0<=x<=2-1,1,2
72,206,3,59,LCR,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,狒狒喜欢吃香蕉。这里有堆香蕉，第堆中有根香蕉。警卫已经离开了，将在小时后回来。狒狒可以决定她吃香蕉的速度（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉根。如果这堆香蕉少于根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在小时内吃掉所有香蕉的最小速度（为整数）。注意：本题与主站875题相同：,1<=piles.length<=10^4piles.length<=H<=10^91<=piles[i]<=10^9,1,2
73,79,2,62,LCR,2,0,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,以数组表示若干个区间的集合，其中单个区间为。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。注意：本题与主站56题相同：,1<=intervals.length<=10intervals[i].length==20<=start<=end<=10,1,2
74,74,1,130,LCR,3,0,1,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个数组，和，对中的元素进行排序，使中项的相对顺序和中的相对顺序相同。未在中出现过的元素需要按照升序放在的末尾。注意：本题与主站1122题相同：,"arr2中的元素各不相同arr2中的每个元素都出现在arr11<=arr1.length,arr2.length<=10000<=arr1[i],arr2[i]<=1000arr2中的元素arr2[i]各不相同arr2中的每个元素arr2[i]都出现在arr1",1,4
75,74,2,37,LCR,2,2,1,0,0,0,0,1,0,1,0,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定整数数组和整数，请返回数组中第个最大的元素。请注意，你需要找的是数组排序后的第个最大的元素，而不是第个不同的元素。注意：本题与主站215题相同：,1<=k<=nums.length<=10-10<=nums[i]<=10,1,5
76,63,3,35,LCR,1,2,1,0,1,0,0,1,0,1,0,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定链表的头结点，请将其按排列并返回。你可以在时间复杂度和常数级空间复杂度下，对链表进行排序吗？注意：本题与主站148题相同：,"链表中节点的数目在范围[0,5*10-10<=Node.val<=10",1,5
77,62,3,108,LCR,0,2,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个链表数组，每个链表都已经按升序排列。请将所有链表合并到一个升序链表中，返回合并后的链表。注意：本题与主站23题相同：,k==lists.length0<=k<=10^40<=lists[i].length<=500-10^4<=lists[i][j]<=10^4lists[i]按排列lists[i].length的总和不超过10^4,1,4
78,66,2,48,LCR,1,1,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，数组中的元素。返回该数组所有可能的子集（幂集）。解集包含重复的子集。你可以按返回解集。注意：本题与主站78题相同：,1<=nums.length<=10-10<=nums[i]<=10nums中的所有元素互不相同,1,3
79,36,2,15,LCR,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数和，返回中所有可能的个数的组合。注意：本题与主站77题相同：,1<=n<=201<=k<=n,1,2
80,114,5,82,LCR,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个的正整数数组和一个正整数，找出中所有可以使数字和为目标数的唯一组合。中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。对于给定的输入，保证和为的唯一组合数少于个。注意：本题与主站39题相同：,1<=candidates.length<=301<=candidates[i]<=200candidate中的每个元素都是独一无二的。1<=target<=500,1,2
81,84,2,58,LCR,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个可能有重复数字的整数数组和一个目标数，找出中所有可以使数字和为的组合。中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。注意：本题与主站40题相同：,1<=candidates.length<=1001<=candidates[i]<=501<=target<=30,1,2
82,41,3,47,LCR,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个不含重复数字的整数数组，返回其。可以返回答案。注意：本题与主站46题相同：,1<=nums.length<=6-10<=nums[i]<=10nums中的所有整数互不相同,1,2
83,44,2,33,LCR,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个可包含重复数字的整数集合，返回它所有不重复的全排列。注意：本题与主站47题相同：,1<=nums.length<=8-10<=nums[i]<=10,1,2
84,53,2,7,LCR,1,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,正整数代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且括号组合。注意：本题与主站22题相同：,1<=n<=8,1,3
85,70,3,25,LCR,0,2,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个字符串，请将分割成一些子串，使每个子串都是，返回s所有可能的分割方案。是正着读和反着读都一样的字符串。注意：本题与主站131题相同：,1<=s.length<=16仅由小写英文字母组成,1,4
86,191,5,23,LCR,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个只包含数字的字符串，用以表示一个IP地址，返回所有可能从获得的。你可以按任何顺序返回答案。正好由四个整数（每个整数位于0到255之间组成，且不能含有前导），整数之间用分隔。例如：""0.1.2.201""和""192.168.1.1""是IP地址，但是""0.011.255.245""、""192.168.1.312""和""192.168@1.1""是IP地址。注意：本题与主站93题相同：",0<=s.length<=3000仅由数字组成,1,2
87,148,2,35,LCR,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,数组的每个下标作为一个阶梯，第个阶梯对应着一个非负数的体力花费值（下标从开始）。每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为0或1的元素作为初始阶梯。注意：本题与主站746题相同：,2<=cost.length<=10000<=cost[i]<=999,1,2
88,120,2,34,LCR,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，。给定一个代表每个房屋存放金额的非负整数数组，请计算，一夜之内能够偷窃到的最高金额。注意：本题与主站198题相同：,1<=nums.length<=1000<=nums[i]<=400,1,2
89,146,3,35,LCR,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，。给定一个代表每个房屋存放金额的非负整数数组，请计算，今晚能够偷窃到的最高金额。注意：本题与主站213题相同：,1<=nums.length<=1000<=nums[i]<=1000,1,2
90,215,2,60,LCR,1,1,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,假如有一排房子，共个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个的正整数矩阵来表示的。例如，表示第0号房子粉刷成红色的成本花费；表示第1号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。注意：本题与主站256题相同：,costs.length==ncosts[i].length==31<=n<=1001<=costs[i][j]<=20,1,2
91,112,3,31,LCR,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果一个由和组成的字符串，是以一些（可能没有）后面跟着一些（也可能没有）的形式组成的，那么该字符串是的。我们给出一个由字符和组成的字符串，我们可以将任何翻转为或者将翻转为。返回使的最小翻转次数。注意：本题与主站926题相同：,1<=s.length<=20000中只包含字符'0'和'1',0,2
92,78,2,79,LCR,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,如果序列满足下列条件，就说它是的：给定一个的正整数数组形成序列，找到中最长的斐波那契式的子序列的长度。如果一个不存在，返回0。注意：本题与主站873题相同：,n>=3对于所有i+2<=n，都有X_i+X_{i+1}=X_{i+2}3<=arr.length<=10001<=arr[i]<arr[i+1]<=10^9,1,3
93,52,3,27,LCR,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串，请将分割成一些子串，使每个子串都是回文串。返回符合要求的。注意：本题与主站132题相同：,1<=s.length<=2000仅由小写英文字母组成,1,2
94,139,3,97,LCR,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个字符串和，返回这两个字符串的最长的长度。如果不存在，返回。一个字符串的是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。两个字符串的是这两个字符串所共同拥有的子序列。注意：本题与主站1143题相同：,"例如，""ace""是""abcde""的子序列，但""aec""不是""abcde""的子序列。1<=text1.length,text2.length<=1000text1和text2仅由小写英文字符组成。",1,2
95,80,3,117,LCR,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定三个字符串、、，请判断能不能由和组成。两个字符串和的定义与过程如下，其中每个字符串都会被分割成若干子字符串：意味着字符串和连接。注意：本题与主站97题相同：,"s=s+s+...+st=t+t+...+t|n-m|<=1是+t+s+t+s+t+...或者+s+t+s+t+s+...0<=s1.length,s2.length<=1000<=s3.length<=200、和都由小写英文字母组成",1,2
96,126,2,34,LCR,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个字符串和一个字符串，计算在的子序列中出现的个数。字符串的一个是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，是的一个子序列，而不是）题目数据保证答案符合32位带符号整数范围。注意：本题与主站115题相同：,"0<=s.length,t.length<=1000和由英文字母组成",1,2
97,111,4,27,LCR,0,1,0,0,0,2,0,0,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个机器人位于一个网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？注意：本题与主站62题相同：,"1<=m,n<=100题目数据保证答案小于等于2*10",1,3
98,79,2,60,LCR,2,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个包含非负整数的网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。一个机器人每次只能向下或者向右移动一步。注意：本题与主站64题相同：,"m==grid.lengthn==grid[i].length1<=m,n<=2000<=grid[i][j]<=100",1,3
99,109,2,143,LCR,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。在这里指的是与相同或者等于的两个结点。也就是说，如果正位于当前行的下标，那么下一步可以移动到下一行的下标或。注意：本题与主站120题相同：,1<=triangle.length<=200triangle[0].length==1triangle[i].length==triangle[i-1].length+1-10<=triangle[i][j]<=10你可以只使用O(n)的额外空间（为三角形的总行数）来解决这个问题吗？,1,2
100,50,2,34,LCR,2,0,0,0,0,1,0,1,1,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个非空的正整数数组，请判断能否将这些数字分成元素和相等的两部分。注意：本题与主站416题相同：,1<=nums.length<=2001<=nums[i]<=100,1,3
101,88,2,125,LCR,1,2,0,0,0,0,0,1,0,0,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个正整数数组和一个整数。向数组中的每个整数前添加或，然后串联起所有整数，可以构造一个：返回可以通过上述方法构造的、运算结果等于的不同的数目。注意：本题与主站494题相同：,"例如，nums=[2,1]，可以在之前添加'+'，在之前添加'-'，然后串联起来得到表达式""+2-1""1<=nums.length<=200<=nums[i]<=10000<=sum(nums[i])<=1000-1000<=target<=1000",1,3
102,97,5,48,LCR,1,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定不同面额的硬币和一个总金额。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回。你可以认为每种硬币的数量是无限的。注意：本题与主站322题相同：,1<=coins.length<=121<=coins[i]<=2-10<=amount<=10,1,3
103,165,2,64,LCR,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个由正整数组成的数组，和一个目标整数。请从中找出并返回总和为的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。题目数据保证答案符合32位整数范围。如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？注意：本题与主站377题相同：,1<=nums.length<=2001<=nums[i]<=1000nums中的所有元素互不相同1<=target<=1000,1,2
104,142,2,63,LCR,2,2,0,1,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个由和组成的非空二维数组，用来表示海洋岛屿地图。一个是由一些相邻的(代表土地)构成的组合，这里的「相邻」要求两个必须在水平或者竖直方向上相邻。你可以假设的四个边缘都被（代表水）包围着。找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为。注意：本题与主站695题相同：,"m==grid.lengthn==grid[i].length1<=m,n<=50grid[i][j]iseither0or1",1,5
105,205,2,231,LCR,0,2,1,1,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,存在一个，图中有个节点。其中每个节点都有一个介于到之间的唯一编号。给定一个二维数组，表示图，其中是一个节点数组，由节点的邻接节点组成。形式上，对于中的每个，都存在一条位于节点和节点之间的无向边。该无向图同时具有以下属性：定义：如果能将一个图的节点集合分割成两个独立的子集和，并使图中的每一条边的两个节点一个来自集合，一个来自集合，就将这个图称为。如果图是二分图，返回；否则，返回。注意：本题与主站785题相同：,不存在自环（graph[u]不包含不存在平行边（graph[u]不包含重复值）。如果在graph[u]内，那么也应该在graph[v]内（该图是无向图）这个图可能不是连通图，也就是说两个节点和之间可能不存在一条连通彼此的路径。graph.length==n1<=n<=1000<=graph[u].length<n0<=graph[u][i]<=n-1graph[u]不会包含graph[u]的所有值互不相同如果graph[u]包含，那么graph[v]也会包含,1,4
106,75,2,80,LCR,2,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个由和组成的矩阵，请输出一个大小相同的矩阵，其中每一个格子是中对应位置元素到最近的的距离。两个相邻元素间的距离为。注意：本题与主站542题相同：,"m==mat.lengthn==mat[i].length1<=m,n<=101<=m*n<=10mat[i][j]iseither0or1.mat中至少有一个",1,4
107,93,2,265,LCR,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在字典（单词列表）中，从单词和的是一个按下述规格形成的序列：给定两个长度相同但内容不同的单词和和一个字典，找到从到的中的。如果不存在这样的转换序列，返回0。注意：本题与主站127题相同：,序列中第一个单词是beginWord序列中最后一个单词是endWord每次转换只能改变一个字母。转换过程中的中间单词必须是字典wordList中的单词。1<=beginWord.length<=10endWord.length==beginWord.length1<=wordList.length<=5000wordList[i].length==beginWord.lengthbeginWordendWord和wordList[i]由小写英文字母组成beginWord!=endWordwordList中的所有字符串互不相同,1,3
108,199,4,103,LCR,2,1,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个密码锁由4个环形拨轮组成，每个拨轮都有10个数字：。每个拨轮可以自由旋转：例如把变为，变为。每次旋转都只能旋转一个拨轮的一位数字。锁的初始数字为，一个代表四个拨轮的数字的字符串。列表包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。字符串代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回。注意：本题与主站752题相同：,1<=deadends.length<=500deadends[i].length==4target.length==4targetdeadends之中target和deadends[i]仅由若干位数字组成,1,4
109,135,5,68,LCR,0,3,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,MEDIUM,给定一个有个节点的有向无环图，用二维数组表示，请找到所有从到的路径并输出（不要求按顺序）。的第个数组中的单元都表示有向图中号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了a→b你就不能从b→a），若为空，就是没有下一个节点了。注意：本题与主站797题相同：,n==graph.length2<=n<=150<=graph[i][j]<ngraph[i][j]!=i保证输入为有向无环图(GAD),1,4
110,209,3,200,LCR,1,2,2,1,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,给定一个变量对数组和一个实数值数组作为已知条件，其中和共同表示等式。每个或是一个表示单个变量的字符串。另有一些以数组表示的问题，其中表示第个问题，请你根据已知条件找出的结果作为答案。返回。如果存在某个无法确定的答案，则用替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用替代这个答案。输入总是有效的。可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。注意：本题与主站399题相同：,"1<=equations.length<=20equations[i].length==21<=A.length,B.length<=5values.length==equations.length0.0<values[i]<=20.01<=queries.length<=20queries[i].length==21<=C.length,D.length<=5,B,C,D由小写英文字母与数字组成",0,6
111,77,3,66,LCR,2,4,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,HARD,给定一个整数矩阵，找出其中的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。在方向上移动或移动到（即不允许环绕）。注意：本题与主站329题相同：,"m==matrix.lengthn==matrix[i].length1<=m,n<=2000<=matrix[i][j]<=2-1",1,8
112,152,3,141,LCR,0,2,2,0,0,0,0,0,1,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,MEDIUM,现在总共有门课需要选，记为到。给定一个数组，它的每一个元素表示两门课程之间的先修顺序。例如表示想要学习课程，需要先完成课程。请根据给出的总课程数和表示先修顺序的得出一个可行的修课序列。可能会有多个正确的顺序，只要任意返回一种就可以了。如果不可能完成所有课程，返回一个空数组。注意：本题与主站210题相同：,"1<=numCourses<=20000<=prerequisites.length<=numCourses*(numCourses-1)prerequisites[i].length==20<=ai,bi<numCoursesai!=biprerequisites中不存在重复元素",1,4
113,153,3,168,LCR,2,2,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,HARD,现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。给定一个字符串列表，作为这门语言的词典，中的字符串已经。请你根据该词典还原出此语言中已知的字母顺序，并排列。若不存在合法字母顺序，返回。若存在多种可能的合法字母顺序，返回其中顺序即可。字符串字符串有两种情况：注意：本题与主站269题相同：,"在第一个不同字母处，如果中的字母在这门外星语言的字母顺序中位于中字母之前，那么的字典顺序小于如果前面min(s.length,t.length)字母都相同，那么s.length<t.length时，的字典顺序也小于1<=words.length<=1001<=words[i].length<=100words[i]仅由小写英文字母组成",1,6
114,160,3,314,LCR,1,0,2,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个长度为的整数数组，其中是范围为的整数的排列。还提供了一个2D整数数组，其中是的子序列。
检查是否是唯一的最短。最短是的序列，并且所有序列都是它的子序列。对于给定的数组，可能存在多个有效的。
是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。注意：本题与主站444题相同：","例如，对于sequences=[[1,2],[1,3]]，有两个最短的超序列[1,2,3]和[1,3,2]而对于sequences=[[1,2],[1,3],[1,2,3]]，唯一可能的最短超序列是[1,2,3][1,2,3,4]是可能的超序列，但不是最短的。n==nums.length1<=n<=10nums是[1,n]范围内所有整数的排列1<=sequences.length<=101<=sequences[i].length<=101<=sum(sequences[i].length)<=101<=sequences[i][j]<=nsequences的所有数组都是唯一sequences[i]是nums的一个子序列",1,3
115,146,2,129,LCR,0,2,1,1,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个城市，其中一些彼此相连，另一些没有相连。如果城市与城市直接相连，且城市与城市直接相连，那么城市与城市间接相连。是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个的矩阵，其中表示第个城市和第个城市直接相连，而表示二者不直接相连。返回矩阵中的数量。注意：本题与主站547题相同：,1<=n<=200n==isConnected.lengthn==isConnected[i].lengthisConnected[i][j]为或isConnected[i][i]==1isConnected[i][j]==isConnected[j][i],1,4
116,273,2,86,LCR,1,2,0,1,0,0,0,0,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,如果交换字符串中的两个不同位置的字母，使得它和字符串相等，那么称和两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。例如，和是相似的(交换与的位置)；和也是相似的，但是不与，，或相似。总之，它们通过相似性形成了两个关联组：和。注意，和是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。给定一个字符串列表。列表中的每个字符串都是中其它所有字符串的一个。请问中有多少个相似字符串组？，一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。注意：本题与主站839题相同：,1<=strs.length<=3001<=strs[i].length<=300strs[i]只包含小写字母。strs中的所有单词都具有相同的长度，且是彼此的字母异位词。,0,4
117,172,2,90,LCR,0,2,1,1,0,0,0,0,0,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,树可以看成是一个连通且的图。给定往一棵个节点(节点值)的树中添加一条边后的图。添加的边的两个顶点包含在到中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为的二维数组，表示图中在和之间存在一条边。请找出一条可以删去的边，删除后可使得剩余部分是一个有着个节点的树。如果有多个答案，则返回数组中最后出现的边。注意：本题与主站684题相同：,n==edges.length3<=n<=1000edges[i].length==21<=ai<bi<=edges.lengthai!=biedges中无重复元素给定的图是连通的,1,4
118,79,2,34,LCR,1,0,1,1,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个未排序的整数数组，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。可以设计并实现时间复杂度为的解决方案吗？注意：本题与主站128题相同：,0<=nums.length<=10-10<=nums[i]<=10,1,3
0,450,2,0,LCS,0,2,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"小扣打算给自己的**VScode**安装使用插件，初始状态下带宽每分钟可以完成`1`个插件的下载。假定每分钟选择以下两种策略之一:
-使用当前带宽下载插件
-将带宽加倍（下载插件数量随之加倍）

请返回小扣完成下载`n`个插件最少需要多少分钟。

注意：实际的下载的插件数量可以超过`n`个


**示例1：**
>输入：`n=2`
>
>输出：`2`
>
>解释：
>以下两个方案，都能实现2分钟内下载2个插件
>-方案一：第一分钟带宽加倍，带宽可每分钟下载2个插件；第二分钟下载2个插件
>-方案二：第一分钟下载1个插件，第二分钟下载1个插件

**示例2：**
>输入：`n=4`
>
>输出：`3`
>
>解释：
>最少需要3分钟可完成4个插件的下载，以下是其中一种方案:
>第一分钟带宽加倍，带宽可每分钟下载2个插件;
>第二分钟下载2个插件;
>第三分钟下载2个插件。



**提示：**
-`1<=n<=10^5`
",,1,3
1,477,2,0,LCS,2,1,1,0,0,0,0,1,0,0,0,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"有`N`位扣友参加了微软与力扣举办了「以扣会友」线下活动。主办方提供了`2*N`道题目，整型数组`questions`中每个数字对应了每道题目所涉及的知识点类型。
若每位扣友选择不同的一题，请返回被选的`N`道题目至少包含多少种知识点类型。


**示例1：**
>输入：`questions=[2,1,6,2]`
>
>输出：`1`
>
>解释：有2位扣友在4道题目中选择2题。
>可选择完成知识点类型为2的题目时，此时仅一种知识点类型
>因此至少包含1种知识点类型。

**示例2：**
>输入：`questions=[1,5,1,3,4,5,2,5,3,3,8,6]`
>
>输出：`2`
>
>解释：有6位扣友在12道题目中选择题目，需要选择6题。
>选择完成知识点类型为3、5的题目，因此至少包含2种知识点类型。



**提示：**
-`questions.length==2*n`
-`2<=questions.length<=10^5`
-`1<=questions[i]<=1000`",,1,4
2,689,2,0,LCS,2,2,0,1,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"「以扣会友」线下活动所在场地由若干主题空间与走廊组成，场地的地图记作由一维字符串型数组`grid`，字符串中仅包含`""0""～""5""`这6个字符。地图上每一个字符代表面积为1的区域，其中`""0""`表示走廊，其他字符表示主题空间。相同且连续（连续指上、下、左、右四个方向连接）的字符组成同一个主题空间。

假如整个`grid`区域的外侧均为走廊。请问，不与走廊直接相邻的主题空间的最大面积是多少？如果不存在这样的空间请返回`0`。

**示例1:**
>输入：`grid=[""110"",""231"",""221""]`
>
>输出：`1`
>
>解释：4个主题空间中，只有1个不与走廊相邻，面积为1。
>![image.png](https://pic.leetcode-cn.com/1613708145-rscctN-image.png)


**示例2:**
>输入：`grid=[""11111100000"",""21243101111"",""21224101221"",""11111101111""]`
>
>输出：`3`
>
>解释：8个主题空间中，有5个不与走廊相邻，面积分别为3、1、1、1、2，最大面积为3。
>![image.png](https://pic.leetcode-cn.com/1613707985-KJyiXJ-image.png)


**提示：**
-`1<=grid.length<=500`
-`1<=grid[i].length<=500`
-`grid[i][j]`仅可能是`""0""～""5""`

",,1,5
0,100,1,0,剑指,2,0,1,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"找出数组中重复的数字。
在一个长度为n的数组nums里的所有数字都在0～n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。",,1,3
1,137,1,0,剑指,2,2,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个n*m的二维数组中，每一行都按照从左到右的顺序排序，每一列都按照从上到下的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。现有矩阵matrix如下：给定target=，返回。给定target=，返回。本题与主站240题相同：,,1,4
2,27,1,0,剑指,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"请实现一个函数，把字符串中的每个空格替换成""%20""。",,1,1
3,34,1,0,剑指,0,1,2,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。,,1,4
4,75,2,0,剑指,1,1,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。：本题与主站105题重复：,,1,5
5,74,2,49,剑指,0,0,2,0,0,0,1,1,0,1,0,0,0,1,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,用两个栈实现一个队列。队列的声明如下，请实现它的两个函数和，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，操作返回-1),1<=values<=10000最多会对appendTail、deleteHead10000次调用,1,3
6,130,2,9,剑指,0,2,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,写一个函数，输入，求斐波那契（Fibonacci）数列的第项（即）。斐波那契数列的定义如下：斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出。答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回1。,0<=n<=100,1,3
7,109,3,9,剑指,0,2,0,0,0,1,0,1,0,1,0,0,0,1,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个级的台阶总共有多少种跳法。答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回1。注意：本题与主站70题相同：,0<=n<=100,1,3
8,138,2,78,剑指,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。给你一个可能存在元素值的数组，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的。例如，数组为的一次旋转，该数组的最小值为1。注意，数组旋转一次的结果为数组。注意：本题与主站154题相同：,n==numbers.length1<=n<=5000-5000<=numbers[i]<=5000numbers原来是一个升序排序的数组，并进行了至次旋转,1,2
9,157,2,79,剑指,2,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个二维字符网格和一个字符串单词。如果存在于网格中，返回；否则，返回。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。例如，在下面的3×4的矩阵中包含单词""ABCCED""（单词中的字母已标出）。本题与主站79题相同：","m==board.lengthn=board[i].length1<=m,n<=61<=word.length<=15boardword仅由大小写英文字母组成",1,3
10,173,2,19,剑指,0,3,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"地上有一个m行n列的方格，从坐标到坐标。一个机器人从坐标的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格[35,37]，因为3+5+3+7=18。但它不能进入方格[35,38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？","1<=n,m<=1000<=k<=20",1,3
11,126,2,8,剑指,0,1,0,0,0,1,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一根长度为的绳子，请把绳子剪成整数长度的段（m、n都是整数，n>1并且m>1），每段绳子的长度记为。请问可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。注意：本题与主站343题相同：,2<=n<=58,1,2
12,175,2,10,剑指,0,1,0,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一根长度为的绳子，请把绳子剪成整数长度的段（m、n都是整数，n>1并且m>1），每段绳子的长度记为。请问可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回1。注意：本题与主站343题相同：,2<=n<=1000,1,2
13,73,4,162,剑指,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为'1'的个数（也被称为).）。注意：本题与主站191题相同：,请注意，在某些语言（如Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在Java中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的示例3中，输入表示有符号整数输入必须是长度为的二进制串,1,1
14,53,3,46,剑指,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,实现，即计算x的n次幂函数（即，x）。不得使用库函数，同时不需要考虑大数问题。注意：本题与主站50题相同：,-100.0<x<100.0<=n<=2是一个整数要么不为零，要么n>0-10<=x<=10,1,2
15,55,1,19,剑指,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入数字，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。说明：,用返回一个整数列表来代替打印n为正整数,1,2
16,56,2,47,剑指,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。此题对比原题有改动,题目保证链表中节点的值互不相同若使用C或C++语言，你不需要free或delete被删除的节点,1,1
17,117,5,50,剑指,1,2,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,请实现一个函数用来匹配包含和的正则表达式。模式中的字符表示任意一个字符，而表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串与模式和匹配，但与和均不匹配。注意：本题与主站10题相同：,可能为空，且只包含从a-z的小写字母。可能为空，且只包含从a-z的小写字母以及字符和，无连续的'*',1,3
18,90,4,145,剑指,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请实现一个函数用来判断字符串是否表示（包括整数和小数）。（按顺序）可以分成以下几个部分：（按顺序）可以分成以下几个部分：（按顺序）可以分成以下几个部分：部分列举如下：部分列举如下：,"[""+100"",""5e2"",""-123"",""3.1416"",""-1E-16"",""0123""][""12e"",""1a3.14"",""1.2.3"",""+-5"",""12e+5.4""]1<=s.length<=20仅含英文字母（大写和小写），数字（0-9），加号'+'，减号'-'，空格''或者点'.'",1,1
19,56,1,0,剑指,2,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。,,1,3
20,103,1,0,剑指,0,0,1,0,1,0,0,1,0,1,0,0,1,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有个节点，从头节点开始，它们的值依次是。这个链表的倒数第个节点是值为的节点。,,1,2
21,49,1,0,剑指,0,1,1,0,0,0,0,1,0,1,0,0,0,1,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。：本题与主站206题相同：,,1,2
22,51,1,0,剑指,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。注意：本题与主站21题相同：,,1,2
23,116,2,0,剑指,0,1,2,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)B是A的子结构，即A中有出现和B相同的结构和节点值。例如:
给定的树A:
给定的树B：
返回true，因为B与A的一个子树拥有相同的结构和节点值。",,1,3
24,53,1,0,剑指,0,2,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"请完成一个函数，输入一个二叉树，该函数输出它的镜像。例如输入：
镜像输出：注意：本题与主站226题相同：",,1,4
25,126,2,0,剑指,0,2,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树[1,2,2,3,4,4,3]是对称的。
但是下面这个[1,2,2,null,3,null,3]则不是镜像对称的:注意：本题与主站101题相同：",,1,4
26,45,2,45,剑指,3,0,0,0,0,0,0,1,0,1,0,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。注意：本题与主站54题相同：,0<=matrix.length<=1000<=matrix[i].length<=100,1,3
27,82,1,0,剑指,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数在该栈中，调用min、push及pop的时间复杂度都是O(1)。注意：本题与主站155题相同：,,1,2
28,154,2,0,剑指,2,0,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该压栈序列对应的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。注意：本题与主站946题相同：",,1,3
29,49,1,0,剑指,0,1,2,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。例如:
给定二叉树:,返回：",,1,3
30,75,1,0,剑指,0,1,2,0,0,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。例如:
给定二叉树:,返回其层次遍历结果：注意：本题与主站102题相同：",,1,3
31,97,1,0,剑指,0,1,2,0,0,0,0,1,0,1,0,0,0,0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。例如:
给定二叉树:,返回其层次遍历结果：",,1,3
32,75,2,0,剑指,0,1,5,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回，否则返回。假设输入的数组的任意两个数字都互不相同。参考以下这颗二叉搜索树：,,1,6
33,63,3,60,剑指,0,2,2,0,0,0,0,0,1,1,0,0,0,1,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你二叉树的根节点和一个整数目标和，找出所有路径总和等于给定目标和的路径。是指没有子节点的节点。注意：本题与主站113题相同：,"树中节点总数在范围[0,5000]-1000<=Node.val<=1000-1000<=targetSum<=1000",1,4
34,72,4,64,剑指,0,0,2,0,0,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请实现函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个指针指向下一个节点，还有一个指针指向链表中的任意节点或者。本题与主站138题相同：,-10000<=Node.val<=10000Node.random为空（null）或指向链表中的节点。节点数目不超过1000。,1,2
35,305,1,0,剑指,0,1,6,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。为了让您更好地理解问题，以下面的二叉搜索树为例：我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。下图展示了上面的二叉搜索树转化成的链表。“head”表示指向链表中有最小元素的节点。特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。本题与主站426题相同：此题对比原题有改动。,,1,7
36,189,1,0,剑指,1,2,2,0,0,0,1,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,请实现两个函数，分别用来序列化和反序列化二叉树。你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列/反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。输入输出格式与LeetCode目前使用的方式一致，详情请参阅。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。注意：本题与主站297题相同：,,1,6
37,53,1,0,剑指,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。,,1,2
38,74,1,0,剑指,2,1,1,0,1,0,0,1,0,1,0,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。注意：本题与主站169题相同：,,1,5
39,60,2,39,剑指,2,2,1,0,0,0,0,0,0,1,1,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入整数数组，找出其中最小的个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。,0<=k<=arr.length<=100000<=arr[i]<=10000,1,5
40,163,2,101,剑指,1,0,1,0,1,0,2,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。例如，[2,3,4]的中位数是3[2,3]的中位数是(2+3)/2=2.5设计一个支持以下两种操作的数据结构：注意：本题与主站295题相同：",voidaddNum(intnum)-从数据流中添加一个整数到数据结构中。doublefindMedian()-返回目前所有元素的中位数。最多会对addNum、findMedian进行50000次调用。,1,5
41,70,1,36,剑指,1,2,0,0,0,0,0,0,0,1,0,0,1,1,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。注意：本题与主站53题相同：,1<=arr.length<=10^5-100<=arr[i]<=100,1,3
42,89,2,4,剑指,0,2,0,0,0,1,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,输入一个整数，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1的数字有1、10、11和12，1一共出现了5次。注意：本题与主站233题相同：,1<=n,1,3
43,115,2,9,剑指,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。注意：本题与主站400题相同：,0<=n<2^31,1,2
44,47,2,72,剑指,2,1,0,0,0,0,0,0,1,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。,0<nums.length<=100输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导0，最后结果不需要去掉前导0,1,3
45,106,1,8,剑指,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成“a”，1翻译成“b”，……，11翻译成“l”，……，25翻译成“z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。,0<=num<2,1,2
46,122,1,39,剑指,2,1,0,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？提示：,0<grid.length<=2000<grid[0].length<=200,1,3
47,55,3,15,剑指,1,0,1,0,1,0,0,0,0,1,0,0,1,1,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。提示：注意：本题与主站3题相同：,s.length<=40000,1,3
48,64,1,0,剑指,0,1,2,0,0,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,我们把只包含质因子2、3和5的数称作丑数（UglyNumber）。求按从小到大的顺序的第n个丑数。注意：本题与主站264题相同：,,1,4
49,42,2,0,剑指,1,0,2,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,在字符串s中找出第一个只出现一次的字符。如果没有，返回一个单空格。s只包含小写字母。,,1,4
50,62,1,0,剑指,1,3,1,2,0,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。,,1,7
51,38,3,155,剑指,0,0,2,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入两个链表，找出它们的第一个公共节点。如下面的两个链表在节点c1开始相交。,如果两个链表没有交点，返回null在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足O()时间复杂度，且仅用O()内存。本题与主站160题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/,1,3
52,37,2,61,剑指,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,统计一个数字在排序数组中出现的次数。本题与主站34题相同（仅返回值不同）：,0<=nums.length<=10-10<=nums[i]<=10nums是一个非递减数组-10<=target<=10,1,2
53,83,2,0,剑指,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。,,1,5
54,23,2,13,剑指,0,1,3,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一棵二叉搜索树，请找出其中第大的节点的值。,1≤k≤二叉搜索树元素个数,1,4
55,98,1,0,剑指,0,2,2,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。例如：给定二叉树，返回它的最大深度3。注意：本题与主站104题相同：,,1,4
56,99,2,16,剑指,0,1,2,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。给定二叉树返回。

给定二叉树返回。注意：本题与主站110题相同：",0<=树的结点个数<=10000,1,3
57,68,2,21,剑指,1,0,0,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。,2<=nums.length<=10000,1,2
58,44,2,36,剑指,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。,1<=nums.length<=100001<=nums[i]<2^31,1,2
59,62,2,36,剑指,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。,1<=nums.length<=10^51<=nums[i]<=10^6,1,3
60,62,2,15,剑指,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,输入一个正整数，输出所有和为的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。,1<=target<=10^5,1,3
61,113,3,79,剑指,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串""Iamastudent.""，则输出""student.aamI""。本题与主站151题相同：此题对比原题有改动",无空格字符构成一个单词。输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。,1,2
62,101,2,20,剑指,1,0,0,0,1,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串""abcdefg""和数字2，该函数将返回左旋转两位得到的结果""cdefgab""。",1<=k<s.length<=10000,1,3
63,67,1,0,剑指,0,0,3,0,1,0,0,0,1,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。你可以假设总是有效的，在输入数组的情况下，。注意：本题与主站239题相同：,,1,4
64,54,2,58,剑指,0,0,2,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请定义一个队列并实现函数得到队列里的最大值，要求函数、和的时间复杂度都是O(1)。若队列为空，和需要返回-1,"1<=push_back,pop_front,max_value的总操作数<=100001<=value<=10^5",1,3
65,97,2,0,剑指,0,1,0,0,0,2,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第i个元素代表这n个骰子所能掷出的点数集合中第i小的那个的概率。,,1,3
66,104,2,0,剑指,2,0,0,0,0,0,0,1,0,1,0,0,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"从中随机抽张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为0，可以看成任意数字。A不能视为14。数组长度为5数组的数取值为[0,13].",,1,2
67,150,2,20,剑指,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。",1<=n<=10^51<=m<=10^6,1,2
68,58,2,0,剑指,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？本题与主站121题相同：,,1,2
69,60,2,11,剑指,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,求，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。,1<=n<=10000,1,3
70,47,1,19,剑指,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,写一个函数，求两个整数之和，要求在函数体内不得使用“+”、“-”、“*”、“/”四则运算符号。,均可能是负数或0结果不会溢出32位整数,1,2
71,44,1,33,剑指,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一个数组，请构建一个数组，其中的值是数组中除了下标以外的元素的积,即。不能使用除法。",所有元素乘积之和不会溢出32位整数a.length<=100000,1,2
72,412,5,0,剑指,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"写一个函数StrToInt，实现把字符串转换成整数这个功能。不能使用atoi或者其他类似的库函数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回0。假设我们的环境只能存储32位大小的有符号整数，那么其数值范围为[−2,2−1]。如果数值超过这个范围，请返回INT_MAX(2−1)或INT_MIN(−2)。注意：本题与主站8题相同：",,1,1
73,157,2,35,剑指,0,1,3,0,0,0,0,1,0,1,0,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定一个二叉搜索树,找到该树中两个指定节点的最近公共祖先。中最近公共祖先的定义为：“对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（）。”例如，给定如下二叉搜索树:root=[6,2,8,0,4,7,9,null,null,3,5]注意：本题与主站235题相同：",所有节点的值都是唯一的。p、q为不同节点且均存在于给定的二叉搜索树中。,1,4
74,153,2,33,剑指,0,1,2,0,0,0,0,1,0,1,0,0,0,1,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"给定一个二叉树,找到该树中两个指定节点的最近公共祖先。中最近公共祖先的定义为：“对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（）。”例如，给定如下二叉树:root=[3,5,1,6,2,0,8,null,null,7,4]注意：本题与主站236题相同：",所有节点的值都是唯一的。p、q为不同节点且均存在于给定的二叉树中。,1,3
0,26,2,44,面试题,2,0,1,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,实现一个算法，确定一个字符串的所有字符是否全都不同。,0<=len(s)<=100s[i]仅包含小写字母如果你不使用额外的数据结构，会很加分。,1,4
1,54,2,30,面试题,2,0,1,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个由小写字母组成的字符串和，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。,0<=len(s1)<=1000<=len(s2)<=100,1,3
2,93,2,20,面试题,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,URL化。编写一种方法，将字符串中的空格全部替换为。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用实现的话，请使用字符数组实现，以便直接在数组上操作。）,"字符串长度在[0,500000]范围内。",1,1
3,79,1,0,面试题,1,0,1,0,1,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。,,1,3
4,73,2,0,面试题,1,0,0,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。,,1,2
5,98,2,0,面试题,1,0,0,0,1,0,0,1,0,1,0,0,0,1,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串会变为。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。,,1,2
6,71,2,0,面试题,2,0,0,0,0,1,0,0,1,1,1,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一幅由矩阵表示的图像，其中每个像素的大小为4字节。请你设计一种算法，将图像旋转90度。不占用额外内存空间能否做到？：本题与主站48题相同：,,1,3
7,33,2,0,面试题,2,0,1,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,编写一种算法，若M×N矩阵中某个元素为0，则将其所在的行与列清零。,,1,3
8,43,2,0,面试题,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,字符串轮转。给定两个字符串和，请编写代码检查是否为旋转而成（比如，是旋转后的字符串）。,,1,2
9,48,2,0,面试题,0,0,2,0,1,0,0,0,0,1,0,1,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。如果不得使用临时缓冲区，该怎么解决？,,1,3
10,50,1,0,面试题,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,实现一种算法，找出单向链表中倒数第k个节点。返回该节点的值。本题相对原题稍作改动给定的保证是有效的。,,1,2
11,105,1,0,面试题,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。例如，传入节点（位于单向链表中），将其删除后，剩余链表为,,1,1
12,64,2,49,面试题,0,0,1,0,1,0,0,0,0,1,0,1,1,0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给你一个链表的头节点和一个特定值，请你对链表进行分隔，使得所有的节点都出现在的节点之前。你不需要每个分区中各节点的初始相对位置。,"链表中节点的数目在范围[0,200]-100<=Node.val<=100-200<=x<=200",1,2
13,97,2,0,面试题,0,1,1,0,0,1,0,1,1,1,0,0,0,0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。思考一下，假设这些数位是正向存放的，又该如何解决呢?,,1,3
14,51,2,0,面试题,0,1,2,0,1,0,0,1,1,1,0,0,0,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"编写一个函数，检查输入的链表是否是回文的。
你能否用O(n)时间复杂度和O(1)空间复杂度解决此题？",,1,4
15,113,3,163,面试题,0,0,2,0,1,0,0,1,0,1,0,0,1,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给你两个单链表的头节点和，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回。图示两个链表在节点开始相交题目数据整个链式结构中不存在环。，函数返回结果后，链表必须。你能否设计一个时间复杂度、仅用内存的解决方案？,"listA中节点数目为listB中节点数目为0<=m,n<=3*101<=Node.val<=100<=skipA<=m0<=skipB<=n如果listA和listB没有交点，intersectVal为如果listA和listB有交点，intersectVal==listA[skipA+1]==listB[skipB+1]",1,3
16,144,3,16,面试题,0,0,2,0,1,0,0,0,0,1,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个链表，如果它是有环链表，实现一个算法返回环路的。若环不存在，请返回。如果链表中有某个节点，可以通过连续跟踪指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数来表示链表尾连接到链表中的位置（索引从0开始）。如果是，则在该链表中没有环。，仅仅是为了标识链表的实际情况。,你是否可以不用额外空间解决此题？,1,3
17,66,2,14,面试题,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,三合一。描述如何只用一个数组来实现三个栈。你应该实现、、、方法。表示栈下标，表示压入的值。构造函数会传入一个参数，代表每个栈的大小。,0<=stackNum<=2,1,3
18,81,1,0,面试题,0,0,1,0,0,0,1,1,0,1,0,0,0,1,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。,,1,2
19,206,2,0,面试题,0,0,2,0,0,0,1,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构，模拟这种行为。应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，和应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。进阶：实现一个方法，根据指定的子栈，执行pop操作。当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，，应返回-1.,,1,3
20,27,1,154,面试题,0,0,2,0,0,0,1,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,实现一个MyQueue类，该类用两个栈来实现一个队列。,你只能使用标准的栈操作--也就是只有pushtotoppeek/popfromtopsize和isempty操作是合法的。你所使用的语言也许不支持栈。你可以使用list或者deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的（例如，一个空的队列不会调用pop或者peek操作）。,1,3
21,90,2,0,面试题,0,0,2,0,0,0,1,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,栈排序。编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：、、和。当栈为空时，返回-1。,,1,3
22,246,2,0,面试题,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如、、和。允许使用Java内置的LinkedList数据结构。方法有一个参数，代表动物编号，代表动物种类，其中0代表猫，1代表狗。方法返回一个列表，若没有可以收养的动物，则返回。,,1,2
23,36,2,0,面试题,0,2,1,0,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。,,1,3
24,46,1,0,面试题,1,1,3,0,0,0,0,0,0,1,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。,,1,5
25,71,1,0,面试题,0,1,3,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为，则会创建出个链表）。返回一个包含所有深度的链表的数组。,,1,4
26,54,2,0,面试题,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过1。,,1,3
27,23,2,0,面试题,0,1,3,0,0,0,0,1,0,1,0,0,0,1,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,实现一个函数，检查一棵二叉树是否为二叉搜索树。,,1,4
28,59,2,0,面试题,0,1,3,0,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。如果指定节点没有对应的“下一个”节点，则返回。,,1,4
29,109,2,0,面试题,0,1,2,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。例如，给定如下二叉树:root=[3,5,1,6,2,0,8,null,null,7,4]",,1,3
30,84,2,55,面试题,0,1,3,0,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由组成的二叉搜索树，输出所有可能生成此树的数组。用例保证符合要求的数组数量不超过,"二叉搜索树中的节点数在[0,1000]的范围内1<=节点值<=10^6用例保证符合要求的数组数量不超过5000",1,4
31,131,2,0,面试题,1,1,2,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断T2是否为T1的子树。如果T1有这么一个节点n，其子树与T2一模一样，则T2为T1的子树，也就是说，从节点n处把树砍断，得到的树与T2完全相同。此题相对书上原题略有改动。,,1,5
32,138,1,11,面试题,0,1,2,0,0,0,0,0,1,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。
给定如下二叉树，以及目标和，返回:提示：",节点总数<=10000,1,3
33,111,2,0,面试题,0,0,0,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个整型数字与，以及表示比特位置的与（，且从0位开始计算）。编写一种方法，使对应的二进制数字插入对应的二进制数字的第位区域，不足之处用补齐。具体插入过程如图所示。题目保证从位到位足以容纳，例如：，则区域至少可容纳5位。,,1,1
34,86,2,34,面试题,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。,"32位包括输出中的""0.""这两位。题目保证输入用例的小数位数最多只有",1,3
35,50,2,0,面试题,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个32位整数，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。,,1,2
36,53,2,0,面试题,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。,,1,1
37,33,2,0,面试题,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。,,1,1
38,62,2,0,面试题,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。,,1,1
39,122,2,76,面试题,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,已知一个由像素点组成的单色屏幕，每行均有个像素点，所有像素点初始为，左上角位置为。现将每行的像素点按照「每个像素点」为一组存放在一个中，再依次存入长度为的一维数组中。我们将在屏幕上绘制一条从点到点的直线（即像素点修改为），请返回绘制过后的数组。,用例保证屏幕宽度可被32整除（即一个int不会分布在两行上）1<=length<=10^51<=w<=3*10^50<=x1<=x2<w0<=y<=10,1,3
40,86,2,0,面试题,0,2,0,0,0,1,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。,,1,3
41,166,1,0,面试题,2,2,0,0,0,0,0,0,1,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设想有个机器人坐在一个网格的左上角，网格r行c列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。网格中的障碍物和空位置分别用和来表示。返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为0行0列。如果没有可行的路径，返回空数组。和的值均不超过100。,,1,4
42,98,2,0,面试题,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,魔术索引。在数组中，有所谓的魔术索引，满足条件。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。,,1,2
43,40,1,0,面试题,1,1,0,0,1,0,0,1,0,1,1,0,0,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,幂集。编写一种方法，返回某集合的所有子集。集合中。说明：解集不能包含重复的子集。,,1,3
44,52,2,0,面试题,0,1,0,0,1,1,0,1,0,1,0,0,0,0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,递归乘法。写一个递归函数，不使用*运算符，实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。,,1,3
45,194,2,0,面试题,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,"在经典汉诺塔问题中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1)每次只能移动一个盘子;
(2)盘子只能从柱子顶端滑出移到下一根柱子;
(3)盘子只能叠在比它大的盘子上。请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。你需要原地修改栈。",,1,2
46,45,2,0,面试题,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。,,1,2
47,33,2,0,面试题,1,1,0,0,0,0,0,0,1,1,0,1,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。,,1,2
48,66,1,0,面试题,1,2,0,0,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。说明：解集不能包含重复的子集。例如，给出n=3，生成结果为：,,1,3
49,142,1,123,面试题,2,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。待填充的图像用二维数组表示，元素为初始颜色值。初始坐标点的行坐标为列坐标为。需要填充的新颜色为。「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。,"image和image[0]的长度均在范围[1,50]内。初始坐标点(sr,sc)满足0<=sr<image.length和0<=sc<image[0].lengthimage[i][j]和newColor表示的颜色值在范围[0,65535]内。",1,4
50,82,2,18,面试题,1,1,0,0,0,1,0,0,1,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)注意:你可以假设：,0<=n(总金额)<=1000000,1,3
51,93,1,0,面试题,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,设计一种算法，打印N皇后在N×N棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。本题相对原题做了扩展,,1,2
52,111,2,0,面试题,2,1,0,0,0,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,堆箱子。给你一堆n个箱子，箱子宽wi、深di、高hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。输入使用数组表示每个箱子。,,1,3
53,101,2,12,面试题,1,2,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个布尔表达式和一个期望的布尔结果result，布尔表达式由(false)、(true)、(AND)、(OR)和(XOR)符号组成。实现一个函数，算出有几种可使该表达式得出result值的括号方法。,运算符的数量不超过19个,1,3
54,65,1,13,面试题,2,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定两个排序后的数组A和B，其中A的末端有足够的缓冲空间容纳B。编写一个方法，将B合并入A并排序。初始化A和B的元素数量分别为和。,A.length==n+m,1,3
55,60,1,22,面试题,3,0,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。本题相对原题稍作修改,所有输入均为小写字母。不考虑答案输出的顺序。,1,4
56,97,2,0,面试题,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。,,1,2
57,49,2,0,面试题,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。,,1,3
58,72,1,0,面试题,2,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。现有矩阵matrix如下：给定target=，返回。给定target=，返回。,,1,4
59,116,1,45,面试题,0,1,0,1,0,0,2,0,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,假设你正在读取一串整数。每隔一段时间，你希望能找出数字x的秩(小于或等于x的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：实现方法，每读入一个数字都会调用该方法；实现方法，返回小于或等于x的值的个数。本题相对原题稍作改动,x<=50000track和getRankOfNumber方法的调用次数均不超过2000次,1,4
60,113,1,18,面试题,2,1,0,0,0,0,0,0,1,0,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5,8,4,2,3,4,6}中，{8,6}是峰，{5,2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。",nums.length<=10000,1,3
61,23,1,52,面试题,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,编写一个函数，不用临时变量，直接交换中与的值。,numbers.length==2-2147483647<=numbers[i]<=2147483647,1,2
62,39,1,140,面试题,2,0,1,1,0,0,1,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个方法，找出任意指定单词在一本书中的出现频率。你的实现应该支持如下操作：,WordsFrequency(book)构造函数，参数为字符串数组构成的一本书get(word)查询指定单词在书中出现的频率book[i]中只包含小写字母1<=book.length<=1000001<=book[i].length<=10get函数的调用次数不会超过100000,1,5
63,90,3,26,面试题,0,0,0,0,0,2,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定两条线段（表示为起点和终点），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过。若有多个交点（线段重叠）则返回X值最小的点，X坐标相同则返回Y值最小的点。,坐标绝对值不会超过2^7输入的坐标均是有效的二维坐标,1,2
64,157,3,206,面试题,2,0,0,0,1,0,0,0,0,1,1,0,0,1,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"设计一个算法，判断玩家是否赢了井字游戏。输入是一个NxN的数组棋盘，由字符""""，""X""和""O""组成，其中字符""""代表一个空位。以下是井字游戏的规则：如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（""X""或""O""）；如果游戏以平局结束，则返回""Draw""；如果仍会有行动（游戏未结束），则返回""Pending""。","玩家轮流将字符放入空位（""""）中。第一个玩家总是放字符""O""，且第二个玩家总是放字符""X""。""X""和""O""只允许放置在空位中，不允许对已放有字符的位置进行填充。当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。当所有位置非空时，也算为游戏结束。如果游戏结束，玩家不允许再放置字符。1<=board.length==board[i].length<=100输入一定遵循井字棋规则",1,3
65,37,2,0,面试题,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,设计一个算法，算出n阶乘有多少个尾随零。你算法的时间复杂度应为(log)。,,1,1
66,46,1,83,面试题,2,1,0,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数数组和，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差,"1<=a.length,b.length<=100000-2147483648<=a[i],b[i]<=2147483647正确结果在区间[0,2147483647]",1,4
67,42,1,0,面试题,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,编写一个方法，找出两个数字和中最大的那一个。不得使用if-else或其他比较运算符。,,1,3
68,31,4,0,面试题,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个整数，打印该整数的英文描述。注意：本题与273题相同：,,1,3
69,84,1,125,面试题,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。你的实现应该支持如下操作：,"Operations()构造函数minus(a,b)减法，返回a-bmultiply(a,b)乘法，返回a*bdivide(a,b)除法，返回a/b你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况单个用例的函数调用次数不会超过1000次",1,2
70,196,1,53,面试题,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定N个人的出生年份和死亡年份，第个人的出生年份为，死亡年份为，实现一个方法以计算生存人数最多的年份。你可以假设所有人都出生于1900年至2000年（含1900和2000）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于1908年、死于1909年的人应当被列入1908年和1909年的计数。如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。,0<birth.length==death.length<=10000birth[i]<=death[i],1,2
71,93,1,29,面试题,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,EASY,你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为，长度较长的木板长度为。你必须正好使用块木板。编写一个方法，生成跳水板所有可能的长度。返回的长度需要从小到大排列。,0<shorter<=longer0<=k<=100000,1,2
72,241,1,27,面试题,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与x轴平行。每个正方形的数据包含3个数值，正方形的左下顶点坐标，以及正方形的边长。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标和的返回格式为，要求若，需保证，否则需保证。若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。,square.length==3square[2]>0,0,2
73,129,1,35,面试题,1,0,1,0,0,2,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个二维平面及平面上的N个点列表，其中第个点的坐标为。请找出一条直线，其通过的点的数目最多。设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为，你仅需返回作为答案，若有多条直线穿过了相同数量的点，则选择值较小的直线返回，相同则选择值较小的直线返回。,2<=len(Points)<=300len(Points[i])=2,1,4
74,256,1,59,面试题,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,珠玑妙算游戏（thegameofmastermind）的玩法如下。计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。给定一种颜色组合和一个猜测，编写一个方法，返回猜中和伪猜中的次数，其中为猜中的次数，为伪猜中的次数。,"len(solution)=len(guess)=4solutionguess仅包含""R""""G""""B""""Y""这4种字符",1,3
75,103,1,22,面试题,2,1,2,0,1,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个整数数组，编写一个函数，找出索引和，只要将索引区间的元素排好序，整个数组就是有序的。注意：尽量最小，也就是说，找出符合条件的最短序列。函数返回值为，若不存在这样的和（例如整个数组是有序的），请返回。,0<=len(array)<=1000000,1,6
76,60,1,0,面试题,1,2,0,0,0,0,0,1,0,1,1,0,0,0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,给定一个整数数组，找出总和最大的连续数列，并返回总和。如果你已经实现复杂度为O()的解法，尝试使用更为精妙的分治法求解。,,1,3
77,104,4,76,面试题,2,1,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有两个字符串，即和。字符串由字母和组成，用于描述字符串中的模式。例如，字符串匹配模式（其中是，是），该字符串也匹配像、和这样的模式。但需注意和不能同时表示相同的字符串。编写一个方法判断字符串是否匹配字符串。,"1<=len(pattern)<=10000<=len(value)<=1000你可以假设pattern只包含字母""a""""b""value仅包含小写字母。",1,4
78,116,1,37,面试题,2,2,0,1,0,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,你有一个用于表示一片土地的整数矩阵，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。,0<len(land)<=10000<len(land[i])<=1000,1,5
79,104,2,76,面试题,2,0,1,0,0,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：提示：,"num.length<=1000words.length<=500words[i].length==num.lengthnum中不会出现0,1这两个数字",1,3
80,121,2,38,面试题,2,1,1,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。,"1<=array1.length,array2.length<=100000",1,4
81,270,3,9,面试题,4,0,1,0,0,0,0,1,0,0,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。(1)如果在白色方格上，则翻转方格的颜色，向右(顺时针)转90度，并向前移动一个单位。
(2)如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转90度，并向前移动一个单位。编写程序来模拟蚂蚁执行的前K个动作，并返回最终的网格。网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由表示，白色方格由表示，蚂蚁所在的位置由,,,表示，分别表示蚂蚁左、上、右、下的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。",K<=100000,1,5
82,39,2,46,面试题,2,0,1,0,2,0,0,1,0,1,0,0,0,0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。,"nums.length<=100000-10^5<=nums[i],target<=10^5",1,5
83,231,1,0,面试题,0,0,3,0,0,0,1,1,0,1,0,0,0,1,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,"设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。它应该支持以下操作：获取数据和写入数据。获取数据-如果密钥(key)存在于缓存中，则获取密钥的值（总是正数），否则返回-1。
写入数据-如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。",,1,4
84,83,3,30,面试题,1,0,1,0,0,1,0,0,1,1,0,0,0,1,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。表达式仅包含非负整数，，，，四种运算符和空格。整数除法仅保留整数部分。,你可以假设所给定的表达式都是有效的。使用内置的库函数eval,1,3
85,29,1,19,面试题,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,设计一个函数把两个数字相加。不得使用+或者其他算术运算符。,均可能是负数或0结果不会溢出32位整数,1,2
86,63,2,0,面试题,2,0,1,0,1,1,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,EASY,数组包含从到的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？本题相对书上原题稍作改动,,1,5
87,90,2,20,面试题,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。,array.length<=100000,1,3
88,30,1,7,面试题,0,2,0,0,0,1,0,1,0,1,0,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,编写一个方法，计算从0到n(含n)中数字2出现的次数。提示：,n<=10^9,1,3
89,217,1,20,面试题,2,2,1,1,1,0,0,1,0,1,0,1,0,0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John和Jon本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果John和Jon是相同的，并且Jon和Johnny相同，则John与Johnny也相同，即它们有传递和对称性。在结果列表中，选择的名字作为真实名字。,names.length<=100000,1,7
90,95,1,35,面试题,2,2,0,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。,height.length==weight.length<=10000,1,4
91,86,1,0,面试题,0,1,2,0,0,1,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有些数的素因子只有3，5，7，请设计一个算法找出第k个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是1，3，5，7，9，15，21。,,1,4
92,66,3,0,面试题,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,数组中占比超过一半的元素称之为主要元素。给你一个数组，找出其中的主要元素。若没有，返回。请设计时间复杂度为、空间复杂度为的解决方案。,,1,2
93,89,1,20,面试题,2,0,0,0,0,0,0,0,0,1,1,0,1,0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?提示：,words.length<=100000,1,2
94,121,1,15,面试题,0,1,5,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,二叉树数据结构可用来表示单向链表（其中置空，为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。返回转换后的单向链表的头节点。本题相对原题稍作改动,节点数量不会超过100000。,1,6
95,161,1,79,面试题,2,1,1,1,2,0,0,0,0,1,1,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子已经变成了。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典，不过，有些词没在词典里。假设文章用表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。本题相对原题稍作改动，只需返回未识别的字符数,0<=len(sentence)<=1000dictionary中总字符数不超过150000。你可以认为dictionarysentence中只包含小写字母。,1,7
96,33,1,45,面试题,2,2,1,0,0,0,0,0,0,1,1,0,0,1,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。,"0<=len(arr)<=1000000<=k<=min(100000,len(arr))",1,5
97,87,1,39,面试题,2,0,1,1,0,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一组单词，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。,0<=len(words)<=2001<=len(words[i])<=100,1,4
98,116,3,0,面试题,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,EASY,一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。本题相对原题稍作改动,,1,2
99,77,1,98,面试题,3,0,1,1,1,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定一个较长字符串和一个包含较短字符串的数组，设计一个方法，根据中的每一个较短字符串，对进行搜索。输出中的字符串在里出现的所有位置，其中为出现的所有位置。,0<=len(big)<=10000<=len(smalls[i])<=1000smalls的总字符数不会超过100000。你可以认为smalls中没有重复字符串。所有出现的字符均为英文小写字母。,1,6
100,109,2,41,面试题,1,0,1,0,1,0,0,1,0,1,1,0,0,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。,big.length<=1000001<=small.length<=100000,1,3
101,69,2,18,面试题,1,0,1,0,1,0,0,1,1,0,0,0,1,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个数组，包含从1到N所有的整数，但其中缺了两个数字。你能在O(N)时间内只用O(1)的空间找到它们吗？以任意顺序返回这两个数字均可。,nums.length<=30000,1,3
102,147,1,69,面试题,1,0,1,0,1,0,2,0,0,0,0,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。例如，[2,3,4]的中位数是3[2,3]的中位数是(2+3)/2=2.5设计一个支持以下两种操作的数据结构：",voidaddNum(intnum)-从数据流中添加一个整数到数据结构中。doublefindMedian()-返回目前所有元素的中位数。,1,5
103,51,1,0,面试题,1,1,2,0,1,0,0,0,1,1,0,0,1,0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为1。,,1,5
104,106,2,0,面试题,1,2,1,0,0,0,0,1,0,1,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,MEDIUM,给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词，但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。,,1,4
105,131,2,36,面试题,2,1,0,0,0,0,0,1,0,0,0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,MEDIUM,"给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出4条边皆为黑色像素的最大子方阵。返回一个数组，其中,分别代表子方阵左上角的行号和列号，是子方阵的边长。若有多个满足条件的子方阵，返回最小的，若相同，返回最小的子方阵。若无满足条件的子方阵，返回空数组。",matrix.length==matrix[0].length<=200,1,3
106,115,1,38,面试题,2,1,0,0,1,0,0,1,1,1,0,0,0,0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"给定一个正整数、负整数和0组成的N×M矩阵，编写代码找出元素总和最大的子矩阵。返回一个数组，其中,分别代表子矩阵左上角的行号和列号，,分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。本题相对书上原题稍作改动","1<=matrix.length,matrix[0].length<=200",1,4
107,132,2,48,面试题,2,1,0,1,0,0,0,1,0,1,0,0,1,0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,给定一份单词的清单，设计一个算法，创建由字母组成的面积最大的矩形，其中每一行组成一个单词(自左向右)，每一列也组成一个单词(自上而下)。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。如果有多个面积最大的矩形，输出任意一个均可。一个单词可以重复使用。,words.length<=1000words[i].length<=100数据保证单词足够随机,1,4
108,352,1,35,面试题,2,0,1,0,0,0,0,0,0,1,1,1,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,HARD,"两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1,5,3}和{1,7,2,3}的相似度是0.4，其中，交集的元素有2个，并集的元素有5个。给定一系列的长篇文档，每个文档元素各不相同，并与一个ID相关联。它们的相似度非常“稀疏”，也就是说任选2个文档，相似度都很接近0。请设计一个算法返回每对文档的ID及其相似度。只需输出相似度大于0的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。输入为一个二维数组，表示id为的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于0的文档，其格式为，其中为两个文档中较小的id，为相似度，精确到小数点后4位。以任意顺序返回数组均可。",docs.length<=500docs[i].length<=500,1,3
